{"version":3,"file":"structuredData.esm.js","sources":["../../src/signature/structuredData.ts"],"sourcesContent":["import { serializeCV } from '@stacks/transactions';\nimport { TokenSigner } from 'jsontokens';\nimport { getDefaultSignatureRequestOptions } from '.';\nimport { getKeys } from '../transactions';\nimport {\n  StructuredDataSignatureOptions,\n  StructuredDataSignaturePayload,\n  StructuredDataSignaturePopup,\n  StructuredDataSignatureRequestOptions,\n} from '../types/structuredDataSignature';\nimport { getStacksProvider } from '../utils';\n\nasync function generateTokenAndOpenPopup<T extends StructuredDataSignatureOptions>(\n  options: T,\n  makeTokenFn: (options: T) => Promise<string>\n) {\n  const token = await makeTokenFn({\n    ...getDefaultSignatureRequestOptions(options),\n    ...options,\n  } as T);\n  return openStructuredDataSignaturePopup({ token, options });\n}\n\nasync function signPayload(payload: StructuredDataSignaturePayload, privateKey: string) {\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  return tokenSigner.signAsync({\n    ...payload,\n    message: serializeCV(payload.message).toString('hex'),\n    domain: serializeCV(payload.domain).toString('hex'),\n  } as any);\n}\n\nexport async function signStructuredMessage(options: StructuredDataSignatureRequestOptions) {\n  const { userSession, ..._options } = options;\n  const { privateKey, publicKey } = getKeys(userSession);\n\n  const payload: StructuredDataSignaturePayload = {\n    ..._options,\n    publicKey,\n  };\n\n  return signPayload(payload, privateKey);\n}\n\nasync function openStructuredDataSignaturePopup({ token, options }: StructuredDataSignaturePopup) {\n  const provider = getStacksProvider();\n  if (!provider) {\n    throw new Error('Hiro Wallet not installed.');\n  }\n\n  try {\n    const signatureResponse = await provider.structuredDataSignatureRequest(token);\n\n    options.onFinish?.(signatureResponse);\n  } catch (error) {\n    console.error('[Connect] Error during signature request', error);\n    options.onCancel?.();\n  }\n}\n\nexport function openStructuredDataSignatureRequestPopup(\n  options: StructuredDataSignatureRequestOptions\n) {\n  return generateTokenAndOpenPopup(options, signStructuredMessage);\n}\n"],"names":["options","makeTokenFn","getDefaultSignatureRequestOptions","token","openStructuredDataSignaturePopup","payload","privateKey","tokenSigner","TokenSigner","signAsync","message","serializeCV","toString","domain","userSession","_options","getKeys","publicKey","signPayload","provider","getStacksProvider","Error","structuredDataSignatureRequest","signatureResponse","onFinish","error","onCancel","generateTokenAndOpenPopup","signStructuredMessage"],"mappings":";;;;;;;;;;;;;;;wFAYA,iBACEA,OADF,EAEEC,WAFF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAIsBA,yBACfC,kCAAkCF,UAClCA,SANP;;AAAA;AAIQG,YAAAA,KAJR;AAAA,6CAQSC,iCAAiC;AAAED,cAAAA,OAAAA,KAAF;AAASH,cAAAA,SAAAA;AAAT,cAR1C;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;0EAWA,kBAA2BK,OAA3B,EAAoEC,UAApE;AAAA;AAAA;AAAA;AAAA;AAAA;AACQC,YAAAA,WADR,GACsB,IAAIC,WAAJ,CAAgB,QAAhB,EAA0BF,UAA1B,CADtB;AAAA,8CAISC,YAAYE,SAAZ,cACFJ,OADE;AAELK,cAAAA,SAASC,YAAYN,QAAQK,QAApB,CAA6BE,QAA7B,CAAsC,KAAtC,CAFJ;AAGLC,cAAAA,QAAQF,YAAYN,QAAQQ,OAApB,CAA4BD,QAA5B,CAAqC,KAArC;AAHH,eAJT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;8BAWA;AAAA;AAAA;;;sGAA4CZ;;;;;;;AAClCc,YAAAA,cAA6Bd,QAA7Bc,aAAgBC,yCAAaf;uBACHgB,QAAQF,cAAlCR,sBAAAA,YAAYW,qBAAAA;AAEdZ,YAAAA,uBACDU;AACHE,cAAAA,WAAAA;;8CAGKC,YAAYb,SAASC;;;;;;;;;;;;;;;;;+FAG9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkDH,YAAAA,KAAlD,QAAkDA,KAAlD,EAAyDH,OAAzD,QAAyDA,OAAzD;AACQmB,YAAAA,QADR,GACmBC,mBADnB;;AAAA,gBAEOD,QAFP;AAAA;AAAA;AAAA;;AAAA,kBAGU,IAAIE,KAAJ,CAAU,4BAAV,CAHV;;AAAA;AAAA;AAAA;AAAA,mBAOoCF,SAASG,8BAAT,CAAwCnB,KAAxC,CAPpC;;AAAA;AAOUoB,YAAAA,iBAPV;oBASYC,oCAAAA,SAAWD;AATvB;AAAA;;AAAA;AAAA;AAAA;oBAWYE,MAAM;oBACNC,oCAAAA;;AAZZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;iDAiBE1B,SACA;SACO2B,0BAA0B3B,SAAS4B;;;;;"}