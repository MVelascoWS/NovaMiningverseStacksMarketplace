{"ast":null,"code":"import { Buffer, hexToInt, intToBytes, intToHex } from '@stacks/common';\nimport { MEMO_MAX_LENGTH_BYTES, AddressHashMode, AddressVersion, StacksMessageType, PostConditionPrincipalID, PostConditionType, FungibleConditionCode, NonFungibleConditionCode } from './constants';\nimport { serializePublicKey, deserializePublicKey, isCompressed } from './keys';\nimport { BufferArray, exceedsMaxLengthBytes, hashP2PKH, rightPadHexToLength, hashP2SH, hashP2WSH, hashP2WPKH } from './utils';\nimport { createLPString } from './postcondition-types';\nimport { deserializePayload, serializePayload } from './payload';\nimport { DeserializationError } from './errors';\nimport { deserializeTransactionAuthField, deserializeMessageSignature, serializeMessageSignature, serializeTransactionAuthField } from './signature';\nimport { addressHashModeToVersion, addressFromVersionHash } from './common';\nimport { deserializeCV, serializeCV } from './clarity';\nexport function serializeStacksMessage(message) {\n  switch (message.type) {\n    case StacksMessageType.Address:\n      return serializeAddress(message);\n\n    case StacksMessageType.Principal:\n      return serializePrincipal(message);\n\n    case StacksMessageType.LengthPrefixedString:\n      return serializeLPString(message);\n\n    case StacksMessageType.MemoString:\n      return serializeMemoString(message);\n\n    case StacksMessageType.AssetInfo:\n      return serializeAssetInfo(message);\n\n    case StacksMessageType.PostCondition:\n      return serializePostCondition(message);\n\n    case StacksMessageType.PublicKey:\n      return serializePublicKey(message);\n\n    case StacksMessageType.LengthPrefixedList:\n      return serializeLPList(message);\n\n    case StacksMessageType.Payload:\n      return serializePayload(message);\n\n    case StacksMessageType.TransactionAuthField:\n      return serializeTransactionAuthField(message);\n\n    case StacksMessageType.MessageSignature:\n      return serializeMessageSignature(message);\n  }\n}\nexport function deserializeStacksMessage(bufferReader, type, listType) {\n  switch (type) {\n    case StacksMessageType.Address:\n      return deserializeAddress(bufferReader);\n\n    case StacksMessageType.Principal:\n      return deserializePrincipal(bufferReader);\n\n    case StacksMessageType.LengthPrefixedString:\n      return deserializeLPString(bufferReader);\n\n    case StacksMessageType.MemoString:\n      return deserializeMemoString(bufferReader);\n\n    case StacksMessageType.AssetInfo:\n      return deserializeAssetInfo(bufferReader);\n\n    case StacksMessageType.PostCondition:\n      return deserializePostCondition(bufferReader);\n\n    case StacksMessageType.PublicKey:\n      return deserializePublicKey(bufferReader);\n\n    case StacksMessageType.Payload:\n      return deserializePayload(bufferReader);\n\n    case StacksMessageType.LengthPrefixedList:\n      if (!listType) {\n        throw new DeserializationError('No List Type specified');\n      }\n\n      return deserializeLPList(bufferReader, listType);\n\n    case StacksMessageType.MessageSignature:\n      return deserializeMessageSignature(bufferReader);\n\n    default:\n      throw new Error('Could not recognize StacksMessageType');\n  }\n}\nexport function createEmptyAddress() {\n  return {\n    type: StacksMessageType.Address,\n    version: AddressVersion.MainnetSingleSig,\n    hash160: '0'.repeat(40)\n  };\n}\nexport function addressFromHashMode(hashMode, txVersion, data) {\n  const version = addressHashModeToVersion(hashMode, txVersion);\n  return addressFromVersionHash(version, data);\n}\nexport function addressFromPublicKeys(version, hashMode, numSigs, publicKeys) {\n  if (publicKeys.length === 0) {\n    throw Error('Invalid number of public keys');\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    if (publicKeys.length !== 1 || numSigs !== 1) {\n      throw Error('Invalid number of public keys or signatures');\n    }\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2WPKH || hashMode === AddressHashMode.SerializeP2WSH) {\n    for (let i = 0; i < publicKeys.length; i++) {\n      if (!isCompressed(publicKeys[i])) {\n        throw Error('Public keys must be compressed for segwit');\n      }\n    }\n  }\n\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      return addressFromVersionHash(version, hashP2PKH(publicKeys[0].data));\n\n    case AddressHashMode.SerializeP2WPKH:\n      return addressFromVersionHash(version, hashP2WPKH(publicKeys[0].data));\n\n    case AddressHashMode.SerializeP2SH:\n      return addressFromVersionHash(version, hashP2SH(numSigs, publicKeys.map(serializePublicKey)));\n\n    case AddressHashMode.SerializeP2WSH:\n      return addressFromVersionHash(version, hashP2WSH(numSigs, publicKeys.map(serializePublicKey)));\n  }\n}\nexport function serializeAddress(address) {\n  const bufferArray = new BufferArray();\n  bufferArray.appendHexString(intToHex(address.version, 1));\n  bufferArray.appendHexString(address.hash160);\n  return bufferArray.concatBuffer();\n}\nexport function deserializeAddress(bufferReader) {\n  const version = hexToInt(bufferReader.readBuffer(1).toString('hex'));\n  const data = bufferReader.readBuffer(20).toString('hex');\n  return {\n    type: StacksMessageType.Address,\n    version,\n    hash160: data\n  };\n}\nexport function serializePrincipal(principal) {\n  const bufferArray = new BufferArray();\n  bufferArray.push(Buffer.from([principal.prefix]));\n  bufferArray.push(serializeAddress(principal.address));\n\n  if (principal.prefix === PostConditionPrincipalID.Contract) {\n    bufferArray.push(serializeLPString(principal.contractName));\n  }\n\n  return bufferArray.concatBuffer();\n}\nexport function deserializePrincipal(bufferReader) {\n  const prefix = bufferReader.readUInt8Enum(PostConditionPrincipalID, _ => {\n    throw new DeserializationError('Unexpected Principal payload type: ${n}');\n  });\n  const address = deserializeAddress(bufferReader);\n\n  if (prefix === PostConditionPrincipalID.Standard) {\n    return {\n      type: StacksMessageType.Principal,\n      prefix,\n      address\n    };\n  }\n\n  const contractName = deserializeLPString(bufferReader);\n  return {\n    type: StacksMessageType.Principal,\n    prefix,\n    address,\n    contractName\n  };\n}\nexport function serializeLPString(lps) {\n  const bufferArray = new BufferArray();\n  const contentBuffer = Buffer.from(lps.content);\n  const length = contentBuffer.byteLength;\n  bufferArray.appendHexString(intToHex(length, lps.lengthPrefixBytes));\n  bufferArray.push(contentBuffer);\n  return bufferArray.concatBuffer();\n}\nexport function deserializeLPString(bufferReader, prefixBytes, maxLength) {\n  prefixBytes = prefixBytes ? prefixBytes : 1;\n  const length = hexToInt(bufferReader.readBuffer(prefixBytes).toString('hex'));\n  const content = bufferReader.readBuffer(length).toString();\n  return createLPString(content, prefixBytes, maxLength !== null && maxLength !== void 0 ? maxLength : 128);\n}\nexport function codeBodyString(content) {\n  return createLPString(content, 4, 100000);\n}\nexport function createMemoString(content) {\n  if (content && exceedsMaxLengthBytes(content, MEMO_MAX_LENGTH_BYTES)) {\n    throw new Error(`Memo exceeds maximum length of ${MEMO_MAX_LENGTH_BYTES.toString()} bytes`);\n  }\n\n  return {\n    type: StacksMessageType.MemoString,\n    content\n  };\n}\nexport function serializeMemoString(memoString) {\n  const bufferArray = new BufferArray();\n  const contentBuffer = Buffer.from(memoString.content);\n  const paddedContent = rightPadHexToLength(contentBuffer.toString('hex'), MEMO_MAX_LENGTH_BYTES * 2);\n  bufferArray.push(Buffer.from(paddedContent, 'hex'));\n  return bufferArray.concatBuffer();\n}\nexport function deserializeMemoString(bufferReader) {\n  const content = bufferReader.readBuffer(MEMO_MAX_LENGTH_BYTES).toString();\n  return {\n    type: StacksMessageType.MemoString,\n    content\n  };\n}\nexport function serializeAssetInfo(info) {\n  const bufferArray = new BufferArray();\n  bufferArray.push(serializeAddress(info.address));\n  bufferArray.push(serializeLPString(info.contractName));\n  bufferArray.push(serializeLPString(info.assetName));\n  return bufferArray.concatBuffer();\n}\nexport function deserializeAssetInfo(bufferReader) {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: deserializeAddress(bufferReader),\n    contractName: deserializeLPString(bufferReader),\n    assetName: deserializeLPString(bufferReader)\n  };\n}\nexport function createLPList(values, lengthPrefixBytes) {\n  return {\n    type: StacksMessageType.LengthPrefixedList,\n    lengthPrefixBytes: lengthPrefixBytes || 4,\n    values\n  };\n}\nexport function serializeLPList(lpList) {\n  const list = lpList.values;\n  const bufferArray = new BufferArray();\n  bufferArray.appendHexString(intToHex(list.length, lpList.lengthPrefixBytes));\n\n  for (let index = 0; index < list.length; index++) {\n    bufferArray.push(serializeStacksMessage(list[index]));\n  }\n\n  return bufferArray.concatBuffer();\n}\nexport function deserializeLPList(bufferReader, type, lengthPrefixBytes) {\n  const length = hexToInt(bufferReader.readBuffer(lengthPrefixBytes || 4).toString('hex'));\n  const l = [];\n\n  for (let index = 0; index < length; index++) {\n    switch (type) {\n      case StacksMessageType.Address:\n        l.push(deserializeAddress(bufferReader));\n        break;\n\n      case StacksMessageType.LengthPrefixedString:\n        l.push(deserializeLPString(bufferReader));\n        break;\n\n      case StacksMessageType.MemoString:\n        l.push(deserializeMemoString(bufferReader));\n        break;\n\n      case StacksMessageType.AssetInfo:\n        l.push(deserializeAssetInfo(bufferReader));\n        break;\n\n      case StacksMessageType.PostCondition:\n        l.push(deserializePostCondition(bufferReader));\n        break;\n\n      case StacksMessageType.PublicKey:\n        l.push(deserializePublicKey(bufferReader));\n        break;\n\n      case StacksMessageType.TransactionAuthField:\n        l.push(deserializeTransactionAuthField(bufferReader));\n        break;\n    }\n  }\n\n  return createLPList(l, lengthPrefixBytes);\n}\nexport function serializePostCondition(postCondition) {\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(postCondition.conditionType);\n  bufferArray.push(serializePrincipal(postCondition.principal));\n\n  if (postCondition.conditionType === PostConditionType.Fungible || postCondition.conditionType === PostConditionType.NonFungible) {\n    bufferArray.push(serializeAssetInfo(postCondition.assetInfo));\n  }\n\n  if (postCondition.conditionType === PostConditionType.NonFungible) {\n    bufferArray.push(serializeCV(postCondition.assetName));\n  }\n\n  bufferArray.appendByte(postCondition.conditionCode);\n\n  if (postCondition.conditionType === PostConditionType.STX || postCondition.conditionType === PostConditionType.Fungible) {\n    bufferArray.push(intToBytes(postCondition.amount, false, 8));\n  }\n\n  return bufferArray.concatBuffer();\n}\nexport function deserializePostCondition(bufferReader) {\n  const postConditionType = bufferReader.readUInt8Enum(PostConditionType, n => {\n    throw new DeserializationError(`Could not read ${n} as PostConditionType`);\n  });\n  const principal = deserializePrincipal(bufferReader);\n  let conditionCode;\n  let assetInfo;\n  let amount;\n\n  switch (postConditionType) {\n    case PostConditionType.STX:\n      conditionCode = bufferReader.readUInt8Enum(FungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      amount = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.STX,\n        principal,\n        conditionCode,\n        amount\n      };\n\n    case PostConditionType.Fungible:\n      assetInfo = deserializeAssetInfo(bufferReader);\n      conditionCode = bufferReader.readUInt8Enum(FungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      amount = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.Fungible,\n        principal,\n        conditionCode,\n        amount,\n        assetInfo\n      };\n\n    case PostConditionType.NonFungible:\n      assetInfo = deserializeAssetInfo(bufferReader);\n      const assetName = deserializeCV(bufferReader);\n      conditionCode = bufferReader.readUInt8Enum(NonFungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.NonFungible,\n        principal,\n        conditionCode,\n        assetInfo,\n        assetName\n      };\n  }\n}","map":{"version":3,"mappings":"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","names":["Buffer","hexToInt","intToBytes","intToHex","MEMO_MAX_LENGTH_BYTES","AddressHashMode","AddressVersion","StacksMessageType","PostConditionPrincipalID","PostConditionType","FungibleConditionCode","NonFungibleConditionCode","serializePublicKey","deserializePublicKey","isCompressed","BufferArray","exceedsMaxLengthBytes","hashP2PKH","rightPadHexToLength","hashP2SH","hashP2WSH","hashP2WPKH","createLPString","deserializePayload","serializePayload","DeserializationError","deserializeTransactionAuthField","deserializeMessageSignature","serializeMessageSignature","serializeTransactionAuthField","addressHashModeToVersion","addressFromVersionHash","deserializeCV","serializeCV","serializeStacksMessage","message","type","Address","serializeAddress","Principal","serializePrincipal","LengthPrefixedString","serializeLPString","MemoString","serializeMemoString","AssetInfo","serializeAssetInfo","PostCondition","serializePostCondition","PublicKey","LengthPrefixedList","serializeLPList","Payload","TransactionAuthField","MessageSignature","deserializeStacksMessage","bufferReader","listType","deserializeAddress","deserializePrincipal","deserializeLPString","deserializeMemoString","deserializeAssetInfo","deserializePostCondition","deserializeLPList","Error","createEmptyAddress","version","MainnetSingleSig","hash160","repeat","addressFromHashMode","hashMode","txVersion","data","addressFromPublicKeys","numSigs","publicKeys","length","SerializeP2PKH","SerializeP2WPKH","SerializeP2WSH","i","SerializeP2SH","map","address","bufferArray","appendHexString","concatBuffer","readBuffer","toString","principal","push","from","prefix","Contract","contractName","readUInt8Enum","_","Standard","lps","contentBuffer","content","byteLength","lengthPrefixBytes","prefixBytes","maxLength","codeBodyString","createMemoString","memoString","paddedContent","info","assetName","createLPList","values","lpList","list","index","l","postCondition","appendByte","conditionType","Fungible","NonFungible","assetInfo","conditionCode","STX","amount","postConditionType","n","BigInt"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\transactions\\src\\types.ts"],"sourcesContent":["import { Buffer, hexToInt, intToBytes, intToHex } from '@stacks/common';\nimport {\n  MEMO_MAX_LENGTH_BYTES,\n  AddressHashMode,\n  AddressVersion,\n  TransactionVersion,\n  StacksMessageType,\n  PostConditionPrincipalID,\n  PostConditionType,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n} from './constants';\n\nimport { StacksPublicKey, serializePublicKey, deserializePublicKey, isCompressed } from './keys';\n\nimport {\n  BufferArray,\n  exceedsMaxLengthBytes,\n  hashP2PKH,\n  rightPadHexToLength,\n  hashP2SH,\n  hashP2WSH,\n  hashP2WPKH,\n} from './utils';\n\nimport { BufferReader } from './bufferReader';\nimport {\n  PostCondition,\n  StandardPrincipal,\n  ContractPrincipal,\n  PostConditionPrincipal,\n  LengthPrefixedString,\n  AssetInfo,\n  createLPString,\n} from './postcondition-types';\nimport { Payload, deserializePayload, serializePayload } from './payload';\nimport { DeserializationError } from './errors';\nimport {\n  deserializeTransactionAuthField,\n  deserializeMessageSignature,\n  serializeMessageSignature,\n  serializeTransactionAuthField,\n  TransactionAuthField,\n} from './signature';\nimport {\n  MessageSignature,\n  Address,\n  addressHashModeToVersion,\n  addressFromVersionHash,\n} from './common';\nimport { deserializeCV, serializeCV } from './clarity';\nexport type StacksMessage =\n  | Address\n  | PostConditionPrincipal\n  | LengthPrefixedString\n  | LengthPrefixedList\n  | Payload\n  | MemoString\n  | AssetInfo\n  | PostCondition\n  | StacksPublicKey\n  | TransactionAuthField\n  | MessageSignature;\n\nexport function serializeStacksMessage(message: StacksMessage): Buffer {\n  switch (message.type) {\n    case StacksMessageType.Address:\n      return serializeAddress(message);\n    case StacksMessageType.Principal:\n      return serializePrincipal(message);\n    case StacksMessageType.LengthPrefixedString:\n      return serializeLPString(message);\n    case StacksMessageType.MemoString:\n      return serializeMemoString(message);\n    case StacksMessageType.AssetInfo:\n      return serializeAssetInfo(message);\n    case StacksMessageType.PostCondition:\n      return serializePostCondition(message);\n    case StacksMessageType.PublicKey:\n      return serializePublicKey(message);\n    case StacksMessageType.LengthPrefixedList:\n      return serializeLPList(message);\n    case StacksMessageType.Payload:\n      return serializePayload(message);\n    case StacksMessageType.TransactionAuthField:\n      return serializeTransactionAuthField(message);\n    case StacksMessageType.MessageSignature:\n      return serializeMessageSignature(message);\n  }\n}\n\nexport function deserializeStacksMessage(\n  bufferReader: BufferReader,\n  type: StacksMessageType,\n  listType?: StacksMessageType\n): StacksMessage {\n  switch (type) {\n    case StacksMessageType.Address:\n      return deserializeAddress(bufferReader);\n    case StacksMessageType.Principal:\n      return deserializePrincipal(bufferReader);\n    case StacksMessageType.LengthPrefixedString:\n      return deserializeLPString(bufferReader);\n    case StacksMessageType.MemoString:\n      return deserializeMemoString(bufferReader);\n    case StacksMessageType.AssetInfo:\n      return deserializeAssetInfo(bufferReader);\n    case StacksMessageType.PostCondition:\n      return deserializePostCondition(bufferReader);\n    case StacksMessageType.PublicKey:\n      return deserializePublicKey(bufferReader);\n    case StacksMessageType.Payload:\n      return deserializePayload(bufferReader);\n    case StacksMessageType.LengthPrefixedList:\n      if (!listType) {\n        throw new DeserializationError('No List Type specified');\n      }\n      return deserializeLPList(bufferReader, listType);\n    case StacksMessageType.MessageSignature:\n      return deserializeMessageSignature(bufferReader);\n    default:\n      throw new Error('Could not recognize StacksMessageType');\n  }\n}\n\nexport function createEmptyAddress(): Address {\n  return {\n    type: StacksMessageType.Address,\n    version: AddressVersion.MainnetSingleSig,\n    hash160: '0'.repeat(40),\n  };\n}\n\nexport function addressFromHashMode(\n  hashMode: AddressHashMode,\n  txVersion: TransactionVersion,\n  data: string\n): Address {\n  const version = addressHashModeToVersion(hashMode, txVersion);\n  return addressFromVersionHash(version, data);\n}\n\nexport function addressFromPublicKeys(\n  version: AddressVersion,\n  hashMode: AddressHashMode,\n  numSigs: number,\n  publicKeys: StacksPublicKey[]\n): Address {\n  if (publicKeys.length === 0) {\n    throw Error('Invalid number of public keys');\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    if (publicKeys.length !== 1 || numSigs !== 1) {\n      throw Error('Invalid number of public keys or signatures');\n    }\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2WPKH || hashMode === AddressHashMode.SerializeP2WSH) {\n    for (let i = 0; i < publicKeys.length; i++) {\n      if (!isCompressed(publicKeys[i])) {\n        throw Error('Public keys must be compressed for segwit');\n      }\n    }\n  }\n\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      return addressFromVersionHash(version, hashP2PKH(publicKeys[0].data));\n    case AddressHashMode.SerializeP2WPKH:\n      return addressFromVersionHash(version, hashP2WPKH(publicKeys[0].data));\n    case AddressHashMode.SerializeP2SH:\n      return addressFromVersionHash(version, hashP2SH(numSigs, publicKeys.map(serializePublicKey)));\n    case AddressHashMode.SerializeP2WSH:\n      return addressFromVersionHash(\n        version,\n        hashP2WSH(numSigs, publicKeys.map(serializePublicKey))\n      );\n  }\n}\n\nexport function serializeAddress(address: Address): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendHexString(intToHex(address.version, 1));\n  bufferArray.appendHexString(address.hash160);\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeAddress(bufferReader: BufferReader): Address {\n  const version = hexToInt(bufferReader.readBuffer(1).toString('hex'));\n  const data = bufferReader.readBuffer(20).toString('hex');\n\n  return { type: StacksMessageType.Address, version, hash160: data };\n}\n\nexport function serializePrincipal(principal: PostConditionPrincipal): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(Buffer.from([principal.prefix]));\n  bufferArray.push(serializeAddress(principal.address));\n  if (principal.prefix === PostConditionPrincipalID.Contract) {\n    bufferArray.push(serializeLPString(principal.contractName));\n  }\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializePrincipal(bufferReader: BufferReader): PostConditionPrincipal {\n  const prefix = bufferReader.readUInt8Enum(PostConditionPrincipalID, _ => {\n    throw new DeserializationError('Unexpected Principal payload type: ${n}');\n  });\n  const address = deserializeAddress(bufferReader);\n  if (prefix === PostConditionPrincipalID.Standard) {\n    return { type: StacksMessageType.Principal, prefix, address } as StandardPrincipal;\n  }\n  const contractName = deserializeLPString(bufferReader);\n  return {\n    type: StacksMessageType.Principal,\n    prefix,\n    address,\n    contractName,\n  } as ContractPrincipal;\n}\n\nexport function serializeLPString(lps: LengthPrefixedString) {\n  const bufferArray: BufferArray = new BufferArray();\n  const contentBuffer = Buffer.from(lps.content);\n  const length = contentBuffer.byteLength;\n  bufferArray.appendHexString(intToHex(length, lps.lengthPrefixBytes));\n  bufferArray.push(contentBuffer);\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeLPString(\n  bufferReader: BufferReader,\n  prefixBytes?: number,\n  maxLength?: number\n): LengthPrefixedString {\n  prefixBytes = prefixBytes ? prefixBytes : 1;\n  const length = hexToInt(bufferReader.readBuffer(prefixBytes).toString('hex'));\n  const content = bufferReader.readBuffer(length).toString();\n  return createLPString(content, prefixBytes, maxLength ?? 128);\n}\n\nexport function codeBodyString(content: string): LengthPrefixedString {\n  return createLPString(content, 4, 100000);\n}\n\nexport interface MemoString {\n  readonly type: StacksMessageType.MemoString;\n  readonly content: string;\n}\n\nexport function createMemoString(content: string): MemoString {\n  if (content && exceedsMaxLengthBytes(content, MEMO_MAX_LENGTH_BYTES)) {\n    throw new Error(`Memo exceeds maximum length of ${MEMO_MAX_LENGTH_BYTES.toString()} bytes`);\n  }\n  return { type: StacksMessageType.MemoString, content };\n}\n\nexport function serializeMemoString(memoString: MemoString): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  const contentBuffer = Buffer.from(memoString.content);\n  const paddedContent = rightPadHexToLength(\n    contentBuffer.toString('hex'),\n    MEMO_MAX_LENGTH_BYTES * 2\n  );\n  bufferArray.push(Buffer.from(paddedContent, 'hex'));\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeMemoString(bufferReader: BufferReader): MemoString {\n  const content = bufferReader.readBuffer(MEMO_MAX_LENGTH_BYTES).toString();\n  return { type: StacksMessageType.MemoString, content };\n}\n\nexport function serializeAssetInfo(info: AssetInfo): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(serializeAddress(info.address));\n  bufferArray.push(serializeLPString(info.contractName));\n  bufferArray.push(serializeLPString(info.assetName));\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeAssetInfo(bufferReader: BufferReader): AssetInfo {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: deserializeAddress(bufferReader),\n    contractName: deserializeLPString(bufferReader),\n    assetName: deserializeLPString(bufferReader),\n  };\n}\n\nexport interface LengthPrefixedList {\n  readonly type: StacksMessageType.LengthPrefixedList;\n  readonly lengthPrefixBytes: number;\n  readonly values: StacksMessage[];\n}\n\nexport function createLPList<T extends StacksMessage>(\n  values: T[],\n  lengthPrefixBytes?: number\n): LengthPrefixedList {\n  return {\n    type: StacksMessageType.LengthPrefixedList,\n    lengthPrefixBytes: lengthPrefixBytes || 4,\n    values,\n  };\n}\n\nexport function serializeLPList(lpList: LengthPrefixedList): Buffer {\n  const list = lpList.values;\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendHexString(intToHex(list.length, lpList.lengthPrefixBytes));\n  for (let index = 0; index < list.length; index++) {\n    bufferArray.push(serializeStacksMessage(list[index]));\n  }\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeLPList(\n  bufferReader: BufferReader,\n  type: StacksMessageType,\n  lengthPrefixBytes?: number\n): LengthPrefixedList {\n  const length = hexToInt(bufferReader.readBuffer(lengthPrefixBytes || 4).toString('hex'));\n  const l: StacksMessage[] = [];\n  for (let index = 0; index < length; index++) {\n    switch (type) {\n      case StacksMessageType.Address:\n        l.push(deserializeAddress(bufferReader));\n        break;\n      case StacksMessageType.LengthPrefixedString:\n        l.push(deserializeLPString(bufferReader));\n        break;\n      case StacksMessageType.MemoString:\n        l.push(deserializeMemoString(bufferReader));\n        break;\n      case StacksMessageType.AssetInfo:\n        l.push(deserializeAssetInfo(bufferReader));\n        break;\n      case StacksMessageType.PostCondition:\n        l.push(deserializePostCondition(bufferReader));\n        break;\n      case StacksMessageType.PublicKey:\n        l.push(deserializePublicKey(bufferReader));\n        break;\n      case StacksMessageType.TransactionAuthField:\n        l.push(deserializeTransactionAuthField(bufferReader));\n        break;\n    }\n  }\n  return createLPList(l, lengthPrefixBytes);\n}\n\nexport function serializePostCondition(postCondition: PostCondition): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(postCondition.conditionType);\n  bufferArray.push(serializePrincipal(postCondition.principal));\n\n  if (\n    postCondition.conditionType === PostConditionType.Fungible ||\n    postCondition.conditionType === PostConditionType.NonFungible\n  ) {\n    bufferArray.push(serializeAssetInfo(postCondition.assetInfo));\n  }\n\n  if (postCondition.conditionType === PostConditionType.NonFungible) {\n    bufferArray.push(serializeCV(postCondition.assetName));\n  }\n\n  bufferArray.appendByte(postCondition.conditionCode);\n\n  if (\n    postCondition.conditionType === PostConditionType.STX ||\n    postCondition.conditionType === PostConditionType.Fungible\n  ) {\n    bufferArray.push(intToBytes(postCondition.amount, false, 8));\n  }\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializePostCondition(bufferReader: BufferReader): PostCondition {\n  const postConditionType = bufferReader.readUInt8Enum(PostConditionType, n => {\n    throw new DeserializationError(`Could not read ${n} as PostConditionType`);\n  });\n\n  const principal = deserializePrincipal(bufferReader);\n\n  let conditionCode;\n  let assetInfo;\n  let amount: bigint;\n  switch (postConditionType) {\n    case PostConditionType.STX:\n      conditionCode = bufferReader.readUInt8Enum(FungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      amount = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.STX,\n        principal,\n        conditionCode,\n        amount,\n      };\n    case PostConditionType.Fungible:\n      assetInfo = deserializeAssetInfo(bufferReader);\n      conditionCode = bufferReader.readUInt8Enum(FungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      amount = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.Fungible,\n        principal,\n        conditionCode,\n        amount,\n        assetInfo,\n      };\n    case PostConditionType.NonFungible:\n      assetInfo = deserializeAssetInfo(bufferReader);\n      const assetName = deserializeCV(bufferReader);\n      conditionCode = bufferReader.readUInt8Enum(NonFungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.NonFungible,\n        principal,\n        conditionCode,\n        assetInfo,\n        assetName,\n      };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}