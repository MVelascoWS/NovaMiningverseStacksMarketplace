{"ast":null,"code":"import { asyncToGenerator as _asyncToGenerator, extends as _extends, objectWithoutPropertiesLoose as _objectWithoutPropertiesLoose } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport _regeneratorRuntime from 'regenerator-runtime';\nimport { TokenSigner } from 'jsontokens';\nimport { getStacksProvider } from '../utils.esm.js';\nimport { serializeCV } from '@stacks/transactions';\nimport { getKeys } from '../transactions/index.esm.js';\nimport { getDefaultSignatureRequestOptions } from './index.esm.js';\nvar _excluded = [\"userSession\"];\n\nfunction generateTokenAndOpenPopup(_x, _x2) {\n  return _generateTokenAndOpenPopup.apply(this, arguments);\n}\n\nfunction _generateTokenAndOpenPopup() {\n  _generateTokenAndOpenPopup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(options, makeTokenFn) {\n    var token;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return makeTokenFn(_extends({}, getDefaultSignatureRequestOptions(options), options));\n\n          case 2:\n            token = _context.sent;\n            return _context.abrupt(\"return\", openStructuredDataSignaturePopup({\n              token: token,\n              options: options\n            }));\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _generateTokenAndOpenPopup.apply(this, arguments);\n}\n\nfunction signPayload(_x3, _x4) {\n  return _signPayload.apply(this, arguments);\n}\n\nfunction _signPayload() {\n  _signPayload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(payload, privateKey) {\n    var tokenSigner;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            tokenSigner = new TokenSigner(\"ES256k\", privateKey);\n            return _context2.abrupt(\"return\", tokenSigner.signAsync(_extends({}, payload, {\n              message: serializeCV(payload.message).toString(\"hex\"),\n              domain: serializeCV(payload.domain).toString(\"hex\")\n            })));\n\n          case 2:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _signPayload.apply(this, arguments);\n}\n\nfunction signStructuredMessage(_x5) {\n  return _signStructuredMessage.apply(this, arguments);\n}\n\nfunction _signStructuredMessage() {\n  _signStructuredMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(options) {\n    var userSession, _options, _getKeys, privateKey, publicKey, payload;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            userSession = options.userSession, _options = _objectWithoutPropertiesLoose(options, _excluded);\n            _getKeys = getKeys(userSession), privateKey = _getKeys.privateKey, publicKey = _getKeys.publicKey;\n            payload = _extends({}, _options, {\n              publicKey: publicKey\n            });\n            return _context3.abrupt(\"return\", signPayload(payload, privateKey));\n\n          case 4:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _signStructuredMessage.apply(this, arguments);\n}\n\nfunction openStructuredDataSignaturePopup(_x6) {\n  return _openStructuredDataSignaturePopup.apply(this, arguments);\n}\n\nfunction _openStructuredDataSignaturePopup() {\n  _openStructuredDataSignaturePopup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref) {\n    var token, options, provider, signatureResponse;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            token = _ref.token, options = _ref.options;\n            provider = getStacksProvider();\n\n            if (provider) {\n              _context4.next = 4;\n              break;\n            }\n\n            throw new Error(\"Hiro Wallet not installed.\");\n\n          case 4:\n            _context4.prev = 4;\n            _context4.next = 7;\n            return provider.structuredDataSignatureRequest(token);\n\n          case 7:\n            signatureResponse = _context4.sent;\n            options.onFinish == null ? void 0 : options.onFinish(signatureResponse);\n            _context4.next = 15;\n            break;\n\n          case 11:\n            _context4.prev = 11;\n            _context4.t0 = _context4[\"catch\"](4);\n            console.error(\"[Connect] Error during signature request\", _context4.t0);\n            options.onCancel == null ? void 0 : options.onCancel();\n\n          case 15:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[4, 11]]);\n  }));\n  return _openStructuredDataSignaturePopup.apply(this, arguments);\n}\n\nfunction openStructuredDataSignatureRequestPopup(options) {\n  return generateTokenAndOpenPopup(options, signStructuredMessage);\n}\n\nexport { openStructuredDataSignatureRequestPopup, signStructuredMessage };","map":{"version":3,"mappings":";;;;;;;;;;;;;;wFAYA,iBACEA,OADF,EAEEC,WAFF;IAAA;IAAA;MAAA;QAAA;UAAA;YAAAC;YAAA,OAIsBD,yBACfE,kCAAkCH,OAAlCG,CADeF,EAEfD,OAFeC,EAJtB;;UAAA;YAIQG,KAJR,gBAIQA;YAJR,iCAQSC,iCAAiC;cAAED,YAAF;cAASJ;YAAT,CAAjCK,CART;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA;;;;;;;;;0EAWA,kBAA2BC,OAA3B,EAAoEC,UAApE;IAAA;IAAA;MAAA;QAAA;UAAA;YACQC,WADR,GACsB,IAAIC,WAAJ,CAAgB,QAAhB,EAA0BF,UAA1B,CAAdC;YADR,kCAISA,YAAYE,SAAZF,cACFF,OADE;cAELK,SAASC,YAAYN,QAAQK,OAApBC,EAA6BC,QAA7BD,CAAsC,KAAtCA,CAFJ;cAGLE,QAAQF,YAAYN,QAAQQ,MAApBF,EAA4BC,QAA5BD,CAAqC,KAArCA;YAHH,GAJT;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA;;;;+BAWAG;EAAA;AAAA;;;sGAA4Cf;;;;;;;YAClCgB,cAA6BhB,QAA7BgB,aAAgBC,yCAAajB,OAAbiB,EAAajB,SAAbiB,CAAhBD;uBAC0BE,QAAQF,WAARE,GAA1BX,kCAAYY;YAEdb,uBACDW,QADCX,EACDW;cACHE;YADGF,CADCX;8CAKCc,YAAYd,OAAZc,EAAqBb,UAArBa;;;;;;;;;;;;;;;;;+FAGT;IAAA;IAAA;MAAA;QAAA;UAAA;YAAkDhB,KAAlD,QAAkDA,OAAOJ,OAAzD,QAAyDA,OAAPI;YAC1CiB,QADR,GACmBC,mBAAXD;;YADR,IAEOA,QAFP;cAAAE;cAAA;YAAA;;YAAA,MAGU,IAAIC,KAAJ,CAAU,4BAAV,CAHV;;UAAA;YAAAD;YAAAA;YAAA,OAOoCF,SAASI,8BAATJ,CAAwCjB,KAAxCiB,CAPpC;;UAAA;YAOUK,iBAPV,iBAOUA;oBAEEC,6CAAWD,iBAAXC;YATZJ;YAAA;;UAAA;YAAAA;YAAAA;oBAWYK,MAAM;oBACNC;;UAZZ;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA;;;;iDAiBE7B,SACA;SACO8B,0BAA0B9B,OAA1B8B,EAAmCC,qBAAnCD","names":["options","makeTokenFn","_context","getDefaultSignatureRequestOptions","token","openStructuredDataSignaturePopup","payload","privateKey","tokenSigner","TokenSigner","signAsync","message","serializeCV","toString","domain","_x5","userSession","_options","getKeys","publicKey","signPayload","provider","getStacksProvider","_context4","Error","structuredDataSignatureRequest","signatureResponse","onFinish","error","onCancel","generateTokenAndOpenPopup","signStructuredMessage"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\connect-react\\node_modules\\@stacks\\connect\\src\\signature\\structuredData.ts"],"sourcesContent":["import { serializeCV } from '@stacks/transactions';\nimport { TokenSigner } from 'jsontokens';\nimport { getDefaultSignatureRequestOptions } from '.';\nimport { getKeys } from '../transactions';\nimport {\n  StructuredDataSignatureOptions,\n  StructuredDataSignaturePayload,\n  StructuredDataSignaturePopup,\n  StructuredDataSignatureRequestOptions,\n} from '../types/structuredDataSignature';\nimport { getStacksProvider } from '../utils';\n\nasync function generateTokenAndOpenPopup<T extends StructuredDataSignatureOptions>(\n  options: T,\n  makeTokenFn: (options: T) => Promise<string>\n) {\n  const token = await makeTokenFn({\n    ...getDefaultSignatureRequestOptions(options),\n    ...options,\n  } as T);\n  return openStructuredDataSignaturePopup({ token, options });\n}\n\nasync function signPayload(payload: StructuredDataSignaturePayload, privateKey: string) {\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  return tokenSigner.signAsync({\n    ...payload,\n    message: serializeCV(payload.message).toString('hex'),\n    domain: serializeCV(payload.domain).toString('hex'),\n  } as any);\n}\n\nexport async function signStructuredMessage(options: StructuredDataSignatureRequestOptions) {\n  const { userSession, ..._options } = options;\n  const { privateKey, publicKey } = getKeys(userSession);\n\n  const payload: StructuredDataSignaturePayload = {\n    ..._options,\n    publicKey,\n  };\n\n  return signPayload(payload, privateKey);\n}\n\nasync function openStructuredDataSignaturePopup({ token, options }: StructuredDataSignaturePopup) {\n  const provider = getStacksProvider();\n  if (!provider) {\n    throw new Error('Hiro Wallet not installed.');\n  }\n\n  try {\n    const signatureResponse = await provider.structuredDataSignatureRequest(token);\n\n    options.onFinish?.(signatureResponse);\n  } catch (error) {\n    console.error('[Connect] Error during signature request', error);\n    options.onCancel?.();\n  }\n}\n\nexport function openStructuredDataSignatureRequestPopup(\n  options: StructuredDataSignatureRequestOptions\n) {\n  return generateTokenAndOpenPopup(options, signStructuredMessage);\n}\n"]},"metadata":{},"sourceType":"module"}