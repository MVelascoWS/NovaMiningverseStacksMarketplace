{"ast":null,"code":"import { asyncToGenerator as _asyncToGenerator, extends as _extends, objectWithoutPropertiesLoose as _objectWithoutPropertiesLoose } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport _regeneratorRuntime from 'regenerator-runtime';\nimport { AppConfig, UserSession } from '@stacks/auth';\nimport { SECP256K1Client, createUnsecuredToken, TokenSigner } from 'jsontokens';\nimport { getStacksProvider } from '../utils.esm.js';\nimport { TransactionTypes } from '../types/transactions.esm.js';\nimport { ChainID, serializeCV, serializePostCondition, deserializeTransaction, BufferReader } from '@stacks/transactions';\nimport { StacksTestnet } from '@stacks/network';\nvar _excluded = [\"functionArgs\", \"appDetails\", \"userSession\"],\n    _excluded2 = [\"appDetails\", \"userSession\"],\n    _excluded3 = [\"amount\", \"appDetails\", \"userSession\"];\n\nvar getUserSession = function getUserSession(_userSession) {\n  var userSession = _userSession;\n\n  if (!userSession) {\n    var appConfig = new AppConfig([\"store_write\"], document.location.href);\n    userSession = new UserSession({\n      appConfig: appConfig\n    });\n  }\n\n  return userSession;\n};\n\nfunction hasAppPrivateKey(userSession) {\n  try {\n    var session = getUserSession(userSession).loadUserData();\n    return session.appPrivateKey;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar getKeys = function getKeys(_userSession) {\n  var userSession = getUserSession(_userSession);\n  var privateKey = userSession.loadUserData().appPrivateKey;\n  var publicKey = SECP256K1Client.derivePublicKey(privateKey);\n  return {\n    privateKey: privateKey,\n    publicKey: publicKey\n  };\n};\n\nfunction getStxAddress(options) {\n  var _userSession$loadUser, _chainIdToKey;\n\n  var stxAddress = options.stxAddress,\n      userSession = options.userSession,\n      network = options.network;\n  if (stxAddress) return stxAddress;\n  if (!userSession || !network) return void 0;\n  var stxAddresses = userSession == null ? void 0 : (_userSession$loadUser = userSession.loadUserData().profile) == null ? void 0 : _userSession$loadUser.stxAddress;\n  var chainIdToKey = (_chainIdToKey = {}, _chainIdToKey[ChainID.Mainnet] = \"mainnet\", _chainIdToKey[ChainID.Testnet] = \"testnet\", _chainIdToKey);\n  var address = stxAddresses == null ? void 0 : stxAddresses[chainIdToKey[network.chainId]];\n  return address;\n}\n\nfunction getDefaults(options) {\n  var network = options.network || new StacksTestnet();\n\n  if (hasAppPrivateKey(options.userSession)) {\n    var userSession = getUserSession(options.userSession);\n\n    var defaults = _extends({}, options, {\n      network: network,\n      userSession: userSession\n    });\n\n    return _extends({\n      stxAddress: getStxAddress(defaults)\n    }, defaults);\n  }\n\n  return _extends({}, options, {\n    network: network\n  });\n}\n\nfunction encodePostConditions(postConditions) {\n  return postConditions.map(function (pc) {\n    return serializePostCondition(pc).toString(\"hex\");\n  });\n}\n\nfunction signPayload(_x, _x2) {\n  return _signPayload.apply(this, arguments);\n}\n\nfunction _signPayload() {\n  _signPayload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(payload, privateKey) {\n    var postConditions, tokenSigner;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            postConditions = payload.postConditions;\n\n            if (postConditions && typeof postConditions[0] !== \"string\") {\n              postConditions = encodePostConditions(postConditions);\n            }\n\n            tokenSigner = new TokenSigner(\"ES256k\", privateKey);\n            return _context5.abrupt(\"return\", tokenSigner.signAsync(_extends({}, payload, {\n              postConditions: postConditions\n            })));\n\n          case 4:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _signPayload.apply(this, arguments);\n}\n\nfunction createUnsignedTransactionPayload(payload) {\n  var postConditions = payload.postConditions;\n\n  if (postConditions && typeof postConditions[0] !== \"string\") {\n    postConditions = encodePostConditions(postConditions);\n  }\n\n  return createUnsecuredToken(_extends({}, payload, {\n    postConditions: postConditions\n  }));\n}\n\nvar openTransactionPopup = /*#__PURE__*/function () {\n  var _ref2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n    var token, options, provider, txResponse, txRaw, txBuffer, stacksTransaction;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            token = _ref.token, options = _ref.options;\n            provider = getStacksProvider();\n\n            if (provider) {\n              _context.next = 4;\n              break;\n            }\n\n            throw new Error(\"Hiro Wallet not installed\");\n\n          case 4:\n            _context.prev = 4;\n            _context.next = 7;\n            return provider.transactionRequest(token);\n\n          case 7:\n            txResponse = _context.sent;\n            txRaw = txResponse.txRaw;\n            txBuffer = Buffer.from(txRaw.replace(/^0x/, \"\"), \"hex\");\n            stacksTransaction = deserializeTransaction(new BufferReader(txBuffer));\n\n            if (!(\"sponsored\" in options && options.sponsored)) {\n              _context.next = 14;\n              break;\n            }\n\n            options.onFinish == null ? void 0 : options.onFinish(_extends({}, txResponse, {\n              stacksTransaction: stacksTransaction\n            }));\n            return _context.abrupt(\"return\");\n\n          case 14:\n            options.onFinish == null ? void 0 : options.onFinish(_extends({}, txResponse, {\n              stacksTransaction: stacksTransaction\n            }));\n            _context.next = 21;\n            break;\n\n          case 17:\n            _context.prev = 17;\n            _context.t0 = _context[\"catch\"](4);\n            console.error(\"[Connect] Error during transaction request\", _context.t0);\n            options.onCancel == null ? void 0 : options.onCancel();\n\n          case 21:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[4, 17]]);\n  }));\n\n  return function openTransactionPopup(_x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar makeContractCallToken = /*#__PURE__*/function () {\n  var _ref3 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(options) {\n    var functionArgs, appDetails, userSession, _options, args, _getKeys, privateKey, publicKey, payload2, payload;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            functionArgs = options.functionArgs, appDetails = options.appDetails, userSession = options.userSession, _options = _objectWithoutPropertiesLoose(options, _excluded);\n            args = functionArgs.map(function (arg) {\n              if (typeof arg === \"string\") {\n                return arg;\n              }\n\n              return serializeCV(arg).toString(\"hex\");\n            });\n\n            if (!hasAppPrivateKey(userSession)) {\n              _context2.next = 7;\n              break;\n            }\n\n            _getKeys = getKeys(userSession), privateKey = _getKeys.privateKey, publicKey = _getKeys.publicKey;\n            payload2 = _extends({}, _options, {\n              functionArgs: args,\n              txType: TransactionTypes.ContractCall,\n              publicKey: publicKey\n            });\n            if (appDetails) payload2.appDetails = appDetails;\n            return _context2.abrupt(\"return\", signPayload(payload2, privateKey));\n\n          case 7:\n            payload = _extends({}, _options, {\n              functionArgs: args,\n              txType: TransactionTypes.ContractCall\n            });\n            if (appDetails) payload.appDetails = appDetails;\n            return _context2.abrupt(\"return\", createUnsignedTransactionPayload(payload));\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function makeContractCallToken(_x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar makeContractDeployToken = /*#__PURE__*/function () {\n  var _ref4 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(options) {\n    var appDetails, userSession, _options, _getKeys2, privateKey, publicKey, payload2, payload;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            appDetails = options.appDetails, userSession = options.userSession, _options = _objectWithoutPropertiesLoose(options, _excluded2);\n\n            if (!hasAppPrivateKey(userSession)) {\n              _context3.next = 6;\n              break;\n            }\n\n            _getKeys2 = getKeys(userSession), privateKey = _getKeys2.privateKey, publicKey = _getKeys2.publicKey;\n            payload2 = _extends({}, _options, {\n              publicKey: publicKey,\n              txType: TransactionTypes.ContractDeploy\n            });\n            if (appDetails) payload2.appDetails = appDetails;\n            return _context3.abrupt(\"return\", signPayload(payload2, privateKey));\n\n          case 6:\n            payload = _extends({}, _options, {\n              txType: TransactionTypes.ContractDeploy\n            });\n            if (appDetails) payload.appDetails = appDetails;\n            return _context3.abrupt(\"return\", createUnsignedTransactionPayload(payload));\n\n          case 9:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function makeContractDeployToken(_x5) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nvar makeSTXTransferToken = /*#__PURE__*/function () {\n  var _ref5 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(options) {\n    var amount, appDetails, userSession, _options, _getKeys3, privateKey, publicKey, payload2, payload;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            amount = options.amount, appDetails = options.appDetails, userSession = options.userSession, _options = _objectWithoutPropertiesLoose(options, _excluded3);\n\n            if (!hasAppPrivateKey(userSession)) {\n              _context4.next = 6;\n              break;\n            }\n\n            _getKeys3 = getKeys(userSession), privateKey = _getKeys3.privateKey, publicKey = _getKeys3.publicKey;\n            payload2 = _extends({}, _options, {\n              amount: amount.toString(10),\n              publicKey: publicKey,\n              txType: TransactionTypes.STXTransfer\n            });\n            if (appDetails) payload2.appDetails = appDetails;\n            return _context4.abrupt(\"return\", signPayload(payload2, privateKey));\n\n          case 6:\n            payload = _extends({}, _options, {\n              amount: amount.toString(10),\n              txType: TransactionTypes.STXTransfer\n            });\n            if (appDetails) payload.appDetails = appDetails;\n            return _context4.abrupt(\"return\", createUnsignedTransactionPayload(payload));\n\n          case 9:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function makeSTXTransferToken(_x6) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nfunction generateTokenAndOpenPopup(_x7, _x8) {\n  return _generateTokenAndOpenPopup.apply(this, arguments);\n}\n\nfunction _generateTokenAndOpenPopup() {\n  _generateTokenAndOpenPopup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(options, makeTokenFn) {\n    var token;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return makeTokenFn(_extends({}, getDefaults(options), options));\n\n          case 2:\n            token = _context6.sent;\n            return _context6.abrupt(\"return\", openTransactionPopup({\n              token: token,\n              options: options\n            }));\n\n          case 4:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _generateTokenAndOpenPopup.apply(this, arguments);\n}\n\nfunction openContractCall(options) {\n  return generateTokenAndOpenPopup(options, makeContractCallToken);\n}\n\nfunction openContractDeploy(options) {\n  return generateTokenAndOpenPopup(options, makeContractDeployToken);\n}\n\nfunction openSTXTransfer(options) {\n  return generateTokenAndOpenPopup(options, makeSTXTransferToken);\n}\n\nexport { getKeys, getStxAddress, getUserSession, hasAppPrivateKey, makeContractCallToken, makeContractDeployToken, makeSTXTransferToken, openContractCall, openContractDeploy, openSTXTransfer };","map":{"version":3,"mappings":";;;;;;;;;;;;IAkCaA,iBAAiB,SAAjBA,cAAiB,CAACC,YAAD,EAAgC;MACxDC,cAAcD;;MAEd,CAACC,aAAa;QACVC,YAAY,IAAIC,SAAJ,CAAc,CAAC,aAAD,CAAd,EAA+BC,SAASC,QAATD,CAAkBE,IAAjD;kBACJ,IAAIC,WAAJ,CAAgB;MAAEL;IAAF,CAAhB;;;SAETD;;;0BAGwBA,aAA2B;MACtD;QACIO,UAAUT,eAAeE,WAAfF,EAA4BU,YAA5BV;WACTS,QAAQE;WACRC,GAAP;WACO;;;;IAIEC,UAAU,SAAVA,OAAU,CAACZ,YAAD,EAAgC;MAC/CC,cAAcF,eAAeC,YAAfD;MACdc,aAAaZ,YAAYQ,YAAZR,GAA2BS;MACxCI,YAAYC,gBAAgBC,eAAhBD,CAAgCF,UAAhCE;SAEX;IAAEF,sBAAF;IAAcC;EAAd;;;uBAIqBG,SAA6B;EAAA;;MACjDC,aAAqCD,QAArCC;MAAYjB,cAAyBgB,QAAzBhB;MAAakB,UAAYF,QAAZE;MAE7BD,mBAAmBA,UAAnBA;MACA,CAACjB,WAAD,IAAgB,CAACkB,gBAAgB,MAAhBA;MACfC,eAAenB,oEAAaQ,YAAbR,GAA4BoB,OAA5BpB,KAA4BoB,IAA5BpB,GAA4BoB,MAA5BpB,yBAAqCiB;MACpDI,kDACHC,QAAQC,OADLF,IACe,SADfA,EACeG,cAClBF,QAAQG,OADU,IACA,SAFfJ,EAEeG,aAFfH;MAIAK,UAA8BP,6CAAeE,aAAaH,QAAQS,OAArBN,CAAfF;SAC7BO;;;AAGT,qBAAqBV,OAArB,EAAkD;MAC1CE,UAAUF,QAAQE,OAARF,IAAmB,IAAIY,aAAJ;;MAG/BC,iBAAiBb,QAAQhB,WAAzB6B,GAAuC;QACnC7B,cAAcF,eAAekB,QAAQhB,WAAvBF;;QACdgC,wBACDd,OADCc,EACDd;MACHE,gBADGF;MAEHhB;IAFGgB,CADCc;;;MAOJb,YAAYc,cAAcD,QAAdC;OACTD;;;sBAYKd;IAASE;EAATF;;;AAGd,8BAA8BgB,cAA9B,EAA+D;SACtDA,eAAeC,GAAfD,CAAmB;IAAA,OAAME,uBAAuBC,EAAvBD,EAA2BE,QAA3BF,CAAoC,KAApCA,CAAN;EAAnB;;;;;;;;0EAGT,kBAA2BG,OAA3B,EAAwDzB,UAAxD;IAAA;IAAA;MAAA;QAAA;UAAA;YACQoB,cADR,GAC2BK,OAD3B,CACQL;;gBACFA,kBAAkB,OAAOA,eAAe,CAAfA,CAAP,KAA6B,UAAU;+BAC1CM,qBAAqBN,cAArBM;;;YAEbC,WALR,GAKsB,IAAIC,WAAJ,CAAgB,QAAhB,EAA0B5B,UAA1B,CAAd2B;YALR,kCAMSA,YAAYE,SAAZF,cAA2BF,OAA3B;cAAoCL;YAApC,GANT;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA;;;;AASA,0CAA0CK,OAA1C,EAAgF;MACxEL,iBAAmBK,QAAnBL;;MACFA,kBAAkB,OAAOA,eAAe,CAAfA,CAAP,KAA6B,UAAU;qBAC1CM,qBAAqBN,cAArBM;;;SAEZI,kCAA0BL,OAA1BK,EAA0BL;IAASL;EAATK,CAA1BK;;;AAGT,IAAMC;oFAAuB;IAAA;IAAA;MAAA;QAAA;UAAA;YAASC,KAAT,QAASA,OAAO5B,OAAhB,QAAgBA,OAAP4B;YAC9BC,QADqB,GACVC,mBAAXD;;YADqB,IAEtBA,QAFsB;cAAAE;cAAA;YAAA;;YAAA,MAGnB,IAAIC,KAAJ,CAAU,2BAAV,CAHmB;;UAAA;YAAAD;YAAAA;YAAA,OAOAF,SAASI,kBAATJ,CAA4BD,KAA5BC,CAPA;;UAAA;YAOnBK,UAPmB,gBAOnBA;YACEC,KARiB,GAQPD,UARO,CAQjBC;YACFC,QATmB,GASRC,OAAOC,IAAPD,CAAYF,MAAMI,OAANJ,CAAc,KAAdA,EAAqB,EAArBA,CAAZE,EAAsC,KAAtCA,CAAXD;YACAI,iBAVmB,GAUCC,uBAAuB,IAAIC,YAAJ,CAAiBN,QAAjB,CAAvBK,CAApBD;;YAVmB,MAYrB,eAAexC,OAAf,IAA0BA,QAAQ2C,SAZb;cAAAZ;cAAA;YAAA;;oBAafa,0DACFV,UADEU,EACFV;cACJM;YADIN,CADEU;YAbe;;UAAA;oBAmBjBA,0DACFV,UADEU,EACFV;cACJM;YADIN,CADEU;YAnBiBb;YAAA;;UAAA;YAAAA;YAAAA;oBAwBjBc,MAAM;oBACNC;;UAzBiB;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA;;kBAAvBnB;;;CAAAA,EAAN;;IA6BaoB;oFAAwB,kBAAO/C,OAAP;IAAA;;IAAA;MAAA;QAAA;UAAA;YAC3BgD,YAD2B,GAC4BhD,OAD5B,CAC3BgD,cAAcC,UADa,GAC4BjD,OAD5B,CACbiD,UAAdD,EAA0BhE,WADC,GAC4BgB,OAD5B,CACDhB,WAA1BgE,EAA0CE,QADf,iCAC4BlD,OAD5B,YAC3BgD;YAEFG,IAH6B,GAGZH,aAAa/B,GAAb+B,CAAiB,eAAO;kBACzC,OAAOI,GAAP,KAAe,UAAU;uBACpBA;;;qBAEFC,YAAYD,GAAZC,EAAiBjC,QAAjBiC,CAA0B,KAA1BA;YAJc,EAAjBF;;YAH6B,KAS/BtC,iBAAiB7B,WAAjB6B,CAT+B;cAAAyC;cAAA;YAAA;;YAAAC,WAUC5D,QAAQX,WAARW,CAVD,EAUzBC,UAVyB,YAUzBA,UAVyB,EAUbC,SAVa,YAUbA,SAVa;YAW3B2D,QAX2B,gBAY5BN,QAZ4B;cAa/BF,cAAcG,IAbiB;cAc/BM,QAAQC,iBAAiBC,YAdM;cAe/B9D;YAf+B,EAW3B2D;gBAMFP,qBAAoBA,UAApBA,GAAiCA,UAAjCA;YAjB6B,kCAkB1BW,YAAYJ,QAAZI,EAAqBhE,UAArBgE,CAlB0B;;UAAA;YAoB7BvC,OApB6B,gBAqB9B6B,QArB8B;cAsBjCF,cAAcG,IAtBmB;cAuBjCM,QAAQC,iBAAiBC;YAvBQ,EAoB7BtC;gBAKF4B,oBAAoBA,UAApBA,GAAiCA,UAAjCA;YAzB+B,kCA0B5BY,iCAAiCxC,OAAjCwC,CA1B4B;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA;;kBAAxBd;;;CAAAA;;IA6BAe;oFAA0B,kBAAO9D,OAAP;IAAA;;IAAA;MAAA;QAAA;UAAA;YAC7BiD,UAD6B,GACYjD,OADZ,CAC7BiD,YAAYjE,WADiB,GACYgB,OADZ,CACjBhB,WAAZiE,EAA4BC,QADC,iCACYlD,OADZ,aAC7BiD;;YAD6B,KAEjCpC,iBAAiB7B,WAAjB6B,CAFiC;cAAAkD;cAAA;YAAA;;YAAAC,YAGDrE,QAAQX,WAARW,CAHC,EAG3BC,UAH2B,aAG3BA,UAH2B,EAGfC,SAHe,aAGfA,SAHe;YAI7B2D,QAJ6B,gBAK9BN,QAL8B;cAMjCrD,oBANiC;cAOjC4D,QAAQC,iBAAiBO;YAPQ,EAI7BT;gBAKFP,qBAAoBA,UAApBA,GAAiCA,UAAjCA;YAT+B,kCAU5BW,YAAYJ,QAAZI,EAAqBhE,UAArBgE,CAV4B;;UAAA;YAa/BvC,OAb+B,gBAchC6B,QAdgC;cAenCO,QAAQC,iBAAiBO;YAfU,EAa/B5C;gBAIF4B,oBAAoBA,UAApBA,GAAiCA,UAAjCA;YAjBiC,kCAkB9BY,iCAAiCxC,OAAjCwC,CAlB8B;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA;;kBAA1BC;;;CAAAA;;IAqBAI;oFAAuB,kBAAOlE,OAAP;IAAA;;IAAA;MAAA;QAAA;UAAA;YAC1BmE,MAD0B,GACuBnE,OADvB,CAC1BmE,QAAQlB,UADkB,GACuBjD,OADvB,CAClBiD,UAARkB,EAAoBnF,WADM,GACuBgB,OADvB,CACNhB,WAApBmF,EAAoCjB,QADV,iCACuBlD,OADvB,aAC1BmE;;YAD0B,KAG9BtD,iBAAiB7B,WAAjB6B,CAH8B;cAAAuD;cAAA;YAAA;;YAAAC,YAIE1E,QAAQX,WAARW,CAJF,EAIxBC,UAJwB,aAIxBA,UAJwB,EAIZC,SAJY,aAIZA,SAJY;YAK1B2D,QAL0B,gBAM3BN,QAN2B;cAO9BiB,QAAQA,OAAO/C,QAAP+C,CAAgB,EAAhBA,CAPsB;cAQ9BtE,oBAR8B;cAS9B4D,QAAQC,iBAAiBY;YATK,EAK1Bd;gBAMFP,qBAAoBA,UAApBA,GAAiCA,UAAjCA;YAX4B,kCAYzBW,YAAYJ,QAAZI,EAAqBhE,UAArBgE,CAZyB;;UAAA;YAe5BvC,OAf4B,gBAgB7B6B,QAhB6B;cAiBhCiB,QAAQA,OAAO/C,QAAP+C,CAAgB,EAAhBA,CAjBwB;cAkBhCV,QAAQC,iBAAiBY;YAlBO,EAe5BjD;gBAKF4B,oBAAoBA,UAApBA,GAAiCA,UAAjCA;YApB8B,kCAqB3BY,iCAAiCxC,OAAjCwC,CArB2B;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA;;kBAAvBK;;;CAAAA;;;;;;;wFAwBb,kBACElE,OADF,EAEEuE,WAFF;IAAA;IAAA;MAAA;QAAA;UAAA;YAAAC;YAAA,OAIsBD,yBACfE,YAAYzE,OAAZyE,CADeF,EAEfvE,OAFeuE,EAJtB;;UAAA;YAIQ3C,KAJR,iBAIQA;YAJR,kCAQSD,qBAAqB;cAAEC,YAAF;cAAS5B;YAAT,CAArB2B,CART;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA;;;;0BAciC3B,SAA8B;SACtD0E,0BAA0B1E,OAA1B0E,EAAmC3B,qBAAnC2B;;;4BAM0B1E,SAAgC;SAC1D0E,0BAA0B1E,OAA1B0E,EAAmCZ,uBAAnCY;;;yBAMuB1E,SAA6B;SACpD0E,0BAA0B1E,OAA1B0E,EAAmCR,oBAAnCQ","names":["getUserSession","_userSession","userSession","appConfig","AppConfig","document","location","href","UserSession","session","loadUserData","appPrivateKey","e","getKeys","privateKey","publicKey","SECP256K1Client","derivePublicKey","options","stxAddress","network","stxAddresses","profile","chainIdToKey","ChainID","Mainnet","_chainIdToKey","Testnet","address","chainId","StacksTestnet","hasAppPrivateKey","defaults","getStxAddress","postConditions","map","serializePostCondition","pc","toString","payload","encodePostConditions","tokenSigner","TokenSigner","signAsync","createUnsecuredToken","openTransactionPopup","token","provider","getStacksProvider","_context","Error","transactionRequest","txResponse","txRaw","txBuffer","Buffer","from","replace","stacksTransaction","deserializeTransaction","BufferReader","sponsored","onFinish","error","onCancel","makeContractCallToken","functionArgs","appDetails","_options","args","arg","serializeCV","_context2","_getKeys","payload2","txType","TransactionTypes","ContractCall","signPayload","createUnsignedTransactionPayload","makeContractDeployToken","_context3","_getKeys2","ContractDeploy","makeSTXTransferToken","amount","_context4","_getKeys3","STXTransfer","makeTokenFn","_context6","getDefaults","generateTokenAndOpenPopup"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\connect\\src\\transactions\\index.ts"],"sourcesContent":["import { UserSession, AppConfig } from '@stacks/auth';\nimport { createUnsecuredToken, Json, SECP256K1Client, TokenSigner } from 'jsontokens';\nimport {\n  ContractCallOptions,\n  ContractCallPayload,\n  ContractDeployOptions,\n  ContractDeployPayload,\n  TransactionPopup,\n  TransactionOptions,\n  STXTransferOptions,\n  STXTransferPayload,\n  TransactionPayload,\n  TransactionTypes,\n  STXTransferSponsoredOptions,\n  STXTransferRegularOptions,\n  ContractDeployRegularOptions,\n  ContractDeploySponsoredOptions,\n  ContractCallRegularOptions,\n  ContractCallSponsoredOptions,\n  SponsoredFinishedTxPayload,\n  FinishedTxPayload,\n} from '../types/transactions';\nimport {\n  serializeCV,\n  ChainID,\n  deserializeTransaction,\n  BufferReader,\n  serializePostCondition,\n  PostCondition,\n} from '@stacks/transactions';\nimport { getStacksProvider } from '../utils';\nimport { StacksTestnet } from '@stacks/network';\n\n// TODO extract out of transactions\nexport const getUserSession = (_userSession?: UserSession) => {\n  let userSession = _userSession;\n\n  if (!userSession) {\n    const appConfig = new AppConfig(['store_write'], document.location.href);\n    userSession = new UserSession({ appConfig });\n  }\n  return userSession;\n};\n\nexport function hasAppPrivateKey(userSession?: UserSession) {\n  try {\n    const session = getUserSession(userSession).loadUserData();\n    return session.appPrivateKey;\n  } catch (e) {\n    return false;\n  }\n}\n\nexport const getKeys = (_userSession?: UserSession) => {\n  const userSession = getUserSession(_userSession);\n  const privateKey = userSession.loadUserData().appPrivateKey;\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n\n  return { privateKey, publicKey };\n};\n\n// TODO extract out of transactions\nexport function getStxAddress(options: TransactionOptions) {\n  const { stxAddress, userSession, network } = options;\n\n  if (stxAddress) return stxAddress;\n  if (!userSession || !network) return undefined;\n  const stxAddresses = userSession?.loadUserData().profile?.stxAddress;\n  const chainIdToKey = {\n    [ChainID.Mainnet]: 'mainnet',\n    [ChainID.Testnet]: 'testnet',\n  };\n  const address: string | undefined = stxAddresses?.[chainIdToKey[network.chainId]];\n  return address;\n}\n\nfunction getDefaults(options: TransactionOptions) {\n  const network = options.network || new StacksTestnet();\n\n  // Legacy auth using localstorage with appPrivateKey\n  if (hasAppPrivateKey(options.userSession)) {\n    const userSession = getUserSession(options.userSession);\n    const defaults: TransactionOptions = {\n      ...options,\n      network,\n      userSession,\n    };\n\n    return {\n      stxAddress: getStxAddress(defaults),\n      ...defaults,\n    };\n  }\n\n  // User has not authed, we're relying on the app having previously having been\n  // given permissions from  `stx_requestAccounts`, and the wallet recognising the app's origin\n  // const hasSetRequiredStxAddressPropForRequestAccountFlow = 'stxAddress' in options;\n  // if (!hasSetRequiredStxAddressPropForRequestAccountFlow) {\n  //   throw new Error(\n  //     'Must set property `stxAddress` when using `stx_requestAccounts to initiate transaction`'\n  //   );\n  // }\n  return { ...options, network };\n}\n\nfunction encodePostConditions(postConditions: PostCondition[]) {\n  return postConditions.map(pc => serializePostCondition(pc).toString('hex'));\n}\n\nasync function signPayload(payload: TransactionPayload, privateKey: string) {\n  let { postConditions } = payload;\n  if (postConditions && typeof postConditions[0] !== 'string') {\n    postConditions = encodePostConditions(postConditions as PostCondition[]);\n  }\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  return tokenSigner.signAsync({ ...payload, postConditions } as any);\n}\n\nfunction createUnsignedTransactionPayload(payload: Partial<TransactionPayload>) {\n  let { postConditions } = payload;\n  if (postConditions && typeof postConditions[0] !== 'string') {\n    postConditions = encodePostConditions(postConditions as PostCondition[]);\n  }\n  return createUnsecuredToken({ ...payload, postConditions } as unknown as Json);\n}\n\nconst openTransactionPopup = async ({ token, options }: TransactionPopup) => {\n  const provider = getStacksProvider();\n  if (!provider) {\n    throw new Error('Hiro Wallet not installed');\n  }\n\n  try {\n    const txResponse = await provider.transactionRequest(token);\n    const { txRaw } = txResponse;\n    const txBuffer = Buffer.from(txRaw.replace(/^0x/, ''), 'hex');\n    const stacksTransaction = deserializeTransaction(new BufferReader(txBuffer));\n\n    if ('sponsored' in options && options.sponsored) {\n      options.onFinish?.({\n        ...(txResponse as SponsoredFinishedTxPayload),\n        stacksTransaction,\n      });\n      return;\n    }\n    options.onFinish?.({\n      ...(txResponse as FinishedTxPayload),\n      stacksTransaction,\n    });\n  } catch (error) {\n    console.error('[Connect] Error during transaction request', error);\n    options.onCancel?.();\n  }\n};\n\nexport const makeContractCallToken = async (options: ContractCallOptions) => {\n  const { functionArgs, appDetails, userSession, ..._options } = options;\n\n  const args: string[] = functionArgs.map(arg => {\n    if (typeof arg === 'string') {\n      return arg;\n    }\n    return serializeCV(arg).toString('hex');\n  });\n  if (hasAppPrivateKey(userSession)) {\n    const { privateKey, publicKey } = getKeys(userSession);\n    const payload: ContractCallPayload = {\n      ..._options,\n      functionArgs: args,\n      txType: TransactionTypes.ContractCall,\n      publicKey,\n    };\n    if (appDetails) payload.appDetails = appDetails;\n    return signPayload(payload, privateKey);\n  }\n  const payload: Partial<ContractCallPayload> = {\n    ..._options,\n    functionArgs: args,\n    txType: TransactionTypes.ContractCall,\n  };\n  if (appDetails) payload.appDetails = appDetails;\n  return createUnsignedTransactionPayload(payload);\n};\n\nexport const makeContractDeployToken = async (options: ContractDeployOptions) => {\n  const { appDetails, userSession, ..._options } = options;\n  if (hasAppPrivateKey(userSession)) {\n    const { privateKey, publicKey } = getKeys(userSession);\n    const payload: ContractDeployPayload = {\n      ..._options,\n      publicKey,\n      txType: TransactionTypes.ContractDeploy,\n    };\n    if (appDetails) payload.appDetails = appDetails;\n    return signPayload(payload, privateKey);\n  }\n\n  const payload: Partial<ContractDeployPayload> = {\n    ..._options,\n    txType: TransactionTypes.ContractDeploy,\n  };\n  if (appDetails) payload.appDetails = appDetails;\n  return createUnsignedTransactionPayload(payload);\n};\n\nexport const makeSTXTransferToken = async (options: STXTransferOptions) => {\n  const { amount, appDetails, userSession, ..._options } = options;\n\n  if (hasAppPrivateKey(userSession)) {\n    const { privateKey, publicKey } = getKeys(userSession);\n    const payload: STXTransferPayload = {\n      ..._options,\n      amount: amount.toString(10),\n      publicKey,\n      txType: TransactionTypes.STXTransfer,\n    };\n    if (appDetails) payload.appDetails = appDetails;\n    return signPayload(payload, privateKey);\n  }\n\n  const payload: Partial<STXTransferPayload> = {\n    ..._options,\n    amount: amount.toString(10),\n    txType: TransactionTypes.STXTransfer,\n  };\n  if (appDetails) payload.appDetails = appDetails;\n  return createUnsignedTransactionPayload(payload);\n};\n\nasync function generateTokenAndOpenPopup<T extends TransactionOptions>(\n  options: T,\n  makeTokenFn: (options: T) => Promise<string>\n) {\n  const token = await makeTokenFn({\n    ...getDefaults(options),\n    ...options,\n  } as T);\n  return openTransactionPopup({ token, options });\n}\n\nexport function openContractCall(options: ContractCallRegularOptions): Promise<void>;\nexport function openContractCall(options: ContractCallSponsoredOptions): Promise<void>;\nexport function openContractCall(options: ContractCallOptions): Promise<void>;\nexport function openContractCall(options: ContractCallOptions) {\n  return generateTokenAndOpenPopup(options, makeContractCallToken);\n}\n\nexport function openContractDeploy(options: ContractDeployRegularOptions): Promise<void>;\nexport function openContractDeploy(options: ContractDeploySponsoredOptions): Promise<void>;\nexport function openContractDeploy(options: ContractDeployOptions): Promise<void>;\nexport function openContractDeploy(options: ContractDeployOptions) {\n  return generateTokenAndOpenPopup(options, makeContractDeployToken);\n}\n\nexport function openSTXTransfer(options: STXTransferRegularOptions): Promise<void>;\nexport function openSTXTransfer(options: STXTransferSponsoredOptions): Promise<void>;\nexport function openSTXTransfer(options: STXTransferOptions): Promise<void>;\nexport function openSTXTransfer(options: STXTransferOptions) {\n  return generateTokenAndOpenPopup(options, makeSTXTransferToken);\n}\n"]},"metadata":{},"sourceType":"module"}