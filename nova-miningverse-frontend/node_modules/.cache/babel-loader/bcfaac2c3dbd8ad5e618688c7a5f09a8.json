{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { decryptECIES, encryptECIES, signECDSA } from './ec';\nimport { getPublicKeyFromPrivate } from './keys';\nexport async function encryptContent(content, options) {\n  const opts = Object.assign({}, options);\n  let privateKey;\n\n  if (!opts.publicKey) {\n    if (!opts.privateKey) {\n      throw new Error('Either public key or private key must be supplied for encryption.');\n    }\n\n    opts.publicKey = getPublicKeyFromPrivate(opts.privateKey);\n  }\n\n  let wasString;\n\n  if (typeof opts.wasString === 'boolean') {\n    wasString = opts.wasString;\n  } else {\n    wasString = typeof content === 'string';\n  }\n\n  const contentBuffer = typeof content === 'string' ? Buffer.from(content) : content;\n  const cipherObject = await encryptECIES(opts.publicKey, contentBuffer, wasString, opts.cipherTextEncoding);\n  let cipherPayload = JSON.stringify(cipherObject);\n\n  if (opts.sign) {\n    if (typeof opts.sign === 'string') {\n      privateKey = opts.sign;\n    } else if (!privateKey) {\n      privateKey = opts.privateKey;\n    }\n\n    const signatureObject = signECDSA(privateKey, cipherPayload);\n    const signedCipherObject = {\n      signature: signatureObject.signature,\n      publicKey: signatureObject.publicKey,\n      cipherText: cipherPayload\n    };\n    cipherPayload = JSON.stringify(signedCipherObject);\n  }\n\n  return cipherPayload;\n}\nexport function decryptContent(content, options) {\n  const opts = Object.assign({}, options);\n\n  if (!opts.privateKey) {\n    throw new Error('Private key is required for decryption.');\n  }\n\n  try {\n    const cipherObject = JSON.parse(content);\n    return decryptECIES(opts.privateKey, cipherObject);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      throw new Error('Failed to parse encrypted content JSON. The content may not ' + 'be encrypted. If using getFile, try passing { decrypt: false }.');\n    } else {\n      throw err;\n    }\n  }\n}","map":{"version":3,"mappings":"AAAA,SAASA,MAAT,QAAuB,gBAAvB;AACA,SAEEC,YAFF,EAGEC,YAHF,EAIEC,SAJF,QAMO,MANP;AAOA,SAASC,uBAAT,QAAwC,QAAxC;AAiDA,OAAO,eAAeC,cAAf,CACLC,OADK,EAELC,OAFK,EAE0B;EAE/B,MAAMC,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBH,OAAlB,CAAb;EACA,IAAII,UAAJ;;EACA,IAAI,CAACH,IAAI,CAACI,SAAV,EAAqB;IACnB,IAAI,CAACJ,IAAI,CAACG,UAAV,EAAsB;MACpB,MAAM,IAAIE,KAAJ,CAAU,mEAAV,CAAN;IACD;;IACDL,IAAI,CAACI,SAAL,GAAiBR,uBAAuB,CAACI,IAAI,CAACG,UAAN,CAAxC;EACD;;EACD,IAAIG,SAAJ;;EACA,IAAI,OAAON,IAAI,CAACM,SAAZ,KAA0B,SAA9B,EAAyC;IACvCA,SAAS,GAAGN,IAAI,CAACM,SAAjB;EACD,CAFD,MAEO;IACLA,SAAS,GAAG,OAAOR,OAAP,KAAmB,QAA/B;EACD;;EACD,MAAMS,aAAa,GAAG,OAAOT,OAAP,KAAmB,QAAnB,GAA8BN,MAAM,CAACgB,IAAP,CAAYV,OAAZ,CAA9B,GAAqDA,OAA3E;EACA,MAAMW,YAAY,GAAG,MAAMf,YAAY,CACrCM,IAAI,CAACI,SADgC,EAErCG,aAFqC,EAGrCD,SAHqC,EAIrCN,IAAI,CAACU,kBAJgC,CAAvC;EAMA,IAAIC,aAAa,GAAGC,IAAI,CAACC,SAAL,CAAeJ,YAAf,CAApB;;EACA,IAAIT,IAAI,CAACc,IAAT,EAAe;IACb,IAAI,OAAOd,IAAI,CAACc,IAAZ,KAAqB,QAAzB,EAAmC;MACjCX,UAAU,GAAGH,IAAI,CAACc,IAAlB;IACD,CAFD,MAEO,IAAI,CAACX,UAAL,EAAiB;MACtBA,UAAU,GAAGH,IAAI,CAACG,UAAlB;IACD;;IACD,MAAMY,eAAe,GAAGpB,SAAS,CAACQ,UAAD,EAAcQ,aAAd,CAAjC;IACA,MAAMK,kBAAkB,GAAuB;MAC7CC,SAAS,EAAEF,eAAe,CAACE,SADkB;MAE7Cb,SAAS,EAAEW,eAAe,CAACX,SAFkB;MAG7Cc,UAAU,EAAEP;IAHiC,CAA/C;IAKAA,aAAa,GAAGC,IAAI,CAACC,SAAL,CAAeG,kBAAf,CAAhB;EACD;;EACD,OAAOL,aAAP;AACD;AAWD,OAAM,SAAUQ,cAAV,CACJrB,OADI,EAEJC,OAFI,EAIH;EAED,MAAMC,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBH,OAAlB,CAAb;;EACA,IAAI,CAACC,IAAI,CAACG,UAAV,EAAsB;IACpB,MAAM,IAAIE,KAAJ,CAAU,yCAAV,CAAN;EACD;;EAED,IAAI;IACF,MAAMI,YAAY,GAAGG,IAAI,CAACQ,KAAL,CAAWtB,OAAX,CAArB;IACA,OAAOL,YAAY,CAACO,IAAI,CAACG,UAAN,EAAkBM,YAAlB,CAAnB;EACD,CAHD,CAGE,OAAOY,GAAP,EAAY;IACZ,IAAIA,GAAG,YAAYC,WAAnB,EAAgC;MAC9B,MAAM,IAAIjB,KAAJ,CACJ,iEACE,iEAFE,CAAN;IAID,CALD,MAKO;MACL,MAAMgB,GAAN;IACD;EACF;AACF","names":["Buffer","decryptECIES","encryptECIES","signECDSA","getPublicKeyFromPrivate","encryptContent","content","options","opts","Object","assign","privateKey","publicKey","Error","wasString","contentBuffer","from","cipherObject","cipherTextEncoding","cipherPayload","JSON","stringify","sign","signatureObject","signedCipherObject","signature","cipherText","decryptContent","parse","err","SyntaxError"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\encryption\\src\\encryption.ts"],"sourcesContent":["import { Buffer } from '@stacks/common';\nimport {\n  CipherTextEncoding,\n  decryptECIES,\n  encryptECIES,\n  signECDSA,\n  SignedCipherObject,\n} from './ec';\nimport { getPublicKeyFromPrivate } from './keys';\n\nexport interface EncryptionOptions {\n  /**\n   * If set to `true` the data is signed using ECDSA on SHA256 hashes with the user's\n   * app private key. If a string is specified, it is used as the private key instead\n   * of the user's app private key.\n   * @default false\n   */\n  sign?: boolean | string;\n  /**\n   * String encoding format for the cipherText buffer.\n   * Currently defaults to 'hex' for legacy backwards-compatibility.\n   * Only used if the `encrypt` option is also used.\n   * Note: in the future this should default to 'base64' for the significant\n   * file size reduction.\n   */\n  cipherTextEncoding?: CipherTextEncoding;\n  /**\n   * Specifies if the original unencrypted content is a ASCII or UTF-8 string.\n   * For example stringified JSON.\n   * If true, then when the ciphertext is decrypted, it will be returned as\n   * a `string` type variable, otherwise will be returned as a Buffer.\n   */\n  wasString?: boolean;\n}\n\n/**\n * Specify encryption options, and whether to sign the ciphertext.\n */\nexport interface EncryptContentOptions extends EncryptionOptions {\n  /**\n   * Encrypt the data with this key.\n   */\n  publicKey?: string;\n  /**\n   * Encrypt the data with the public key corresponding to the supplied private key\n   */\n  privateKey?: string;\n}\n\n/**\n * Encrypts the data provided with the app public key.\n * @param {String|Buffer} content - data to encrypt\n * @param {Object} [options=null] - options object\n * @param {String} options.publicKey - the hex string of the ECDSA public\n * key to use for encryption. If not provided, will use user's appPublicKey.\n * @return {String} Stringified ciphertext object\n */\nexport async function encryptContent(\n  content: string | Buffer,\n  options?: EncryptContentOptions\n): Promise<string> {\n  const opts = Object.assign({}, options);\n  let privateKey: string | undefined;\n  if (!opts.publicKey) {\n    if (!opts.privateKey) {\n      throw new Error('Either public key or private key must be supplied for encryption.');\n    }\n    opts.publicKey = getPublicKeyFromPrivate(opts.privateKey);\n  }\n  let wasString: boolean;\n  if (typeof opts.wasString === 'boolean') {\n    wasString = opts.wasString;\n  } else {\n    wasString = typeof content === 'string';\n  }\n  const contentBuffer = typeof content === 'string' ? Buffer.from(content) : content;\n  const cipherObject = await encryptECIES(\n    opts.publicKey,\n    contentBuffer,\n    wasString,\n    opts.cipherTextEncoding\n  );\n  let cipherPayload = JSON.stringify(cipherObject);\n  if (opts.sign) {\n    if (typeof opts.sign === 'string') {\n      privateKey = opts.sign;\n    } else if (!privateKey) {\n      privateKey = opts.privateKey;\n    }\n    const signatureObject = signECDSA(privateKey!, cipherPayload);\n    const signedCipherObject: SignedCipherObject = {\n      signature: signatureObject.signature,\n      publicKey: signatureObject.publicKey,\n      cipherText: cipherPayload,\n    };\n    cipherPayload = JSON.stringify(signedCipherObject);\n  }\n  return cipherPayload;\n}\n\n/**\n * Decrypts data encrypted with `encryptContent` with the\n * transit private key.\n * @param {String|Buffer} content - encrypted content.\n * @param {Object} [options=null] - options object\n * @param {String} options.privateKey - the hex string of the ECDSA private\n * key to use for decryption. If not provided, will use user's appPrivateKey.\n * @return {String|Buffer} decrypted content.\n */\nexport function decryptContent(\n  content: string,\n  options?: {\n    privateKey?: string;\n  }\n): Promise<string | Buffer> {\n  const opts = Object.assign({}, options);\n  if (!opts.privateKey) {\n    throw new Error('Private key is required for decryption.');\n  }\n\n  try {\n    const cipherObject = JSON.parse(content);\n    return decryptECIES(opts.privateKey, cipherObject);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      throw new Error(\n        'Failed to parse encrypted content JSON. The content may not ' +\n          'be encrypted. If using getFile, try passing { decrypt: false }.'\n      );\n    } else {\n      throw err;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}