{"ast":null,"code":"import { sha256 } from '@noble/hashes/sha256';\nimport { sha512 } from '@noble/hashes/sha512';\nimport { Buffer } from '@stacks/common';\nimport { getCryptoLib } from './cryptoUtils';\nexport class NodeCryptoSha2Hash {\n  constructor(createHash) {\n    this.createHash = createHash;\n  }\n\n  async digest(data) {\n    let algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'sha256';\n\n    try {\n      const result = this.createHash(algorithm).update(data).digest();\n      return Promise.resolve(result);\n    } catch (error) {\n      console.log(error);\n      console.log(`Error performing ${algorithm} digest with Node.js 'crypto.createHash', falling back to JS implementation.`);\n      return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));\n    }\n  }\n\n}\nexport class WebCryptoSha2Hash {\n  constructor(subtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  async digest(data) {\n    let algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'sha256';\n    let algo;\n\n    if (algorithm === 'sha256') {\n      algo = 'SHA-256';\n    } else if (algorithm === 'sha512') {\n      algo = 'SHA-512';\n    } else {\n      throw new Error(`Unsupported hash algorithm ${algorithm}`);\n    }\n\n    try {\n      const hash = await this.subtleCrypto.digest(algo, data);\n      return Buffer.from(hash);\n    } catch (error) {\n      console.log(error);\n      console.log(`Error performing ${algorithm} digest with WebCrypto, falling back to JS implementation.`);\n      return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));\n    }\n  }\n\n}\nexport async function createSha2Hash() {\n  const cryptoLib = await getCryptoLib();\n\n  if (cryptoLib.name === 'subtleCrypto') {\n    return new WebCryptoSha2Hash(cryptoLib.lib);\n  } else {\n    return new NodeCryptoSha2Hash(cryptoLib.lib.createHash);\n  }\n}\nexport function hashSha256Sync(data) {\n  return Buffer.from(sha256(data));\n}\nexport function hashSha512Sync(data) {\n  return Buffer.from(sha512(data));\n}","map":{"version":3,"mappings":"AAAA,SAASA,MAAT,QAAuB,sBAAvB;AACA,SAASC,MAAT,QAAuB,sBAAvB;AACA,SAASC,MAAT,QAAuB,gBAAvB;AACA,SAASC,YAAT,QAA6B,eAA7B;AAQA,OAAM,MAAOC,kBAAP,CAAyB;EAG7BC,YAAYC,UAAZ,EAA4C;IAC1C,KAAKA,UAAL,GAAkBA,UAAlB;EACD;;EAEW,MAANC,MAAM,CAACC,IAAD,EAAmC;IAAA,IAApBC,SAAoB,uEAAR,QAAQ;;IAC7C,IAAI;MACF,MAAMC,MAAM,GAAG,KAAKJ,UAAL,CAAgBG,SAAhB,EAA2BE,MAA3B,CAAkCH,IAAlC,EAAwCD,MAAxC,EAAf;MACA,OAAOK,OAAO,CAACC,OAAR,CAAgBH,MAAhB,CAAP;IACD,CAHD,CAGE,OAAOI,KAAP,EAAc;MACdC,OAAO,CAACC,GAAR,CAAYF,KAAZ;MACAC,OAAO,CAACC,GAAR,CACE,oBAAoBP,SAAS,8EAD/B;MAGA,OAAOG,OAAO,CAACC,OAAR,CAAgBJ,SAAS,KAAK,QAAd,GAAyBQ,cAAc,CAACT,IAAD,CAAvC,GAAgDU,cAAc,CAACV,IAAD,CAA9E,CAAP;IACD;EACF;;AAlB4B;AAqB/B,OAAM,MAAOW,iBAAP,CAAwB;EAG5Bd,YAAYe,YAAZ,EAAsC;IACpC,KAAKA,YAAL,GAAoBA,YAApB;EACD;;EAEW,MAANb,MAAM,CAACC,IAAD,EAAmC;IAAA,IAApBC,SAAoB,uEAAR,QAAQ;IAC7C,IAAIY,IAAJ;;IACA,IAAIZ,SAAS,KAAK,QAAlB,EAA4B;MAC1BY,IAAI,GAAG,SAAP;IACD,CAFD,MAEO,IAAIZ,SAAS,KAAK,QAAlB,EAA4B;MACjCY,IAAI,GAAG,SAAP;IACD,CAFM,MAEA;MACL,MAAM,IAAIC,KAAJ,CAAU,8BAA8Bb,SAAS,EAAjD,CAAN;IACD;;IACD,IAAI;MACF,MAAMc,IAAI,GAAG,MAAM,KAAKH,YAAL,CAAkBb,MAAlB,CAAyBc,IAAzB,EAA+Bb,IAA/B,CAAnB;MACA,OAAON,MAAM,CAACsB,IAAP,CAAYD,IAAZ,CAAP;IACD,CAHD,CAGE,OAAOT,KAAP,EAAc;MACdC,OAAO,CAACC,GAAR,CAAYF,KAAZ;MACAC,OAAO,CAACC,GAAR,CACE,oBAAoBP,SAAS,4DAD/B;MAGA,OAAOG,OAAO,CAACC,OAAR,CAAgBJ,SAAS,KAAK,QAAd,GAAyBQ,cAAc,CAACT,IAAD,CAAvC,GAAgDU,cAAc,CAACV,IAAD,CAA9E,CAAP;IACD;EACF;;AA1B2B;AA6B9B,OAAO,eAAeiB,cAAf,GAA6B;EAClC,MAAMC,SAAS,GAAG,MAAMvB,YAAY,EAApC;;EACA,IAAIuB,SAAS,CAACC,IAAV,KAAmB,cAAvB,EAAuC;IACrC,OAAO,IAAIR,iBAAJ,CAAsBO,SAAS,CAACE,GAAhC,CAAP;EACD,CAFD,MAEO;IACL,OAAO,IAAIxB,kBAAJ,CAAuBsB,SAAS,CAACE,GAAV,CAActB,UAArC,CAAP;EACD;AACF;AAED,OAAM,SAAUW,cAAV,CAAyBT,IAAzB,EAAqC;EACzC,OAAON,MAAM,CAACsB,IAAP,CAAYxB,MAAM,CAACQ,IAAD,CAAlB,CAAP;AACD;AAED,OAAM,SAAUU,cAAV,CAAyBV,IAAzB,EAAqC;EACzC,OAAON,MAAM,CAACsB,IAAP,CAAYvB,MAAM,CAACO,IAAD,CAAlB,CAAP;AACD","names":["sha256","sha512","Buffer","getCryptoLib","NodeCryptoSha2Hash","constructor","createHash","digest","data","algorithm","result","update","Promise","resolve","error","console","log","hashSha256Sync","hashSha512Sync","WebCryptoSha2Hash","subtleCrypto","algo","Error","hash","from","createSha2Hash","cryptoLib","name","lib"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\encryption\\src\\sha2Hash.ts"],"sourcesContent":["import { sha256 } from '@noble/hashes/sha256';\nimport { sha512 } from '@noble/hashes/sha512';\nimport { Buffer } from '@stacks/common';\nimport { getCryptoLib } from './cryptoUtils';\n\ntype NodeCryptoCreateHash = typeof import('crypto').createHash;\n\nexport interface Sha2Hash {\n  digest(data: Buffer, algorithm?: 'sha256' | 'sha512'): Promise<Buffer>;\n}\n\nexport class NodeCryptoSha2Hash {\n  createHash: NodeCryptoCreateHash;\n\n  constructor(createHash: NodeCryptoCreateHash) {\n    this.createHash = createHash;\n  }\n\n  async digest(data: Buffer, algorithm = 'sha256'): Promise<Buffer> {\n    try {\n      const result = this.createHash(algorithm).update(data).digest();\n      return Promise.resolve(result);\n    } catch (error) {\n      console.log(error);\n      console.log(\n        `Error performing ${algorithm} digest with Node.js 'crypto.createHash', falling back to JS implementation.`\n      );\n      return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));\n    }\n  }\n}\n\nexport class WebCryptoSha2Hash implements Sha2Hash {\n  subtleCrypto: SubtleCrypto;\n\n  constructor(subtleCrypto: SubtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  async digest(data: Buffer, algorithm = 'sha256'): Promise<Buffer> {\n    let algo: string;\n    if (algorithm === 'sha256') {\n      algo = 'SHA-256';\n    } else if (algorithm === 'sha512') {\n      algo = 'SHA-512';\n    } else {\n      throw new Error(`Unsupported hash algorithm ${algorithm}`);\n    }\n    try {\n      const hash = await this.subtleCrypto.digest(algo, data);\n      return Buffer.from(hash);\n    } catch (error) {\n      console.log(error);\n      console.log(\n        `Error performing ${algorithm} digest with WebCrypto, falling back to JS implementation.`\n      );\n      return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));\n    }\n  }\n}\n\nexport async function createSha2Hash(): Promise<Sha2Hash> {\n  const cryptoLib = await getCryptoLib();\n  if (cryptoLib.name === 'subtleCrypto') {\n    return new WebCryptoSha2Hash(cryptoLib.lib);\n  } else {\n    return new NodeCryptoSha2Hash(cryptoLib.lib.createHash);\n  }\n}\n\nexport function hashSha256Sync(data: Buffer) {\n  return Buffer.from(sha256(data));\n}\n\nexport function hashSha512Sync(data: Buffer) {\n  return Buffer.from(sha512(data));\n}\n"]},"metadata":{},"sourceType":"module"}