{"ast":null,"code":"import { Buffer, intToBigInt, intToBytes } from '@stacks/common';\nimport { COINBASE_BUFFER_LENGTH_BYTES, PayloadType, StacksMessageType } from './constants';\nimport { BufferArray } from './utils';\nimport { createMemoString, serializeStacksMessage, deserializeAddress, deserializeLPString, deserializeMemoString, codeBodyString } from './types';\nimport { createAddress, createLPString } from './postcondition-types';\nimport { serializeCV, deserializeCV } from './clarity/';\nimport { principalCV } from './clarity/types/principalCV';\nexport function createTokenTransferPayload(recipient, amount, memo) {\n  if (typeof recipient === 'string') {\n    recipient = principalCV(recipient);\n  }\n\n  if (typeof memo === 'string') {\n    memo = createMemoString(memo);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.TokenTransfer,\n    recipient,\n    amount: intToBigInt(amount, false),\n    memo: memo !== null && memo !== void 0 ? memo : createMemoString('')\n  };\n}\nexport function createContractCallPayload(contractAddress, contractName, functionName, functionArgs) {\n  if (typeof contractAddress === 'string') {\n    contractAddress = createAddress(contractAddress);\n  }\n\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n\n  if (typeof functionName === 'string') {\n    functionName = createLPString(functionName);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.ContractCall,\n    contractAddress,\n    contractName,\n    functionName,\n    functionArgs\n  };\n}\nexport function createSmartContractPayload(contractName, codeBody) {\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n\n  if (typeof codeBody === 'string') {\n    codeBody = codeBodyString(codeBody);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.SmartContract,\n    contractName,\n    codeBody\n  };\n}\nexport function createPoisonPayload() {\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.PoisonMicroblock\n  };\n}\nexport function createCoinbasePayload(coinbaseBuffer) {\n  if (coinbaseBuffer.byteLength != COINBASE_BUFFER_LENGTH_BYTES) {\n    throw Error(`Coinbase buffer size must be ${COINBASE_BUFFER_LENGTH_BYTES} bytes`);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.Coinbase,\n    coinbaseBuffer\n  };\n}\nexport function serializePayload(payload) {\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(payload.payloadType);\n\n  switch (payload.payloadType) {\n    case PayloadType.TokenTransfer:\n      bufferArray.push(serializeCV(payload.recipient));\n      bufferArray.push(intToBytes(payload.amount, false, 8));\n      bufferArray.push(serializeStacksMessage(payload.memo));\n      break;\n\n    case PayloadType.ContractCall:\n      bufferArray.push(serializeStacksMessage(payload.contractAddress));\n      bufferArray.push(serializeStacksMessage(payload.contractName));\n      bufferArray.push(serializeStacksMessage(payload.functionName));\n      const numArgs = Buffer.alloc(4);\n      numArgs.writeUInt32BE(payload.functionArgs.length, 0);\n      bufferArray.push(numArgs);\n      payload.functionArgs.forEach(arg => {\n        bufferArray.push(serializeCV(arg));\n      });\n      break;\n\n    case PayloadType.SmartContract:\n      bufferArray.push(serializeStacksMessage(payload.contractName));\n      bufferArray.push(serializeStacksMessage(payload.codeBody));\n      break;\n\n    case PayloadType.PoisonMicroblock:\n      break;\n\n    case PayloadType.Coinbase:\n      bufferArray.push(payload.coinbaseBuffer);\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\nexport function deserializePayload(bufferReader) {\n  const payloadType = bufferReader.readUInt8Enum(PayloadType, n => {\n    throw new Error(`Cannot recognize PayloadType: ${n}`);\n  });\n\n  switch (payloadType) {\n    case PayloadType.TokenTransfer:\n      const recipient = deserializeCV(bufferReader);\n      const amount = intToBigInt(bufferReader.readBuffer(8), false);\n      const memo = deserializeMemoString(bufferReader);\n      return createTokenTransferPayload(recipient, amount, memo);\n\n    case PayloadType.ContractCall:\n      const contractAddress = deserializeAddress(bufferReader);\n      const contractCallName = deserializeLPString(bufferReader);\n      const functionName = deserializeLPString(bufferReader);\n      const functionArgs = [];\n      const numberOfArgs = bufferReader.readUInt32BE();\n\n      for (let i = 0; i < numberOfArgs; i++) {\n        const clarityValue = deserializeCV(bufferReader);\n        functionArgs.push(clarityValue);\n      }\n\n      return createContractCallPayload(contractAddress, contractCallName, functionName, functionArgs);\n\n    case PayloadType.SmartContract:\n      const smartContractName = deserializeLPString(bufferReader);\n      const codeBody = deserializeLPString(bufferReader, 4, 100000);\n      return createSmartContractPayload(smartContractName, codeBody);\n\n    case PayloadType.PoisonMicroblock:\n      return createPoisonPayload();\n\n    case PayloadType.Coinbase:\n      const coinbaseBuffer = bufferReader.readBuffer(COINBASE_BUFFER_LENGTH_BYTES);\n      return createCoinbasePayload(coinbaseBuffer);\n  }\n}","map":{"version":3,"mappings":"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","names":["Buffer","intToBigInt","intToBytes","COINBASE_BUFFER_LENGTH_BYTES","PayloadType","StacksMessageType","BufferArray","createMemoString","serializeStacksMessage","deserializeAddress","deserializeLPString","deserializeMemoString","codeBodyString","createAddress","createLPString","serializeCV","deserializeCV","principalCV","createTokenTransferPayload","recipient","amount","memo","type","Payload","payloadType","TokenTransfer","createContractCallPayload","contractAddress","contractName","functionName","functionArgs","ContractCall","createSmartContractPayload","codeBody","SmartContract","createPoisonPayload","PoisonMicroblock","createCoinbasePayload","coinbaseBuffer","byteLength","Error","Coinbase","serializePayload","payload","bufferArray","appendByte","push","numArgs","alloc","writeUInt32BE","length","forEach","arg","concatBuffer","deserializePayload","bufferReader","readUInt8Enum","n","readBuffer","contractCallName","numberOfArgs","readUInt32BE","i","clarityValue","smartContractName"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\transactions\\src\\payload.ts"],"sourcesContent":["import { Buffer, IntegerType, intToBigInt, intToBytes } from '@stacks/common';\nimport { COINBASE_BUFFER_LENGTH_BYTES, PayloadType, StacksMessageType } from './constants';\n\nimport { BufferArray } from './utils';\n\nimport {\n  MemoString,\n  createMemoString,\n  serializeStacksMessage,\n  deserializeAddress,\n  deserializeLPString,\n  deserializeMemoString,\n  codeBodyString,\n} from './types';\nimport { createAddress, LengthPrefixedString, createLPString } from './postcondition-types';\nimport { Address } from './common';\nimport { ClarityValue, serializeCV, deserializeCV } from './clarity/';\n\nimport { BufferReader } from './bufferReader';\nimport { PrincipalCV, principalCV } from './clarity/types/principalCV';\n\nexport type Payload =\n  | TokenTransferPayload\n  | ContractCallPayload\n  | SmartContractPayload\n  | PoisonPayload\n  | CoinbasePayload;\n\nexport interface TokenTransferPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.TokenTransfer;\n  readonly recipient: PrincipalCV;\n  readonly amount: bigint;\n  readonly memo: MemoString;\n}\n\nexport type PayloadInput =\n  | (TokenTransferPayload | (Omit<TokenTransferPayload, 'amount'> & { amount: IntegerType }))\n  | ContractCallPayload\n  | SmartContractPayload\n  | PoisonPayload\n  | CoinbasePayload;\n\nexport function createTokenTransferPayload(\n  recipient: string | PrincipalCV,\n  amount: IntegerType,\n  memo?: string | MemoString\n): TokenTransferPayload {\n  if (typeof recipient === 'string') {\n    recipient = principalCV(recipient);\n  }\n  if (typeof memo === 'string') {\n    memo = createMemoString(memo);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.TokenTransfer,\n    recipient,\n    amount: intToBigInt(amount, false),\n    memo: memo ?? createMemoString(''),\n  };\n}\n\nexport interface ContractCallPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.ContractCall;\n  readonly contractAddress: Address;\n  readonly contractName: LengthPrefixedString;\n  readonly functionName: LengthPrefixedString;\n  readonly functionArgs: ClarityValue[];\n}\n\nexport function createContractCallPayload(\n  contractAddress: string | Address,\n  contractName: string | LengthPrefixedString,\n  functionName: string | LengthPrefixedString,\n  functionArgs: ClarityValue[]\n): ContractCallPayload {\n  if (typeof contractAddress === 'string') {\n    contractAddress = createAddress(contractAddress);\n  }\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof functionName === 'string') {\n    functionName = createLPString(functionName);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.ContractCall,\n    contractAddress,\n    contractName,\n    functionName,\n    functionArgs,\n  };\n}\n\nexport interface SmartContractPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.SmartContract;\n  readonly contractName: LengthPrefixedString;\n  readonly codeBody: LengthPrefixedString;\n}\n\nexport function createSmartContractPayload(\n  contractName: string | LengthPrefixedString,\n  codeBody: string | LengthPrefixedString\n): SmartContractPayload {\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof codeBody === 'string') {\n    codeBody = codeBodyString(codeBody);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.SmartContract,\n    contractName,\n    codeBody,\n  };\n}\n\nexport interface PoisonPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.PoisonMicroblock;\n}\n\nexport function createPoisonPayload(): PoisonPayload {\n  return { type: StacksMessageType.Payload, payloadType: PayloadType.PoisonMicroblock };\n}\n\nexport interface CoinbasePayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.Coinbase;\n  readonly coinbaseBuffer: Buffer;\n}\n\nexport function createCoinbasePayload(coinbaseBuffer: Buffer): CoinbasePayload {\n  if (coinbaseBuffer.byteLength != COINBASE_BUFFER_LENGTH_BYTES) {\n    throw Error(`Coinbase buffer size must be ${COINBASE_BUFFER_LENGTH_BYTES} bytes`);\n  }\n  return { type: StacksMessageType.Payload, payloadType: PayloadType.Coinbase, coinbaseBuffer };\n}\n\nexport function serializePayload(payload: PayloadInput): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(payload.payloadType);\n\n  switch (payload.payloadType) {\n    case PayloadType.TokenTransfer:\n      bufferArray.push(serializeCV(payload.recipient));\n      bufferArray.push(intToBytes(payload.amount, false, 8));\n      bufferArray.push(serializeStacksMessage(payload.memo));\n      break;\n    case PayloadType.ContractCall:\n      bufferArray.push(serializeStacksMessage(payload.contractAddress));\n      bufferArray.push(serializeStacksMessage(payload.contractName));\n      bufferArray.push(serializeStacksMessage(payload.functionName));\n      const numArgs = Buffer.alloc(4);\n      numArgs.writeUInt32BE(payload.functionArgs.length, 0);\n      bufferArray.push(numArgs);\n      payload.functionArgs.forEach(arg => {\n        bufferArray.push(serializeCV(arg));\n      });\n      break;\n    case PayloadType.SmartContract:\n      bufferArray.push(serializeStacksMessage(payload.contractName));\n      bufferArray.push(serializeStacksMessage(payload.codeBody));\n      break;\n    case PayloadType.PoisonMicroblock:\n      // TODO: implement\n      break;\n    case PayloadType.Coinbase:\n      bufferArray.push(payload.coinbaseBuffer);\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializePayload(bufferReader: BufferReader): Payload {\n  const payloadType = bufferReader.readUInt8Enum(PayloadType, n => {\n    throw new Error(`Cannot recognize PayloadType: ${n}`);\n  });\n\n  switch (payloadType) {\n    case PayloadType.TokenTransfer:\n      const recipient = deserializeCV(bufferReader) as PrincipalCV;\n      const amount = intToBigInt(bufferReader.readBuffer(8), false);\n      const memo = deserializeMemoString(bufferReader);\n      return createTokenTransferPayload(recipient, amount, memo);\n    case PayloadType.ContractCall:\n      const contractAddress = deserializeAddress(bufferReader);\n      const contractCallName = deserializeLPString(bufferReader);\n      const functionName = deserializeLPString(bufferReader);\n      const functionArgs: ClarityValue[] = [];\n      const numberOfArgs = bufferReader.readUInt32BE();\n      for (let i = 0; i < numberOfArgs; i++) {\n        const clarityValue = deserializeCV(bufferReader);\n        functionArgs.push(clarityValue);\n      }\n      return createContractCallPayload(\n        contractAddress,\n        contractCallName,\n        functionName,\n        functionArgs\n      );\n    case PayloadType.SmartContract:\n      const smartContractName = deserializeLPString(bufferReader);\n      const codeBody = deserializeLPString(bufferReader, 4, 100000);\n      return createSmartContractPayload(smartContractName, codeBody);\n    case PayloadType.PoisonMicroblock:\n      // TODO: implement\n      return createPoisonPayload();\n    case PayloadType.Coinbase:\n      const coinbaseBuffer = bufferReader.readBuffer(COINBASE_BUFFER_LENGTH_BYTES);\n      return createCoinbasePayload(coinbaseBuffer);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}