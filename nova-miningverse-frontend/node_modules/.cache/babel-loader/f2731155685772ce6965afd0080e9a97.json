{"ast":null,"code":"import { decodeToken, SECP256K1Client, TokenSigner, TokenVerifier } from 'jsontokens';\nimport { nextYear, makeUUID4 } from '@stacks/common';\nimport { getAddressFromPublicKey } from '@stacks/transactions';\nexport function signProfileToken(profile, privateKey, subject, issuer) {\n  let signingAlgorithm = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'ES256K';\n  let issuedAt = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Date();\n  let expiresAt = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : nextYear();\n\n  if (signingAlgorithm !== 'ES256K') {\n    throw new Error('Signing algorithm not supported');\n  }\n\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n\n  if (!subject) {\n    subject = {\n      publicKey\n    };\n  }\n\n  if (!issuer) {\n    issuer = {\n      publicKey\n    };\n  }\n\n  const tokenSigner = new TokenSigner(signingAlgorithm, privateKey);\n  const payload = {\n    jti: makeUUID4(),\n    iat: issuedAt.toISOString(),\n    exp: expiresAt.toISOString(),\n    subject,\n    issuer,\n    claim: profile\n  };\n  return tokenSigner.sign(payload);\n}\nexport function wrapProfileToken(token) {\n  return {\n    token,\n    decodedToken: decodeToken(token)\n  };\n}\nexport function verifyProfileToken(token, publicKeyOrAddress) {\n  const decodedToken = decodeToken(token);\n  const payload = decodedToken.payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  if (payload.hasOwnProperty('subject') && payload.subject) {\n    if (!payload.subject.hasOwnProperty('publicKey')) {\n      throw new Error(\"Token doesn't have a subject public key\");\n    }\n  } else {\n    throw new Error(\"Token doesn't have a subject\");\n  }\n\n  if (payload.hasOwnProperty('issuer') && payload.issuer) {\n    if (!payload.issuer.hasOwnProperty('publicKey')) {\n      throw new Error(\"Token doesn't have an issuer public key\");\n    }\n  } else {\n    throw new Error(\"Token doesn't have an issuer\");\n  }\n\n  if (!payload.hasOwnProperty('claim')) {\n    throw new Error(\"Token doesn't have a claim\");\n  }\n\n  const issuerPublicKey = payload.issuer.publicKey;\n  const address = getAddressFromPublicKey(issuerPublicKey);\n\n  if (publicKeyOrAddress === issuerPublicKey) {} else if (publicKeyOrAddress === address) {} else {\n    throw new Error('Token issuer public key does not match the verifying value');\n  }\n\n  const tokenVerifier = new TokenVerifier(decodedToken.header.alg, issuerPublicKey);\n\n  if (!tokenVerifier) {\n    throw new Error('Invalid token verifier');\n  }\n\n  const tokenVerified = tokenVerifier.verify(token);\n\n  if (!tokenVerified) {\n    throw new Error('Token verification failed');\n  }\n\n  return decodedToken;\n}\nexport function extractProfile(token) {\n  let publicKeyOrAddress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let decodedToken;\n\n  if (publicKeyOrAddress) {\n    decodedToken = verifyProfileToken(token, publicKeyOrAddress);\n  } else {\n    decodedToken = decodeToken(token);\n  }\n\n  let profile = {};\n\n  if (decodedToken.hasOwnProperty('payload')) {\n    const payload = decodedToken.payload;\n\n    if (typeof payload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n\n    if (payload.hasOwnProperty('claim')) {\n      profile = payload.claim;\n    }\n  }\n\n  return profile;\n}","map":{"version":3,"mappings":"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","names":["decodeToken","SECP256K1Client","TokenSigner","TokenVerifier","nextYear","makeUUID4","getAddressFromPublicKey","signProfileToken","profile","privateKey","subject","issuer","signingAlgorithm","issuedAt","Date","expiresAt","Error","publicKey","derivePublicKey","tokenSigner","payload","jti","iat","toISOString","exp","claim","sign","wrapProfileToken","token","decodedToken","verifyProfileToken","publicKeyOrAddress","hasOwnProperty","issuerPublicKey","address","tokenVerifier","header","alg","tokenVerified","verify","extractProfile"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\profile\\src\\profileTokens.ts"],"sourcesContent":["import { decodeToken, SECP256K1Client, TokenSigner, TokenVerifier } from 'jsontokens';\nimport { TokenInterface } from 'jsontokens/lib/decode';\nimport { nextYear, makeUUID4 } from '@stacks/common';\nimport { getAddressFromPublicKey } from '@stacks/transactions';\n\n/**\n * Signs a profile token\n * @param {Object} profile - the JSON of the profile to be signed\n * @param {String} privateKey - the signing private key\n * @param {Object} subject - the entity that the information is about\n * @param {Object} issuer - the entity that is issuing the token\n * @param {String} signingAlgorithm - the signing algorithm to use\n * @param {Date} issuedAt - the time of issuance of the token\n * @param {Date} expiresAt - the time of expiration of the token\n * @returns {Object} - the signed profile token\n *\n */\nexport function signProfileToken(\n  profile: any,\n  privateKey: string,\n  subject?: any,\n  issuer?: any,\n  signingAlgorithm = 'ES256K',\n  issuedAt = new Date(),\n  expiresAt = nextYear()\n): string {\n  if (signingAlgorithm !== 'ES256K') {\n    throw new Error('Signing algorithm not supported');\n  }\n\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n\n  if (!subject) {\n    subject = { publicKey };\n  }\n\n  if (!issuer) {\n    issuer = { publicKey };\n  }\n\n  const tokenSigner = new TokenSigner(signingAlgorithm, privateKey);\n\n  const payload = {\n    jti: makeUUID4(),\n    iat: issuedAt.toISOString(),\n    exp: expiresAt.toISOString(),\n    subject,\n    issuer,\n    claim: profile,\n  };\n\n  return tokenSigner.sign(payload);\n}\n\n/**\n * Wraps a token for a profile token file\n * @param {String} token - the token to be wrapped\n * @returns {Object} - including `token` and `decodedToken`\n */\nexport function wrapProfileToken(token: string) {\n  return {\n    token,\n    decodedToken: decodeToken(token),\n  };\n}\n\n/**\n * Verifies a profile token\n * @param {String} token - the token to be verified\n * @param {String} publicKeyOrAddress - the public key or address of the\n *   keypair that is thought to have signed the token\n * @returns {Object} - the verified, decoded profile token\n * @throws {Error} - throws an error if token verification fails\n */\nexport function verifyProfileToken(token: string, publicKeyOrAddress: string): TokenInterface {\n  const decodedToken = decodeToken(token);\n  const payload = decodedToken.payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  // Inspect and verify the subject\n  if (payload.hasOwnProperty('subject') && payload.subject) {\n    if (!payload.subject.hasOwnProperty('publicKey')) {\n      throw new Error(\"Token doesn't have a subject public key\");\n    }\n  } else {\n    throw new Error(\"Token doesn't have a subject\");\n  }\n\n  // Inspect and verify the issuer\n  if (payload.hasOwnProperty('issuer') && payload.issuer) {\n    if (!payload.issuer.hasOwnProperty('publicKey')) {\n      throw new Error(\"Token doesn't have an issuer public key\");\n    }\n  } else {\n    throw new Error(\"Token doesn't have an issuer\");\n  }\n\n  // Inspect and verify the claim\n  if (!payload.hasOwnProperty('claim')) {\n    throw new Error(\"Token doesn't have a claim\");\n  }\n\n  const issuerPublicKey = (payload.issuer as Record<string, string>).publicKey;\n  const address = getAddressFromPublicKey(issuerPublicKey);\n\n  if (publicKeyOrAddress === issuerPublicKey) {\n    // pass\n  } else if (publicKeyOrAddress === address) {\n    // pass\n  } else {\n    throw new Error('Token issuer public key does not match the verifying value');\n  }\n\n  const tokenVerifier = new TokenVerifier(decodedToken.header.alg as string, issuerPublicKey);\n  if (!tokenVerifier) {\n    throw new Error('Invalid token verifier');\n  }\n\n  const tokenVerified = tokenVerifier.verify(token);\n  if (!tokenVerified) {\n    throw new Error('Token verification failed');\n  }\n\n  return decodedToken;\n}\n\n/**\n * Extracts a profile from an encoded token and optionally verifies it,\n * if `publicKeyOrAddress` is provided.\n * @param {String} token - the token to be extracted\n * @param {String} publicKeyOrAddress - the public key or address of the\n *   keypair that is thought to have signed the token\n * @returns {Object} - the profile extracted from the encoded token\n * @throws {Error} - if the token isn't signed by the provided `publicKeyOrAddress`\n */\nexport function extractProfile(\n  token: string,\n  publicKeyOrAddress: string | null = null\n): Record<string, any> {\n  let decodedToken;\n  if (publicKeyOrAddress) {\n    decodedToken = verifyProfileToken(token, publicKeyOrAddress);\n  } else {\n    decodedToken = decodeToken(token);\n  }\n\n  let profile = {};\n  if (decodedToken.hasOwnProperty('payload')) {\n    const payload = decodedToken.payload;\n    if (typeof payload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n    if (payload.hasOwnProperty('claim')) {\n      profile = payload.claim as Record<string, any>;\n    }\n  }\n\n  return profile;\n}\n"]},"metadata":{},"sourceType":"module"}