{"ast":null,"code":"import { isSameOriginAbsoluteUrl } from '@stacks/common';\nimport { publicKeyToAddress } from '@stacks/encryption';\nimport { decodeToken, TokenVerifier } from 'jsontokens';\nimport { getAddressFromDID } from './dids';\nimport { fetchAppManifest } from './provider';\nexport function doSignaturesMatchPublicKeys(token) {\n  const payload = decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  const publicKeys = payload.public_keys;\n\n  if (publicKeys.length === 1) {\n    const publicKey = publicKeys[0];\n\n    try {\n      const tokenVerifier = new TokenVerifier('ES256k', publicKey);\n      return tokenVerifier.verify(token);\n    } catch (e) {\n      return false;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n}\nexport function doPublicKeysMatchIssuer(token) {\n  const payload = decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  const publicKeys = payload.public_keys;\n  const addressFromIssuer = getAddressFromDID(payload.iss);\n\n  if (publicKeys.length === 1) {\n    const addressFromPublicKeys = publicKeyToAddress(publicKeys[0]);\n\n    if (addressFromPublicKeys === addressFromIssuer) {\n      return true;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n\n  return false;\n}\nexport function isIssuanceDateValid(token) {\n  const payload = decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  if (payload.iat) {\n    if (typeof payload.iat !== 'number') {\n      return false;\n    }\n\n    const issuedAt = new Date(payload.iat * 1000);\n\n    if (new Date().getTime() < issuedAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\nexport function isExpirationDateValid(token) {\n  const payload = decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  if (payload.exp) {\n    if (typeof payload.exp !== 'number') {\n      return false;\n    }\n\n    const expiresAt = new Date(payload.exp * 1000);\n\n    if (new Date().getTime() > expiresAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\nexport function isManifestUriValid(token) {\n  const payload = decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  return isSameOriginAbsoluteUrl(payload.domain_name, payload.manifest_uri);\n}\nexport function isRedirectUriValid(token) {\n  const payload = decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  return isSameOriginAbsoluteUrl(payload.domain_name, payload.redirect_uri);\n}\nexport async function verifyAuthRequest(token) {\n  if (decodeToken(token).header.alg === 'none') {\n    throw new Error('Token must be signed in order to be verified');\n  }\n\n  const values = await Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), isManifestUriValid(token), isRedirectUriValid(token)]);\n  return values.every(val => val);\n}\nexport async function verifyAuthRequestAndLoadManifest(token) {\n  const valid = await verifyAuthRequest(token);\n\n  if (!valid) {\n    throw new Error('Token is an invalid auth request');\n  }\n\n  return fetchAppManifest(token);\n}\nexport async function verifyAuthResponse(token) {\n  const conditions = await Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token)]);\n  return conditions.every(val => val);\n}","map":{"version":3,"mappings":"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","names":["isSameOriginAbsoluteUrl","publicKeyToAddress","decodeToken","TokenVerifier","getAddressFromDID","fetchAppManifest","doSignaturesMatchPublicKeys","token","payload","Error","publicKeys","public_keys","length","publicKey","tokenVerifier","verify","e","doPublicKeysMatchIssuer","addressFromIssuer","iss","addressFromPublicKeys","isIssuanceDateValid","iat","issuedAt","Date","getTime","isExpirationDateValid","exp","expiresAt","isManifestUriValid","domain_name","manifest_uri","isRedirectUriValid","redirect_uri","verifyAuthRequest","header","alg","values","Promise","all","every","val","verifyAuthRequestAndLoadManifest","valid","verifyAuthResponse","conditions"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\auth\\src\\verification.ts"],"sourcesContent":["import { isSameOriginAbsoluteUrl } from '@stacks/common';\nimport { publicKeyToAddress } from '@stacks/encryption';\nimport { decodeToken, TokenVerifier } from 'jsontokens';\nimport { getAddressFromDID } from './dids';\nimport { fetchAppManifest } from './provider';\n\n/**\n * Checks if the ES256k signature on passed `token` match the claimed public key\n * in the payload key `public_keys`.\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} Returns `true` if the signature matches the claimed public key\n * @throws {Error} if `token` contains multiple public keys\n * @private\n * @ignore\n */\nexport function doSignaturesMatchPublicKeys(token: string): boolean {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  const publicKeys = payload.public_keys as string[];\n  if (publicKeys.length === 1) {\n    const publicKey = publicKeys[0];\n    try {\n      const tokenVerifier = new TokenVerifier('ES256k', publicKey);\n      return tokenVerifier.verify(token);\n    } catch (e) {\n      return false;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n}\n\n/**\n * Makes sure that the identity address portion of\n * the decentralized identifier passed in the issuer `iss`\n * key of the token matches the public key\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} if the identity address and public keys match\n * @throws {Error} if ` token` has multiple public keys\n * @private\n * @ignore\n */\nexport function doPublicKeysMatchIssuer(token: string): boolean {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  const publicKeys = payload.public_keys as string[];\n  const addressFromIssuer = getAddressFromDID(payload.iss);\n\n  if (publicKeys.length === 1) {\n    const addressFromPublicKeys = publicKeyToAddress(publicKeys[0]);\n    if (addressFromPublicKeys === addressFromIssuer) {\n      return true;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n\n  return false;\n}\n\n/**\n * Checks if the if the token issuance time and date is after the\n * current time and date.\n *\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the token was issued after the current time,\n * otherwise returns `false`\n * @private\n * @ignore\n */\nexport function isIssuanceDateValid(token: string) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  if (payload.iat) {\n    if (typeof payload.iat !== 'number') {\n      return false;\n    }\n    const issuedAt = new Date(payload.iat * 1000); // JWT times are in seconds\n    if (new Date().getTime() < issuedAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\n\n/**\n * Checks if the expiration date of the `token` is before the current time\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the `token` has not yet expired, `false`\n * if the `token` has expired\n *\n * @private\n * @ignore\n */\nexport function isExpirationDateValid(token: string) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  if (payload.exp) {\n    if (typeof payload.exp !== 'number') {\n      return false;\n    }\n    const expiresAt = new Date(payload.exp * 1000); // JWT times are in seconds\n    if (new Date().getTime() > expiresAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\n\n/**\n * Makes sure the `manifest_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n * @ignore\n */\nexport function isManifestUriValid(token: string) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  return isSameOriginAbsoluteUrl(payload.domain_name as string, payload.manifest_uri as string);\n}\n\n/**\n * Makes sure the `redirect_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n * @ignore\n */\nexport function isRedirectUriValid(token: string) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  return isSameOriginAbsoluteUrl(payload.domain_name as string, payload.redirect_uri as string);\n}\n\n/**\n * Verify authentication request is valid. This function performs a number\n * of checks on the authentication request token:\n * * Checks that `token` has a valid issuance date & is not expired\n * * Checks that `token` has a valid signature that matches the public key it claims\n * * Checks that both the manifest and redirect URLs are absolute and conform to\n * the same origin policy\n *\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to true if the auth request\n *  is valid and false if it does not. It rejects with a String if the\n *  token is not signed\n * @private\n * @ignore\n */\nexport async function verifyAuthRequest(token: string): Promise<boolean> {\n  if (decodeToken(token).header.alg === 'none') {\n    throw new Error('Token must be signed in order to be verified');\n  }\n  const values = await Promise.all([\n    isExpirationDateValid(token),\n    isIssuanceDateValid(token),\n    doSignaturesMatchPublicKeys(token),\n    doPublicKeysMatchIssuer(token),\n    isManifestUriValid(token),\n    isRedirectUriValid(token),\n  ]);\n  return values.every(val => val);\n}\n\n/**\n * Verify the authentication request is valid and\n * fetch the app manifest file if valid. Otherwise, reject the promise.\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to the app manifest file in JSON format\n * or rejects if the auth request or app manifest file is invalid\n * @private\n * @ignore\n */\nexport async function verifyAuthRequestAndLoadManifest(token: string): Promise<any> {\n  const valid = await verifyAuthRequest(token);\n  if (!valid) {\n    throw new Error('Token is an invalid auth request');\n  }\n  return fetchAppManifest(token);\n}\n\n/**\n * Verify the authentication response is valid.\n * @param {String} token the authentication response token\n * @return {Promise} that resolves to true if auth response\n * is valid and false if it does not\n * @private\n * @ignore\n */\nexport async function verifyAuthResponse(token: string): Promise<boolean> {\n  const conditions = await Promise.all([\n    isExpirationDateValid(token),\n    isIssuanceDateValid(token),\n    doSignaturesMatchPublicKeys(token),\n    doPublicKeysMatchIssuer(token),\n  ]);\n  return conditions.every(val => val);\n}\n"]},"metadata":{},"sourceType":"module"}