{"ast":null,"code":"import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { getPublicKey as nobleGetPublicKey, signSync, utils } from '@noble/secp256k1';\nimport { Buffer, privateKeyToBuffer, PRIVATE_KEY_COMPRESSED_LENGTH } from '@stacks/common';\nimport base58 from 'bs58';\nimport { hashRipemd160 } from './hashRipemd160';\nimport { hashSha256Sync } from './sha2Hash';\nconst BITCOIN_PUBKEYHASH = 0x00;\n\nutils.hmacSha256Sync = function (key) {\n  const h = hmac.create(sha256, key);\n\n  for (var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    msgs[_key - 1] = arguments[_key];\n  }\n\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\n\nexport function makeECPrivateKey() {\n  return Buffer.from(utils.randomPrivateKey()).toString('hex');\n}\nexport function base58CheckDecode(btcAddress) {\n  const buffer = Buffer.from(base58.decode(btcAddress));\n  const payload = buffer.slice(0, -4);\n  const checksum = buffer.slice(-4);\n  const newChecksum = sha256(sha256(payload));\n\n  if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) {\n    throw new Error('Invalid checksum');\n  }\n\n  if (payload.length !== 21) throw new TypeError('Invalid address length');\n  const version = payload.readUInt8(0);\n  const hash = payload.slice(1);\n  return {\n    version,\n    hash\n  };\n}\nexport function base58Encode(hash) {\n  const checksum = Buffer.from(sha256(sha256(hash)));\n  return base58.encode(Buffer.concat([hash, checksum], hash.length + 4));\n}\nexport function base58CheckEncode(version, hash) {\n  return base58Encode(Buffer.from([version, ...hash].slice(0, 21)));\n}\nexport function publicKeyToAddress(publicKey) {\n  const publicKeyBuffer = Buffer.isBuffer(publicKey) ? publicKey : Buffer.from(publicKey, 'hex');\n  const publicKeyHash160 = hashRipemd160(hashSha256Sync(publicKeyBuffer));\n  return base58CheckEncode(BITCOIN_PUBKEYHASH, publicKeyHash160);\n}\nexport function publicKeyToBtcAddress(publicKey) {\n  let version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BITCOIN_PUBKEYHASH;\n  const publicKeyBuffer = Buffer.isBuffer(publicKey) ? publicKey : Buffer.from(publicKey, 'hex');\n  const publicKeyHash160 = hashRipemd160(hashSha256Sync(publicKeyBuffer));\n  return base58CheckEncode(version, publicKeyHash160);\n}\nexport function getPublicKeyFromPrivate(privateKey) {\n  const privateKeyBuffer = privateKeyToBuffer(privateKey);\n  return Buffer.from(nobleGetPublicKey(privateKeyBuffer.slice(0, 32), true)).toString('hex');\n}\nexport function ecSign(messageHash, hexPrivateKey) {\n  return Buffer.from(signSync(messageHash, privateKeyToBuffer(hexPrivateKey).slice(0, 32), {\n    der: false\n  }));\n}\nexport function ecPrivateKeyToHexString(privateKey) {\n  return privateKey.toString('hex');\n}\nexport function isValidPrivateKey(privateKey) {\n  return utils.isValidPrivateKey(privateKeyToBuffer(privateKey));\n}\nexport function compressPrivateKey(privateKey) {\n  const privateKeyBuffer = privateKeyToBuffer(privateKey);\n  return privateKeyBuffer.length == PRIVATE_KEY_COMPRESSED_LENGTH ? privateKeyBuffer : Buffer.concat([privateKeyBuffer, Buffer.from([1])]);\n}","map":{"version":3,"mappings":"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","names":["hmac","sha256","getPublicKey","nobleGetPublicKey","signSync","utils","Buffer","privateKeyToBuffer","PRIVATE_KEY_COMPRESSED_LENGTH","base58","hashRipemd160","hashSha256Sync","BITCOIN_PUBKEYHASH","hmacSha256Sync","key","h","create","msgs","forEach","msg","update","digest","makeECPrivateKey","from","randomPrivateKey","toString","base58CheckDecode","btcAddress","buffer","decode","payload","slice","checksum","newChecksum","Error","length","TypeError","version","readUInt8","hash","base58Encode","encode","concat","base58CheckEncode","publicKeyToAddress","publicKey","publicKeyBuffer","isBuffer","publicKeyHash160","publicKeyToBtcAddress","getPublicKeyFromPrivate","privateKey","privateKeyBuffer","ecSign","messageHash","hexPrivateKey","der","ecPrivateKeyToHexString","isValidPrivateKey","compressPrivateKey"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\encryption\\src\\keys.ts"],"sourcesContent":["import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { getPublicKey as nobleGetPublicKey, signSync, utils } from '@noble/secp256k1';\nimport { Buffer, privateKeyToBuffer, PRIVATE_KEY_COMPRESSED_LENGTH } from '@stacks/common';\nimport base58 from 'bs58';\nimport { hashRipemd160 } from './hashRipemd160';\nimport { hashSha256Sync } from './sha2Hash';\n\nconst BITCOIN_PUBKEYHASH = 0x00;\n\n/**\n * To use secp256k1.signSync set utils.hmacSha256Sync to a function using noble-hashes\n * secp256k1.signSync is the counter part of secp256k1.sign (async version)\n * secp256k1.signSync is used within signWithKey in this file\n * secp256k1.signSync is used to maintain the semantics of signWithKey while migrating from elliptic lib\n * utils.hmacSha256Sync docs: https://github.com/paulmillr/noble-secp256k1 readme file\n */\nutils.hmacSha256Sync = (key: Uint8Array, ...msgs: Uint8Array[]) => {\n  const h = hmac.create(sha256, key);\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\n\n/**\n * @ignore\n */\nexport function makeECPrivateKey() {\n  return Buffer.from(utils.randomPrivateKey()).toString('hex');\n}\n\n/**\n * Based on bitcoinjs-lib MIT https://github.com/bitcoinjs/bs58check/blob/12b3e700f355c5c49d0be3f8fc29be6c66e753e9/base.js\n * @ignore\n */\nexport function base58CheckDecode(btcAddress: string): {\n  version: number;\n  hash: Buffer;\n} {\n  const buffer = Buffer.from(base58.decode(btcAddress));\n  const payload = buffer.slice(0, -4);\n  const checksum = buffer.slice(-4);\n  const newChecksum = sha256(sha256(payload));\n\n  if (\n    (checksum[0] ^ newChecksum[0]) |\n    (checksum[1] ^ newChecksum[1]) |\n    (checksum[2] ^ newChecksum[2]) |\n    (checksum[3] ^ newChecksum[3])\n  ) {\n    throw new Error('Invalid checksum');\n  }\n\n  if (payload.length !== 21) throw new TypeError('Invalid address length');\n\n  const version = payload.readUInt8(0);\n  const hash = payload.slice(1);\n\n  return { version, hash };\n}\n\n/**\n * @ignore\n */\nexport function base58Encode(hash: Buffer) {\n  const checksum = Buffer.from(sha256(sha256(hash)));\n  return base58.encode(Buffer.concat([hash, checksum], hash.length + 4));\n}\n\n/**\n * @ignore\n */\nexport function base58CheckEncode(version: number, hash: Buffer) {\n  return base58Encode(Buffer.from([version, ...hash].slice(0, 21)));\n}\n\n/**\n * @ignore\n * @deprecated Use {@link publicKeyToBtcAddress} instead\n */\nexport function publicKeyToAddress(publicKey: string | Buffer) {\n  const publicKeyBuffer = Buffer.isBuffer(publicKey) ? publicKey : Buffer.from(publicKey, 'hex');\n  const publicKeyHash160 = hashRipemd160(hashSha256Sync(publicKeyBuffer));\n  return base58CheckEncode(BITCOIN_PUBKEYHASH, publicKeyHash160);\n}\n\n/**\n * @ignore\n */\nexport function publicKeyToBtcAddress(\n  publicKey: string | Buffer,\n  version: number = BITCOIN_PUBKEYHASH\n) {\n  const publicKeyBuffer = Buffer.isBuffer(publicKey) ? publicKey : Buffer.from(publicKey, 'hex');\n  const publicKeyHash160 = hashRipemd160(hashSha256Sync(publicKeyBuffer));\n  return base58CheckEncode(version, publicKeyHash160);\n}\n\n/**\n * @ignore\n * @returns a compressed public key\n */\nexport function getPublicKeyFromPrivate(privateKey: string | Buffer) {\n  const privateKeyBuffer = privateKeyToBuffer(privateKey);\n  // for backwards compatibility we always return a compressed public key, regardless of private key mode\n  return Buffer.from(nobleGetPublicKey(privateKeyBuffer.slice(0, 32), true)).toString('hex');\n}\n\n/**\n * @ignore\n */\nexport function ecSign(messageHash: Buffer, hexPrivateKey: string | Buffer) {\n  return Buffer.from(\n    signSync(messageHash, privateKeyToBuffer(hexPrivateKey).slice(0, 32), {\n      der: false,\n    })\n  );\n}\n\n/**\n * @ignore\n */\nexport function ecPrivateKeyToHexString(privateKey: Buffer): string {\n  return privateKey.toString('hex');\n}\n\n/**\n * @ignore\n */\nexport function isValidPrivateKey(privateKey: string | Buffer): boolean {\n  return utils.isValidPrivateKey(privateKeyToBuffer(privateKey));\n}\n\n/**\n * @ignore\n */\nexport function compressPrivateKey(privateKey: string | Buffer): Buffer {\n  const privateKeyBuffer = privateKeyToBuffer(privateKey);\n\n  return privateKeyBuffer.length == PRIVATE_KEY_COMPRESSED_LENGTH\n    ? privateKeyBuffer // leave compressed\n    : Buffer.concat([privateKeyBuffer, Buffer.from([1])]); // compress\n}\n"]},"metadata":{},"sourceType":"module"}