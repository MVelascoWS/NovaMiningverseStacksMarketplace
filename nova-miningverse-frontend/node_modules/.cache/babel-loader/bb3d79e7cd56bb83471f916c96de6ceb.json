{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { getCryptoLib } from './cryptoUtils';\nexport class NodeCryptoPbkdf2 {\n  constructor(nodePbkdf2) {\n    this.nodePbkdf2 = nodePbkdf2;\n  }\n\n  async derive(password, salt, iterations, keyLength, digest) {\n    if (digest !== 'sha512' && digest !== 'sha256') {\n      throw new Error(`Unsupported digest \"${digest}\" for Pbkdf2`);\n    }\n\n    return new Promise((resolve, reject) => {\n      this.nodePbkdf2(password, salt, iterations, keyLength, digest, (error, result) => {\n        if (error) {\n          reject(error);\n        }\n\n        resolve(result);\n      });\n    });\n  }\n\n}\nexport class WebCryptoPbkdf2 {\n  constructor(subtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  async derive(password, salt, iterations, keyLength, digest) {\n    let algo;\n\n    if (digest === 'sha256') {\n      algo = 'SHA-256';\n    } else if (digest === 'sha512') {\n      algo = 'SHA-512';\n    } else {\n      throw new Error(`Unsupported Pbkdf2 digest algorithm \"${digest}\"`);\n    }\n\n    let result;\n    const passwordBytes = Buffer.from(password, 'utf8');\n\n    try {\n      const key = await this.subtleCrypto.importKey('raw', passwordBytes, 'PBKDF2', false, ['deriveBits']);\n      result = await this.subtleCrypto.deriveBits({\n        name: 'PBKDF2',\n        salt,\n        iterations,\n        hash: {\n          name: algo\n        }\n      }, key, keyLength * 8);\n    } catch (error) {\n      const partialWebCrypto = new WebCryptoPartialPbkdf2(this.subtleCrypto);\n      return partialWebCrypto.derive(password, salt, iterations, keyLength, digest);\n    }\n\n    return Buffer.from(result);\n  }\n\n}\nexport class WebCryptoPartialPbkdf2 {\n  constructor(subtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  async derive(password, salt, iterations, keyLength, digest) {\n    if (digest !== 'sha512' && digest !== 'sha256') {\n      throw new Error(`Unsupported digest \"${digest}\" for Pbkdf2`);\n    }\n\n    const key = Buffer.from(password, 'utf8');\n    const algo = digest === 'sha512' ? 'SHA-512' : 'SHA-256';\n    const algoOpts = {\n      name: 'HMAC',\n      hash: algo\n    };\n\n    const hmacDigest = (key, data) => this.subtleCrypto.importKey('raw', key, algoOpts, true, ['sign']).then(cryptoKey => this.subtleCrypto.sign(algoOpts, cryptoKey, data)).then(result => new Uint8Array(result));\n\n    const DK = new Uint8Array(keyLength);\n    const saltLength = salt.length;\n    const block1 = new Uint8Array(saltLength + 4);\n    block1.set(salt);\n    let destPos = 0;\n    const hLen = digest === 'sha512' ? 64 : 32;\n    const l = Math.ceil(keyLength / hLen);\n\n    function writeUInt32BE(data, value, offset) {\n      value = +value;\n      offset >>>= 0;\n      data[offset] = value >>> 24;\n      data[offset + 1] = value >>> 16;\n      data[offset + 2] = value >>> 8;\n      data[offset + 3] = value & 0xff;\n      return offset + 4;\n    }\n\n    for (let i = 1; i <= l; i++) {\n      writeUInt32BE(block1, i, saltLength);\n      const T = await hmacDigest(key, block1);\n      let U = T;\n\n      for (let j = 1; j < iterations; j++) {\n        U = await hmacDigest(key, U);\n\n        for (let k = 0; k < hLen; k++) {\n          T[k] ^= U[k];\n        }\n      }\n\n      DK.set(T.subarray(0, DK.byteLength - destPos), destPos);\n      destPos += hLen;\n    }\n\n    return Buffer.from(DK.buffer);\n  }\n\n}\nexport async function createPbkdf2() {\n  const cryptoLib = await getCryptoLib();\n\n  if (cryptoLib.name === 'subtleCrypto') {\n    return new WebCryptoPbkdf2(cryptoLib.lib);\n  } else {\n    return new NodeCryptoPbkdf2(cryptoLib.lib.pbkdf2);\n  }\n}","map":{"version":3,"mappings":"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","names":["Buffer","getCryptoLib","NodeCryptoPbkdf2","constructor","nodePbkdf2","derive","password","salt","iterations","keyLength","digest","Error","Promise","resolve","reject","error","result","WebCryptoPbkdf2","subtleCrypto","algo","passwordBytes","from","key","importKey","deriveBits","name","hash","partialWebCrypto","WebCryptoPartialPbkdf2","algoOpts","hmacDigest","data","then","cryptoKey","sign","Uint8Array","DK","saltLength","length","block1","set","destPos","hLen","l","Math","ceil","writeUInt32BE","value","offset","i","T","U","j","k","subarray","byteLength","buffer","createPbkdf2","cryptoLib","lib","pbkdf2"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\encryption\\src\\pbkdf2.ts"],"sourcesContent":["import { Buffer } from '@stacks/common';\nimport { getCryptoLib } from './cryptoUtils';\n\nexport type Pbkdf2Digests = 'sha512' | 'sha256';\n\nexport interface Pbkdf2 {\n  derive(\n    password: string,\n    salt: Buffer,\n    iterations: number,\n    keyLength: number,\n    digest: Pbkdf2Digests\n  ): Promise<Buffer>;\n}\n\ntype NodePbkdf2Fn = typeof import('crypto').pbkdf2;\n\nexport class NodeCryptoPbkdf2 implements Pbkdf2 {\n  nodePbkdf2: NodePbkdf2Fn;\n\n  constructor(nodePbkdf2: NodePbkdf2Fn) {\n    this.nodePbkdf2 = nodePbkdf2;\n  }\n\n  async derive(\n    password: string,\n    salt: Buffer,\n    iterations: number,\n    keyLength: number,\n    digest: Pbkdf2Digests\n  ): Promise<Buffer> {\n    if (digest !== 'sha512' && digest !== 'sha256') {\n      throw new Error(`Unsupported digest \"${digest}\" for Pbkdf2`);\n    }\n    return new Promise((resolve, reject) => {\n      this.nodePbkdf2(password, salt, iterations, keyLength, digest, (error, result) => {\n        if (error) {\n          reject(error);\n        }\n        resolve(result);\n      });\n    });\n  }\n}\n\nexport class WebCryptoPbkdf2 implements Pbkdf2 {\n  subtleCrypto: SubtleCrypto;\n\n  constructor(subtleCrypto: SubtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  async derive(\n    password: string,\n    salt: Buffer,\n    iterations: number,\n    keyLength: number,\n    digest: Pbkdf2Digests\n  ): Promise<Buffer> {\n    let algo: string;\n    if (digest === 'sha256') {\n      algo = 'SHA-256';\n    } else if (digest === 'sha512') {\n      algo = 'SHA-512';\n    } else {\n      throw new Error(`Unsupported Pbkdf2 digest algorithm \"${digest}\"`);\n    }\n    let result: ArrayBuffer;\n    const passwordBytes = Buffer.from(password, 'utf8');\n    try {\n      const key = await this.subtleCrypto.importKey('raw', passwordBytes, 'PBKDF2', false, [\n        'deriveBits',\n      ]);\n      result = await this.subtleCrypto.deriveBits(\n        {\n          name: 'PBKDF2',\n          salt,\n          iterations,\n          hash: { name: algo },\n        },\n        key,\n        keyLength * 8\n      );\n    } catch (error) {\n      // Browser appears to support WebCrypto but missing pbkdf2 support.\n      const partialWebCrypto = new WebCryptoPartialPbkdf2(this.subtleCrypto);\n      return partialWebCrypto.derive(password, salt, iterations, keyLength, digest);\n    }\n    return Buffer.from(result);\n  }\n}\n\nexport class WebCryptoPartialPbkdf2 implements Pbkdf2 {\n  // An async implementation for browsers that support WebCrypto hmac\n  // but not pbkdf2. Extracted from crypto-browserify/pbkdf2 and modified to\n  // use WebCrypto for hmac operations.\n  // Original: https://github.com/crypto-browserify/pbkdf2/tree/v3.0.17/lib\n\n  subtleCrypto: SubtleCrypto;\n\n  constructor(subtleCrypto: SubtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  async derive(\n    password: string,\n    salt: Buffer,\n    iterations: number,\n    keyLength: number,\n    digest: Pbkdf2Digests\n  ): Promise<Buffer> {\n    if (digest !== 'sha512' && digest !== 'sha256') {\n      throw new Error(`Unsupported digest \"${digest}\" for Pbkdf2`);\n    }\n    const key = Buffer.from(password, 'utf8');\n    const algo = digest === 'sha512' ? 'SHA-512' : 'SHA-256';\n    const algoOpts = { name: 'HMAC', hash: algo };\n    const hmacDigest = (key: ArrayBuffer, data: ArrayBuffer) =>\n      this.subtleCrypto\n        .importKey('raw', key, algoOpts, true, ['sign'])\n        .then(cryptoKey => this.subtleCrypto.sign(algoOpts, cryptoKey, data))\n        .then(result => new Uint8Array(result));\n\n    const DK = new Uint8Array(keyLength);\n    const saltLength = salt.length;\n    const block1 = new Uint8Array(saltLength + 4);\n    block1.set(salt);\n    let destPos = 0;\n    const hLen = digest === 'sha512' ? 64 : 32;\n    const l = Math.ceil(keyLength / hLen);\n\n    function writeUInt32BE(data: Uint8Array, value: number, offset: number) {\n      value = +value;\n      offset >>>= 0;\n      data[offset] = value >>> 24;\n      data[offset + 1] = value >>> 16;\n      data[offset + 2] = value >>> 8;\n      data[offset + 3] = value & 0xff;\n      return offset + 4;\n    }\n\n    for (let i = 1; i <= l; i++) {\n      writeUInt32BE(block1, i, saltLength);\n      const T = await hmacDigest(key, block1);\n      let U = T;\n      for (let j = 1; j < iterations; j++) {\n        U = await hmacDigest(key, U);\n        for (let k = 0; k < hLen; k++) {\n          T[k] ^= U[k];\n        }\n      }\n      DK.set(T.subarray(0, DK.byteLength - destPos), destPos);\n      destPos += hLen;\n    }\n    return Buffer.from(DK.buffer);\n  }\n}\n\nexport async function createPbkdf2(): Promise<Pbkdf2> {\n  const cryptoLib = await getCryptoLib();\n  if (cryptoLib.name === 'subtleCrypto') {\n    return new WebCryptoPbkdf2(cryptoLib.lib);\n  } else {\n    return new NodeCryptoPbkdf2(cryptoLib.lib.pbkdf2);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}