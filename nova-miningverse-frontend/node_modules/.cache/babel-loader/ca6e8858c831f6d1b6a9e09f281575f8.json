{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { SmartBuffer } from 'smart-buffer';\n\nfunction createEnumChecker(enumVariable) {\n  const enumValues = Object.values(enumVariable).filter(v => typeof v === 'number');\n  const enumValueSet = new Set(enumValues);\n  return value => enumValueSet.has(value);\n}\n\nconst enumCheckFunctions = new Map();\nexport function isEnum(enumVariable, value) {\n  const checker = enumCheckFunctions.get(enumVariable);\n\n  if (checker !== undefined) {\n    return checker(value);\n  }\n\n  const newChecker = createEnumChecker(enumVariable);\n  enumCheckFunctions.set(enumVariable, newChecker);\n  return isEnum(enumVariable, value);\n}\nexport class BufferReader {\n  constructor(options) {\n    if (Buffer.isBuffer(options)) {\n      this.smartBuffer = new SmartBuffer({\n        buff: options\n      });\n    } else {\n      this.smartBuffer = new SmartBuffer(options);\n    }\n  }\n\n  static fromBuffer(buffer) {\n    return new BufferReader({\n      buff: buffer\n    });\n  }\n\n  readBuffer(length) {\n    return this.smartBuffer.readBuffer(length);\n  }\n\n  readUInt32BE(offset) {\n    return this.smartBuffer.readUInt32BE(offset);\n  }\n\n  readUInt8() {\n    return this.smartBuffer.readUInt8();\n  }\n\n  readUInt16BE() {\n    return this.smartBuffer.readUInt16BE();\n  }\n\n  readBigUIntLE(length) {\n    const buffer = Buffer.from(this.smartBuffer.readBuffer(length)).reverse();\n    const hex = buffer.toString();\n    const num = BigInt(`0x${hex}`);\n    return num;\n  }\n\n  readBigUIntBE(length) {\n    const buffer = this.smartBuffer.readBuffer(length);\n    const hex = buffer.toString('hex');\n    const num = BigInt(`0x${hex}`);\n    return num;\n  }\n\n  readBigUInt64BE() {\n    return this.smartBuffer.readBigUInt64BE();\n  }\n\n  readString(arg, encoding) {\n    return this.smartBuffer.readString(arg, encoding);\n  }\n\n  get readOffset() {\n    return this.smartBuffer.readOffset;\n  }\n\n  set readOffset(val) {\n    this.smartBuffer.readOffset = val;\n  }\n\n  get internalBuffer() {\n    return this.smartBuffer.internalBuffer;\n  }\n\n  readUInt8Enum(enumVariable, invalidEnumErrorFormatter) {\n    const num = this.smartBuffer.readUInt8();\n\n    if (isEnum(enumVariable, num)) {\n      return num;\n    } else {\n      throw invalidEnumErrorFormatter(num);\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Buffer","SmartBuffer","createEnumChecker","enumVariable","enumValues","Object","values","filter","v","enumValueSet","Set","value","has","enumCheckFunctions","Map","isEnum","checker","get","undefined","newChecker","set","BufferReader","constructor","options","isBuffer","smartBuffer","buff","fromBuffer","buffer","readBuffer","length","readUInt32BE","offset","readUInt8","readUInt16BE","readBigUIntLE","from","reverse","hex","toString","num","BigInt","readBigUIntBE","readBigUInt64BE","readString","arg","encoding","readOffset","val","internalBuffer","readUInt8Enum","invalidEnumErrorFormatter"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\connect-react\\node_modules\\@stacks\\transactions\\src\\bufferReader.ts"],"sourcesContent":["import { Buffer } from '@stacks/common';\nimport { SmartBuffer, SmartBufferOptions } from 'smart-buffer';\n\nfunction createEnumChecker<T extends string, TEnumValue extends number>(enumVariable: {\n  [key in T]: TEnumValue;\n}): (value: number) => value is TEnumValue {\n  // Create a set of valid enum number values.\n  const enumValues = Object.values<number>(enumVariable).filter(v => typeof v === 'number');\n  const enumValueSet = new Set<number>(enumValues);\n  return (value: number): value is TEnumValue => enumValueSet.has(value);\n}\n\nconst enumCheckFunctions = new Map<object, (value: number) => boolean>();\n\n/**\n * Type guard to check if a given value is a valid enum value.\n * @param enumVariable - Literal `enum` type.\n * @param value - A value to check against the enum's values.\n * @example\n * ```ts\n * enum Color {\n *   Purple = 3,\n *   Orange = 5\n * }\n * const val: number = 3;\n * if (isEnum(Color, val)) {\n *   // `val` is known as enum type `Color`, e.g.:\n *   const colorVal: Color = val;\n * }\n * ```\n */\nexport function isEnum<T extends string, TEnumValue extends number>(\n  enumVariable: { [key in T]: TEnumValue },\n  value: number\n): value is TEnumValue {\n  const checker = enumCheckFunctions.get(enumVariable);\n  if (checker !== undefined) {\n    return checker(value);\n  }\n  const newChecker = createEnumChecker(enumVariable);\n  enumCheckFunctions.set(enumVariable, newChecker);\n  return isEnum(enumVariable, value);\n}\n\nexport class BufferReader {\n  smartBuffer: SmartBuffer;\n\n  static fromBuffer(buffer: Buffer): BufferReader {\n    return new BufferReader({ buff: buffer });\n  }\n\n  constructor(options?: SmartBufferOptions | Buffer) {\n    if (Buffer.isBuffer(options)) {\n      this.smartBuffer = new SmartBuffer({ buff: options });\n    } else {\n      this.smartBuffer = new SmartBuffer(options);\n    }\n  }\n\n  readBuffer(length: number): Buffer {\n    return this.smartBuffer.readBuffer(length);\n  }\n\n  readUInt32BE(offset?: number): number {\n    return this.smartBuffer.readUInt32BE(offset);\n  }\n\n  readUInt8(): number {\n    return this.smartBuffer.readUInt8();\n  }\n\n  readUInt16BE(): number {\n    return this.smartBuffer.readUInt16BE();\n  }\n\n  readBigUIntLE(length: number): bigint {\n    const buffer = Buffer.from(this.smartBuffer.readBuffer(length)).reverse();\n    const hex = buffer.toString();\n    const num = BigInt(`0x${hex}`);\n    return num;\n  }\n\n  readBigUIntBE(length: number): bigint {\n    const buffer = this.smartBuffer.readBuffer(length);\n    const hex = buffer.toString('hex');\n    const num = BigInt(`0x${hex}`);\n    return num;\n  }\n\n  readBigUInt64BE(): bigint {\n    return this.smartBuffer.readBigUInt64BE();\n  }\n\n  readString(arg?: number | BufferEncoding, encoding?: BufferEncoding): string {\n    return this.smartBuffer.readString(arg, encoding);\n  }\n\n  get readOffset(): number {\n    return this.smartBuffer.readOffset;\n  }\n\n  set readOffset(val: number) {\n    this.smartBuffer.readOffset = val;\n  }\n\n  get internalBuffer(): Buffer {\n    return this.smartBuffer.internalBuffer;\n  }\n\n  readUInt8Enum<T extends string, TEnumValue extends number>(\n    enumVariable: { [key in T]: TEnumValue },\n    invalidEnumErrorFormatter: (val: number) => Error\n  ): TEnumValue {\n    const num = this.smartBuffer.readUInt8();\n    if (isEnum(enumVariable, num)) {\n      return num;\n    } else {\n      throw invalidEnumErrorFormatter(num);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}