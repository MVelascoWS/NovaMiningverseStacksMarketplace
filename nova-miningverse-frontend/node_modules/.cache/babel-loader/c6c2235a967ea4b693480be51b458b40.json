{"ast":null,"code":"import 'cross-fetch/polyfill';\nconst defaultFetchOpts = {\n  referrerPolicy: 'origin'\n};\nexport const getFetchOptions = () => {\n  return defaultFetchOpts;\n};\nexport const setFetchOptions = ops => {\n  return Object.assign(defaultFetchOpts, ops);\n};\nexport async function fetchWrapper(input, init) {\n  const fetchOpts = {};\n  Object.assign(fetchOpts, init, defaultFetchOpts);\n  const fetchResult = await fetch(input, fetchOpts);\n  return fetchResult;\n}\nexport function hostMatches(host, pattern) {\n  if (typeof pattern === 'string') return pattern === host;\n  return pattern.exec(host);\n}\nexport function createApiKeyMiddleware(_ref) {\n  let {\n    apiKey,\n    host = /(.*)api(.*)\\.stacks\\.co$/i,\n    httpHeader = 'x-api-key'\n  } = _ref;\n  return {\n    pre: context => {\n      const reqUrl = new URL(context.url);\n      if (!hostMatches(reqUrl.host, host)) return;\n      const headers = new Headers(context.init.headers);\n      headers.set(httpHeader, apiKey);\n      context.init.headers = headers;\n    }\n  };\n}\n\nfunction argsForCreateFetchFn(args) {\n  let fetchLib = fetchWrapper;\n  let middlewares = [];\n\n  if (args.length > 0 && typeof args[0] === 'function') {\n    fetchLib = args.shift();\n  }\n\n  if (args.length > 0) {\n    middlewares = args;\n  }\n\n  return {\n    fetchLib,\n    middlewares\n  };\n}\n\nexport function createFetchFn() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  const {\n    fetchLib,\n    middlewares\n  } = argsForCreateFetchFn(args);\n\n  const fetchFn = async (url, init) => {\n    var _a;\n\n    let fetchParams = {\n      url,\n      init: init !== null && init !== void 0 ? init : {}\n    };\n\n    for (const middleware of middlewares) {\n      if (typeof middleware.pre === 'function') {\n        const result = await Promise.resolve(middleware.pre(Object.assign({\n          fetch: fetchLib\n        }, fetchParams)));\n        fetchParams = result !== null && result !== void 0 ? result : fetchParams;\n      }\n    }\n\n    let response = await fetchLib(fetchParams.url, fetchParams.init);\n\n    for (const middleware of middlewares) {\n      if (typeof middleware.post === 'function') {\n        const result = await Promise.resolve(middleware.post({\n          fetch: fetchLib,\n          url: fetchParams.url,\n          init: fetchParams.init,\n          response: (_a = response === null || response === void 0 ? void 0 : response.clone()) !== null && _a !== void 0 ? _a : response\n        }));\n        response = result !== null && result !== void 0 ? result : response;\n      }\n    }\n\n    return response;\n  };\n\n  return fetchFn;\n}","map":{"version":3,"mappings":"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","names":["defaultFetchOpts","referrerPolicy","getFetchOptions","setFetchOptions","ops","Object","assign","fetchWrapper","input","init","fetchOpts","fetchResult","fetch","hostMatches","host","pattern","exec","createApiKeyMiddleware","apiKey","httpHeader","pre","context","reqUrl","URL","url","headers","Headers","set","argsForCreateFetchFn","args","fetchLib","middlewares","length","shift","createFetchFn","fetchFn","fetchParams","middleware","result","Promise","resolve","response","post","clone","_a"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\connect-react\\node_modules\\@stacks\\transactions\\node_modules\\@stacks\\network\\src\\fetch.ts"],"sourcesContent":["import 'cross-fetch/polyfill';\n\n// Define a default request options and allow modification using getters, setters\n// Reference: https://developer.mozilla.org/en-US/docs/Web/API/Request/Request\nconst defaultFetchOpts: RequestInit = {\n  // By default referrer value will be client:origin: above reference link\n  referrerPolicy: 'origin', // Use origin value for referrer policy\n  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy\n};\n\n/**\n * Get fetch options\n * @category Network\n */\nexport const getFetchOptions = () => {\n  return defaultFetchOpts;\n};\n\n/**\n * Sets global fetch options for stacks.js network calls.\n *\n * @example\n * Users can change the default referrer as well as other options when fetch is used internally by stacks.js:\n * ```\n * setFetchOptions({ referrer: 'no-referrer', referrerPolicy: 'no-referrer', ...otherRequestOptions });\n * ```\n * After calling {@link setFetchOptions} all subsequent network calls will use the specified options above.\n *\n * @see MDN Request: https://developer.mozilla.org/en-US/docs/Web/API/Request/Request\n * @returns global fetch options after merging with previous options (or defaults)\n * @category Network\n * @related {@link getFetchOptions}\n */\nexport const setFetchOptions = (ops: RequestInit): RequestInit => {\n  return Object.assign(defaultFetchOpts, ops);\n};\n\n/** @internal */\nexport async function fetchWrapper(input: RequestInfo, init?: RequestInit): Promise<Response> {\n  const fetchOpts = {};\n  // Use the provided options in request options along with default or user provided values\n  Object.assign(fetchOpts, init, defaultFetchOpts);\n\n  const fetchResult = await fetch(input, fetchOpts);\n  return fetchResult;\n}\n\nexport type FetchFn = (url: string, init?: RequestInit) => Promise<Response>;\n\nexport interface RequestContext {\n  fetch: FetchFn;\n  url: string;\n  init: RequestInit;\n}\n\nexport interface ResponseContext {\n  fetch: FetchFn;\n  url: string;\n  init: RequestInit;\n  response: Response;\n}\n\nexport interface FetchParams {\n  url: string;\n  init: RequestInit;\n}\n\nexport interface FetchMiddleware {\n  pre?: (context: RequestContext) => PromiseLike<FetchParams | void> | FetchParams | void;\n  post?: (context: ResponseContext) => Promise<Response | void> | Response | void;\n}\nexport interface ApiKeyMiddlewareOpts {\n  /** The middleware / API key header will only be added to requests matching this host. */\n  host?: RegExp | string;\n  /** The http header name used for specifying the API key value. */\n  httpHeader?: string;\n  /** The API key string to specify as an http header value. */\n  apiKey: string;\n}\n\n/** @internal */\nexport function hostMatches(host: string, pattern: string | RegExp) {\n  if (typeof pattern === 'string') return pattern === host;\n  return (pattern as RegExp).exec(host);\n}\n\n/**\n * Creates a new middleware from an API key.\n * @example\n * ```\n * const apiMiddleware = createApiKeyMiddleware(\"example_e8e044a3_41d8b0fe_3dd3988ef302\");\n * const fetchFn = createFetchFn(apiMiddleware);\n * const network = new StacksMainnet({ fetchFn });\n * ```\n * @category Network\n * @related {@link createFetchFn}, {@link StacksNetwork}\n */\nexport function createApiKeyMiddleware({\n  apiKey,\n  host = /(.*)api(.*)\\.stacks\\.co$/i,\n  httpHeader = 'x-api-key',\n}: ApiKeyMiddlewareOpts): FetchMiddleware {\n  return {\n    pre: context => {\n      const reqUrl = new URL(context.url);\n      if (!hostMatches(reqUrl.host, host)) return; // Skip middleware if host does not match pattern\n\n      const headers = new Headers(context.init.headers);\n      headers.set(httpHeader, apiKey);\n      context.init.headers = headers;\n    },\n  };\n}\n\nfunction argsForCreateFetchFn(args: any[]): { fetchLib: FetchFn; middlewares: FetchMiddleware[] } {\n  let fetchLib: FetchFn = fetchWrapper;\n  let middlewares: FetchMiddleware[] = [];\n  if (args.length > 0 && typeof args[0] === 'function') {\n    fetchLib = args.shift();\n  }\n  if (args.length > 0) {\n    middlewares = args; // remaining args\n  }\n  return { fetchLib, middlewares };\n}\n\n/**\n * Creates a new network fetching function, which combines an optional fetch-compatible library with optional middlware.\n * @example\n * ```\n * const customFetch = createFetchFn(someMiddleware)\n * const customFetch = createFetchFn(fetch, someMiddleware)\n * const customFetch = createFetchFn(fetch, middlewareA, middlewareB)\n * ```\n * @category Network\n */\nexport function createFetchFn(fetchLib: FetchFn, ...middleware: FetchMiddleware[]): FetchFn;\nexport function createFetchFn(...middleware: FetchMiddleware[]): FetchFn;\nexport function createFetchFn(...args: any[]): FetchFn {\n  const { fetchLib, middlewares } = argsForCreateFetchFn(args);\n\n  const fetchFn = async (url: string, init?: RequestInit | undefined): Promise<Response> => {\n    let fetchParams = { url, init: init ?? {} };\n\n    for (const middleware of middlewares) {\n      if (typeof middleware.pre === 'function') {\n        const result = await Promise.resolve(\n          middleware.pre({\n            fetch: fetchLib,\n            ...fetchParams,\n          })\n        );\n        fetchParams = result ?? fetchParams;\n      }\n    }\n\n    let response = await fetchLib(fetchParams.url, fetchParams.init);\n\n    for (const middleware of middlewares) {\n      if (typeof middleware.post === 'function') {\n        const result = await Promise.resolve(\n          middleware.post({\n            fetch: fetchLib,\n            url: fetchParams.url,\n            init: fetchParams.init,\n            response: response?.clone() ?? response,\n          })\n        );\n        response = result ?? response;\n      }\n    }\n    return response;\n  };\n  return fetchFn;\n}\n"]},"metadata":{},"sourceType":"module"}