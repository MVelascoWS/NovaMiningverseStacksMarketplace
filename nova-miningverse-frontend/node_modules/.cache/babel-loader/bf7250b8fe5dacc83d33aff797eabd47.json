{"ast":null,"code":"import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { getPublicKey, getSharedSecret, Point, Signature, signSync, utils, verify } from '@noble/secp256k1';\nimport { Buffer, bytesToHex, concatBytes, FailedDecryptionError, hexToBigInt, hexToBytes, parseRecoverableSignatureVrs, signatureRsvToVrs, toBuffer } from '@stacks/common';\nimport { createCipher } from './aesCipher';\nimport { createHmacSha256 } from './hmacSha256';\nimport { getPublicKeyFromPrivate } from './keys';\nimport { hashMessage } from './messageSignature';\nimport { hashSha256Sync, hashSha512Sync } from './sha2Hash';\nimport { getAesCbcOutputLength, getBase64OutputLength } from './utils';\n\nutils.hmacSha256Sync = function (key) {\n  const h = hmac.create(sha256, key);\n\n  for (var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    msgs[_key - 1] = arguments[_key];\n  }\n\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\n\nexport var InvalidPublicKeyReason;\n\n(function (InvalidPublicKeyReason) {\n  InvalidPublicKeyReason[\"InvalidFormat\"] = \"InvalidFormat\";\n  InvalidPublicKeyReason[\"IsNotPoint\"] = \"IsNotPoint\";\n})(InvalidPublicKeyReason || (InvalidPublicKeyReason = {}));\n\nexport async function aes256CbcEncrypt(iv, key, plaintext) {\n  const cipher = await createCipher();\n  const result = await cipher.encrypt('aes-256-cbc', key, iv, plaintext);\n  return result;\n}\n\nasync function aes256CbcDecrypt(iv, key, ciphertext) {\n  const cipher = await createCipher();\n  const result = await cipher.decrypt('aes-256-cbc', key, iv, ciphertext);\n  return result;\n}\n\nasync function hmacSha256(key, content) {\n  const hmacSha256 = await createHmacSha256();\n  return hmacSha256.digest(key, content);\n}\n\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n\n  let res = 0;\n\n  for (let i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i];\n  }\n\n  return res === 0;\n}\n\nfunction sharedSecretToKeys(sharedSecret) {\n  const hashedSecret = hashSha512Sync(sharedSecret);\n  return {\n    encryptionKey: hashedSecret.slice(0, 32),\n    hmacKey: hashedSecret.slice(32)\n  };\n}\n\nfunction allHexChars(maybe) {\n  return maybe.match(/^[0-9a-f]+$/i) !== null;\n}\n\nfunction isValidPublicKey(pub) {\n  const invalidFormat = {\n    result: false,\n    reason_data: 'Invalid public key format',\n    reason: InvalidPublicKeyReason.InvalidFormat\n  };\n  const invalidPoint = {\n    result: false,\n    reason_data: 'Public key is not a point',\n    reason: InvalidPublicKeyReason.IsNotPoint\n  };\n  if (pub.length !== 66 && pub.length !== 130) return invalidFormat;\n  const firstByte = pub.slice(0, 2);\n  if (pub.length === 130 && firstByte !== '04') return invalidFormat;\n  if (pub.length === 66 && firstByte !== '02' && firstByte !== '03') return invalidFormat;\n  if (!allHexChars(pub)) return invalidFormat;\n\n  try {\n    const point = Point.fromHex(pub);\n    point.assertValidity();\n    return {\n      result: true,\n      reason_data: null,\n      reason: null\n    };\n  } catch (e) {\n    return invalidPoint;\n  }\n}\n\nexport function getHexFromBN(bnInput) {\n  const hexOut = bnInput.toString(16);\n\n  if (hexOut.length === 64) {\n    return hexOut;\n  } else if (hexOut.length < 64) {\n    const padding = '0'.repeat(64 - hexOut.length);\n    return `${padding}${hexOut}`;\n  } else {\n    throw new Error('Generated a > 32-byte BN for encryption. Failing.');\n  }\n}\nexport function getBufferFromBN(bnInput) {\n  const result = toBuffer(bnInput, 32);\n\n  if (result.byteLength !== 32) {\n    throw new Error('Failed to generate a 32-byte buffer instance');\n  }\n\n  return result;\n}\nexport function getCipherObjectWrapper(opts) {\n  const shell = {\n    iv: '',\n    ephemeralPK: '',\n    mac: '',\n    cipherText: '',\n    wasString: !!opts.wasString\n  };\n\n  if (opts.cipherTextEncoding === 'base64') {\n    shell.cipherTextEncoding = 'base64';\n  }\n\n  const ivLength = 32;\n  const ephemeralPKLength = 66;\n  const macLength = 64;\n  return {\n    payloadValuesLength: ivLength + ephemeralPKLength + macLength,\n    payloadShell: JSON.stringify(shell)\n  };\n}\nexport function getSignedCipherObjectWrapper(payloadShell) {\n  const shell = {\n    signature: '',\n    publicKey: '',\n    cipherText: payloadShell\n  };\n  const signatureLength = 144;\n  const publicKeyLength = 66;\n  return {\n    signedPayloadValuesLength: signatureLength + publicKeyLength,\n    signedPayloadShell: JSON.stringify(shell)\n  };\n}\nexport function eciesGetJsonStringLength(opts) {\n  const {\n    payloadShell,\n    payloadValuesLength\n  } = getCipherObjectWrapper(opts);\n  const cipherTextLength = getAesCbcOutputLength(opts.contentLength);\n  let encodedCipherTextLength;\n\n  if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {\n    encodedCipherTextLength = cipherTextLength * 2;\n  } else if (opts.cipherTextEncoding === 'base64') {\n    encodedCipherTextLength = getBase64OutputLength(cipherTextLength);\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${opts.cipherTextEncoding}\"`);\n  }\n\n  if (!opts.sign) {\n    return payloadShell.length + payloadValuesLength + encodedCipherTextLength;\n  } else {\n    const {\n      signedPayloadShell,\n      signedPayloadValuesLength\n    } = getSignedCipherObjectWrapper(payloadShell);\n    return signedPayloadShell.length + signedPayloadValuesLength + payloadValuesLength + encodedCipherTextLength;\n  }\n}\nexport async function encryptECIES(publicKey, content, wasString, cipherTextEncoding) {\n  const validity = isValidPublicKey(publicKey);\n\n  if (!validity.result) {\n    throw validity;\n  }\n\n  const ephemeralPrivateKey = utils.randomPrivateKey();\n  const ephemeralPublicKey = getPublicKey(ephemeralPrivateKey, true);\n  let sharedSecret = getSharedSecret(ephemeralPrivateKey, publicKey, true);\n  sharedSecret = sharedSecret.slice(1);\n  const sharedKeys = sharedSecretToKeys(Buffer.from(sharedSecret));\n  const initializationVector = utils.randomBytes(16);\n  const cipherText = await aes256CbcEncrypt(Buffer.from(initializationVector), sharedKeys.encryptionKey, content);\n  const macData = concatBytes(initializationVector, ephemeralPublicKey, cipherText);\n  const mac = await hmacSha256(sharedKeys.hmacKey, Buffer.from(macData));\n  let cipherTextString;\n\n  if (!cipherTextEncoding || cipherTextEncoding === 'hex') {\n    cipherTextString = bytesToHex(cipherText);\n  } else if (cipherTextEncoding === 'base64') {\n    cipherTextString = cipherText.toString('base64');\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${cipherTextEncoding}\"`);\n  }\n\n  const result = {\n    iv: bytesToHex(initializationVector),\n    ephemeralPK: bytesToHex(ephemeralPublicKey),\n    cipherText: cipherTextString,\n    mac: bytesToHex(mac),\n    wasString\n  };\n\n  if (cipherTextEncoding && cipherTextEncoding !== 'hex') {\n    result.cipherTextEncoding = cipherTextEncoding;\n  }\n\n  return result;\n}\nexport async function decryptECIES(privateKey, cipherObject) {\n  if (!cipherObject.ephemeralPK) {\n    throw new FailedDecryptionError('Unable to get public key from cipher object. ' + 'You might be trying to decrypt an unencrypted object.');\n  }\n\n  const ephemeralPK = cipherObject.ephemeralPK;\n  let sharedSecret = getSharedSecret(privateKey, ephemeralPK, true);\n  sharedSecret = sharedSecret.slice(1);\n  const sharedKeys = sharedSecretToKeys(Buffer.from(sharedSecret));\n  const ivBuffer = hexToBytes(cipherObject.iv);\n  let cipherTextBuffer;\n\n  if (!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex') {\n    cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'hex');\n  } else if (cipherObject.cipherTextEncoding === 'base64') {\n    cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'base64');\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${cipherObject.cipherText}\"`);\n  }\n\n  const macData = concatBytes(ivBuffer, hexToBytes(ephemeralPK), cipherTextBuffer);\n  const actualMac = await hmacSha256(sharedKeys.hmacKey, Buffer.from(macData));\n  const expectedMac = hexToBytes(cipherObject.mac);\n\n  if (!equalConstTime(Buffer.from(expectedMac), actualMac)) {\n    throw new FailedDecryptionError('Decryption failed: failure in MAC check');\n  }\n\n  const plainText = await aes256CbcDecrypt(Buffer.from(ivBuffer), sharedKeys.encryptionKey, cipherTextBuffer);\n\n  if (cipherObject.wasString) {\n    return plainText.toString();\n  } else {\n    return plainText;\n  }\n}\nexport function signECDSA(privateKey, content) {\n  const contentBuffer = content instanceof Buffer ? content : Buffer.from(content);\n  const publicKey = getPublicKeyFromPrivate(privateKey);\n  const contentHash = hashSha256Sync(contentBuffer);\n  const signature = signSync(contentHash, privateKey);\n  return {\n    signature: bytesToHex(signature),\n    publicKey\n  };\n}\n\nfunction getBuffer(content) {\n  if (content instanceof Buffer) return content;else if (content instanceof ArrayBuffer) return Buffer.from(content);else return Buffer.from(content);\n}\n\nexport function verifyECDSA(content, publicKey, signature) {\n  const contentBuffer = getBuffer(content);\n  const contentHash = hashSha256Sync(contentBuffer);\n  return verify(signature, contentHash, publicKey, {\n    strict: false\n  });\n}\nexport function verifyMessageSignature(_ref) {\n  let {\n    signature,\n    message,\n    publicKey\n  } = _ref;\n  const {\n    r,\n    s\n  } = parseRecoverableSignatureVrs(signature);\n  const sig = new Signature(hexToBigInt(r), hexToBigInt(s));\n  const hashedMsg = typeof message === 'string' ? hashMessage(message) : message;\n  return verify(sig, hashedMsg, publicKey, {\n    strict: false\n  });\n}\nexport function verifyMessageSignatureRsv(_ref2) {\n  let {\n    signature,\n    message,\n    publicKey\n  } = _ref2;\n  return verifyMessageSignature({\n    signature: signatureRsvToVrs(signature),\n    message,\n    publicKey\n  });\n}","map":{"version":3,"mappings":"AAAA,SAASA,IAAT,QAAqB,oBAArB;AACA,SAASC,MAAT,QAAuB,sBAAvB;AACA,SACEC,YADF,EAEEC,eAFF,EAGEC,KAHF,EAIEC,SAJF,EAKEC,QALF,EAMEC,KANF,EAOEC,MAPF,QAQO,kBARP;AASA,SACEC,MADF,EAEEC,UAFF,EAGEC,WAHF,EAIEC,qBAJF,EAKEC,WALF,EAMEC,UANF,EAOEC,4BAPF,EAQEC,iBARF,EASEC,QATF,QAUO,gBAVP;AAWA,SAASC,YAAT,QAA6B,aAA7B;AACA,SAASC,gBAAT,QAAiC,cAAjC;AACA,SAASC,uBAAT,QAAwC,QAAxC;AACA,SAASC,WAAT,QAA4B,oBAA5B;AACA,SAASC,cAAT,EAAyBC,cAAzB,QAA+C,YAA/C;AACA,SAASC,qBAAT,EAAgCC,qBAAhC,QAA6D,SAA7D;;AASAlB,KAAK,CAACmB,cAAN,GAAuB,UAACC,GAAD,EAA2C;EAChE,MAAMC,CAAC,GAAG5B,IAAI,CAAC6B,MAAL,CAAY5B,MAAZ,EAAoB0B,GAApB,CAAV;;EADgE,kCAAtBG,IAAsB;IAAtBA,IAAsB;EAAA;;EAEhEA,IAAI,CAACC,OAAL,CAAaC,GAAG,IAAIJ,CAAC,CAACK,MAAF,CAASD,GAAT,CAApB;EACA,OAAOJ,CAAC,CAACM,MAAF,EAAP;AACD,CAJD;;AA2CA,WAAYC,sBAAZ;;AAAA,WAAYA,sBAAZ,EAAkC;EAChCA;EACAA;AACD,CAHD,EAAYA,sBAAsB,KAAtBA,sBAAsB,MAAlC;;AAQA,OAAO,eAAeC,gBAAf,CACLC,EADK,EAELV,GAFK,EAGLW,SAHK,EAGY;EAEjB,MAAMC,MAAM,GAAG,MAAMrB,YAAY,EAAjC;EACA,MAAMsB,MAAM,GAAG,MAAMD,MAAM,CAACE,OAAP,CAAe,aAAf,EAA8Bd,GAA9B,EAAmCU,EAAnC,EAAuCC,SAAvC,CAArB;EACA,OAAOE,MAAP;AACD;;AAKD,eAAeE,gBAAf,CAAgCL,EAAhC,EAA4CV,GAA5C,EAAyDgB,UAAzD,EAA2E;EACzE,MAAMJ,MAAM,GAAG,MAAMrB,YAAY,EAAjC;EACA,MAAMsB,MAAM,GAAG,MAAMD,MAAM,CAACK,OAAP,CAAe,aAAf,EAA8BjB,GAA9B,EAAmCU,EAAnC,EAAuCM,UAAvC,CAArB;EACA,OAAOH,MAAP;AACD;;AAKD,eAAeK,UAAf,CAA0BlB,GAA1B,EAAuCmB,OAAvC,EAAsD;EACpD,MAAMD,UAAU,GAAG,MAAM1B,gBAAgB,EAAzC;EACA,OAAO0B,UAAU,CAACX,MAAX,CAAkBP,GAAlB,EAAuBmB,OAAvB,CAAP;AACD;;AAKD,SAASC,cAAT,CAAwBC,EAAxB,EAAoCC,EAApC,EAA8C;EAC5C,IAAID,EAAE,CAACE,MAAH,KAAcD,EAAE,CAACC,MAArB,EAA6B;IAC3B,OAAO,KAAP;EACD;;EACD,IAAIC,GAAG,GAAG,CAAV;;EACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,EAAE,CAACE,MAAvB,EAA+BE,CAAC,EAAhC,EAAoC;IAClCD,GAAG,IAAIH,EAAE,CAACI,CAAD,CAAF,GAAQH,EAAE,CAACG,CAAD,CAAjB;EACD;;EACD,OAAOD,GAAG,KAAK,CAAf;AACD;;AAKD,SAASE,kBAAT,CAA4BC,YAA5B,EAAgD;EAE9C,MAAMC,YAAY,GAAGhC,cAAc,CAAC+B,YAAD,CAAnC;EACA,OAAO;IACLE,aAAa,EAAED,YAAY,CAACE,KAAb,CAAmB,CAAnB,EAAsB,EAAtB,CADV;IAELC,OAAO,EAAEH,YAAY,CAACE,KAAb,CAAmB,EAAnB;EAFJ,CAAP;AAID;;AAKD,SAASE,WAAT,CAAqBC,KAArB,EAAkC;EAChC,OAAOA,KAAK,CAACC,KAAN,CAAY,cAAZ,MAAgC,IAAvC;AACD;;AAKD,SAASC,gBAAT,CAA0BC,GAA1B,EAAqC;EAKnC,MAAMC,aAAa,GAAG;IACpBxB,MAAM,EAAE,KADY;IAEpByB,WAAW,EAAE,2BAFO;IAGpBC,MAAM,EAAE/B,sBAAsB,CAACgC;EAHX,CAAtB;EAKA,MAAMC,YAAY,GAAG;IACnB5B,MAAM,EAAE,KADW;IAEnByB,WAAW,EAAE,2BAFM;IAGnBC,MAAM,EAAE/B,sBAAsB,CAACkC;EAHZ,CAArB;EAKA,IAAIN,GAAG,CAACb,MAAJ,KAAe,EAAf,IAAqBa,GAAG,CAACb,MAAJ,KAAe,GAAxC,EAA6C,OAAOc,aAAP;EAE7C,MAAMM,SAAS,GAAGP,GAAG,CAACN,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAlB;EAGA,IAAIM,GAAG,CAACb,MAAJ,KAAe,GAAf,IAAsBoB,SAAS,KAAK,IAAxC,EAA8C,OAAON,aAAP;EAG9C,IAAID,GAAG,CAACb,MAAJ,KAAe,EAAf,IAAqBoB,SAAS,KAAK,IAAnC,IAA2CA,SAAS,KAAK,IAA7D,EAAmE,OAAON,aAAP;EAEnE,IAAI,CAACL,WAAW,CAACI,GAAD,CAAhB,EAAuB,OAAOC,aAAP;;EAEvB,IAAI;IAEF,MAAMO,KAAK,GAAGnE,KAAK,CAACoE,OAAN,CAAcT,GAAd,CAAd;IAKAQ,KAAK,CAACE,cAAN;IAGA,OAAO;MACLjC,MAAM,EAAE,IADH;MAELyB,WAAW,EAAE,IAFR;MAGLC,MAAM,EAAE;IAHH,CAAP;EAKD,CAfD,CAeE,OAAOQ,CAAP,EAAU;IACV,OAAON,YAAP;EACD;AACF;;AAOD,OAAM,SAAUO,YAAV,CAAuBC,OAAvB,EAAsC;EAC1C,MAAMC,MAAM,GAAGD,OAAO,CAACE,QAAR,CAAiB,EAAjB,CAAf;;EACA,IAAID,MAAM,CAAC3B,MAAP,KAAkB,EAAtB,EAA0B;IACxB,OAAO2B,MAAP;EACD,CAFD,MAEO,IAAIA,MAAM,CAAC3B,MAAP,GAAgB,EAApB,EAAwB;IAG7B,MAAM6B,OAAO,GAAG,IAAIC,MAAJ,CAAW,KAAKH,MAAM,CAAC3B,MAAvB,CAAhB;IACA,OAAO,GAAG6B,OAAO,GAAGF,MAAM,EAA1B;EACD,CALM,MAKA;IACL,MAAM,IAAII,KAAJ,CAAU,mDAAV,CAAN;EACD;AACF;AAOD,OAAM,SAAUC,eAAV,CAA0BN,OAA1B,EAAyC;EAC7C,MAAMpC,MAAM,GAAGvB,QAAQ,CAAC2D,OAAD,EAAU,EAAV,CAAvB;;EACA,IAAIpC,MAAM,CAAC2C,UAAP,KAAsB,EAA1B,EAA8B;IAC5B,MAAM,IAAIF,KAAJ,CAAU,8CAAV,CAAN;EACD;;EACD,OAAOzC,MAAP;AACD;AAMD,OAAM,SAAU4C,sBAAV,CAAiCC,IAAjC,EAGL;EAQC,MAAMC,KAAK,GAAiB;IAC1BjD,EAAE,EAAE,EADsB;IAE1BkD,WAAW,EAAE,EAFa;IAG1BC,GAAG,EAAE,EAHqB;IAI1BC,UAAU,EAAE,EAJc;IAK1BC,SAAS,EAAE,CAAC,CAACL,IAAI,CAACK;EALQ,CAA5B;;EAOA,IAAIL,IAAI,CAACM,kBAAL,KAA4B,QAAhC,EAA0C;IACxCL,KAAK,CAACK,kBAAN,GAA2B,QAA3B;EACD;;EAED,MAAMC,QAAQ,GAAG,EAAjB;EAEA,MAAMC,iBAAiB,GAAG,EAA1B;EAEA,MAAMC,SAAS,GAAG,EAAlB;EACA,OAAO;IACLC,mBAAmB,EAAEH,QAAQ,GAAGC,iBAAX,GAA+BC,SAD/C;IAELE,YAAY,EAAEC,IAAI,CAACC,SAAL,CAAeZ,KAAf;EAFT,CAAP;AAID;AAOD,OAAM,SAAUa,4BAAV,CAAuCH,YAAvC,EAA2D;EAS/D,MAAMV,KAAK,GAAuB;IAChCc,SAAS,EAAE,EADqB;IAEhCC,SAAS,EAAE,EAFqB;IAGhCZ,UAAU,EAAEO;EAHoB,CAAlC;EAMA,MAAMM,eAAe,GAAG,GAAxB;EAEA,MAAMC,eAAe,GAAG,EAAxB;EACA,OAAO;IACLC,yBAAyB,EAAEF,eAAe,GAAGC,eADxC;IAELE,kBAAkB,EAAER,IAAI,CAACC,SAAL,CAAeZ,KAAf;EAFf,CAAP;AAID;AAOD,OAAM,SAAUoB,wBAAV,CAAmCrB,IAAnC,EAKL;EACC,MAAM;IAAEW,YAAF;IAAgBD;EAAhB,IAAwCX,sBAAsB,CAACC,IAAD,CAApE;EAGA,MAAMsB,gBAAgB,GAAGnF,qBAAqB,CAAC6D,IAAI,CAACuB,aAAN,CAA9C;EAGA,IAAIC,uBAAJ;;EACA,IAAI,CAACxB,IAAI,CAACM,kBAAN,IAA4BN,IAAI,CAACM,kBAAL,KAA4B,KAA5D,EAAmE;IACjEkB,uBAAuB,GAAGF,gBAAgB,GAAG,CAA7C;EACD,CAFD,MAEO,IAAItB,IAAI,CAACM,kBAAL,KAA4B,QAAhC,EAA0C;IAC/CkB,uBAAuB,GAAGpF,qBAAqB,CAACkF,gBAAD,CAA/C;EACD,CAFM,MAEA;IACL,MAAM,IAAI1B,KAAJ,CAAU,kCAAkCI,IAAI,CAACM,kBAAkB,GAAnE,CAAN;EACD;;EAED,IAAI,CAACN,IAAI,CAACyB,IAAV,EAAgB;IAEd,OAAOd,YAAY,CAAC9C,MAAb,GAAsB6C,mBAAtB,GAA4Cc,uBAAnD;EACD,CAHD,MAGO;IAEL,MAAM;MAAEJ,kBAAF;MAAsBD;IAAtB,IACJL,4BAA4B,CAACH,YAAD,CAD9B;IAGA,OACES,kBAAkB,CAACvD,MAAnB,GACAsD,yBADA,GAEAT,mBAFA,GAGAc,uBAJF;EAMD;AACF;AAeD,OAAO,eAAeE,YAAf,CACLV,SADK,EAELvD,OAFK,EAGL4C,SAHK,EAILC,kBAJK,EAIkC;EAEvC,MAAMqB,QAAQ,GAAGlD,gBAAgB,CAACuC,SAAD,CAAjC;;EACA,IAAI,CAACW,QAAQ,CAACxE,MAAd,EAAsB;IACpB,MAAMwE,QAAN;EACD;;EACD,MAAMC,mBAAmB,GAAG1G,KAAK,CAAC2G,gBAAN,EAA5B;EACA,MAAMC,kBAAkB,GAAGjH,YAAY,CAAC+G,mBAAD,EAAsB,IAAtB,CAAvC;EACA,IAAI3D,YAAY,GAAGnD,eAAe,CAAC8G,mBAAD,EAAsBZ,SAAtB,EAAiC,IAAjC,CAAlC;EAEA/C,YAAY,GAAGA,YAAY,CAACG,KAAb,CAAmB,CAAnB,CAAf;EACA,MAAM2D,UAAU,GAAG/D,kBAAkB,CAAC5C,MAAM,CAAC4G,IAAP,CAAY/D,YAAZ,CAAD,CAArC;EACA,MAAMgE,oBAAoB,GAAG/G,KAAK,CAACgH,WAAN,CAAkB,EAAlB,CAA7B;EAEA,MAAM9B,UAAU,GAAG,MAAMrD,gBAAgB,CACvC3B,MAAM,CAAC4G,IAAP,CAAYC,oBAAZ,CADuC,EAEvCF,UAAU,CAAC5D,aAF4B,EAGvCV,OAHuC,CAAzC;EAMA,MAAM0E,OAAO,GAAG7G,WAAW,CAAC2G,oBAAD,EAAuBH,kBAAvB,EAA2C1B,UAA3C,CAA3B;EACA,MAAMD,GAAG,GAAG,MAAM3C,UAAU,CAACuE,UAAU,CAAC1D,OAAZ,EAAqBjD,MAAM,CAAC4G,IAAP,CAAYG,OAAZ,CAArB,CAA5B;EAEA,IAAIC,gBAAJ;;EAEA,IAAI,CAAC9B,kBAAD,IAAuBA,kBAAkB,KAAK,KAAlD,EAAyD;IACvD8B,gBAAgB,GAAG/G,UAAU,CAAC+E,UAAD,CAA7B;EACD,CAFD,MAEO,IAAIE,kBAAkB,KAAK,QAA3B,EAAqC;IAC1C8B,gBAAgB,GAAGhC,UAAU,CAACX,QAAX,CAAoB,QAApB,CAAnB;EACD,CAFM,MAEA;IACL,MAAM,IAAIG,KAAJ,CAAU,kCAAkCU,kBAAkB,GAA9D,CAAN;EACD;;EAED,MAAMnD,MAAM,GAAiB;IAC3BH,EAAE,EAAE3B,UAAU,CAAC4G,oBAAD,CADa;IAE3B/B,WAAW,EAAE7E,UAAU,CAACyG,kBAAD,CAFI;IAG3B1B,UAAU,EAAEgC,gBAHe;IAI3BjC,GAAG,EAAE9E,UAAU,CAAC8E,GAAD,CAJY;IAK3BE;EAL2B,CAA7B;;EAOA,IAAIC,kBAAkB,IAAIA,kBAAkB,KAAK,KAAjD,EAAwD;IACtDnD,MAAM,CAACmD,kBAAP,GAA4BA,kBAA5B;EACD;;EACD,OAAOnD,MAAP;AACD;AAcD,OAAO,eAAekF,YAAf,CACLC,UADK,EAELC,YAFK,EAEqB;EAE1B,IAAI,CAACA,YAAY,CAACrC,WAAlB,EAA+B;IAC7B,MAAM,IAAI3E,qBAAJ,CACJ,kDACE,uDAFE,CAAN;EAID;;EACD,MAAM2E,WAAW,GAAGqC,YAAY,CAACrC,WAAjC;EACA,IAAIjC,YAAY,GAAGnD,eAAe,CAACwH,UAAD,EAAapC,WAAb,EAA0B,IAA1B,CAAlC;EAEAjC,YAAY,GAAGA,YAAY,CAACG,KAAb,CAAmB,CAAnB,CAAf;EACA,MAAM2D,UAAU,GAAG/D,kBAAkB,CAAC5C,MAAM,CAAC4G,IAAP,CAAY/D,YAAZ,CAAD,CAArC;EACA,MAAMuE,QAAQ,GAAG/G,UAAU,CAAC8G,YAAY,CAACvF,EAAd,CAA3B;EAEA,IAAIyF,gBAAJ;;EAEA,IAAI,CAACF,YAAY,CAACjC,kBAAd,IAAoCiC,YAAY,CAACjC,kBAAb,KAAoC,KAA5E,EAAmF;IACjFmC,gBAAgB,GAAGrH,MAAM,CAAC4G,IAAP,CAAYO,YAAY,CAACnC,UAAzB,EAAqC,KAArC,CAAnB;EACD,CAFD,MAEO,IAAImC,YAAY,CAACjC,kBAAb,KAAoC,QAAxC,EAAkD;IACvDmC,gBAAgB,GAAGrH,MAAM,CAAC4G,IAAP,CAAYO,YAAY,CAACnC,UAAzB,EAAqC,QAArC,CAAnB;EACD,CAFM,MAEA;IACL,MAAM,IAAIR,KAAJ,CAAU,kCAAkC2C,YAAY,CAACnC,UAAU,GAAnE,CAAN;EACD;;EAED,MAAM+B,OAAO,GAAG7G,WAAW,CAACkH,QAAD,EAAW/G,UAAU,CAACyE,WAAD,CAArB,EAAoCuC,gBAApC,CAA3B;EACA,MAAMC,SAAS,GAAG,MAAMlF,UAAU,CAACuE,UAAU,CAAC1D,OAAZ,EAAqBjD,MAAM,CAAC4G,IAAP,CAAYG,OAAZ,CAArB,CAAlC;EACA,MAAMQ,WAAW,GAAGlH,UAAU,CAAC8G,YAAY,CAACpC,GAAd,CAA9B;;EAEA,IAAI,CAACzC,cAAc,CAACtC,MAAM,CAAC4G,IAAP,CAAYW,WAAZ,CAAD,EAA2BD,SAA3B,CAAnB,EAA0D;IACxD,MAAM,IAAInH,qBAAJ,CAA0B,yCAA1B,CAAN;EACD;;EACD,MAAMqH,SAAS,GAAG,MAAMvF,gBAAgB,CACtCjC,MAAM,CAAC4G,IAAP,CAAYQ,QAAZ,CADsC,EAEtCT,UAAU,CAAC5D,aAF2B,EAGtCsE,gBAHsC,CAAxC;;EAMA,IAAIF,YAAY,CAAClC,SAAjB,EAA4B;IAC1B,OAAOuC,SAAS,CAACnD,QAAV,EAAP;EACD,CAFD,MAEO;IACL,OAAOmD,SAAP;EACD;AACF;AAaD,OAAM,SAAUC,SAAV,CACJP,UADI,EAEJ7E,OAFI,EAEoB;EAKxB,MAAMqF,aAAa,GAAGrF,OAAO,YAAYrC,MAAnB,GAA4BqC,OAA5B,GAAsCrC,MAAM,CAAC4G,IAAP,CAAYvE,OAAZ,CAA5D;EACA,MAAMuD,SAAS,GAAGjF,uBAAuB,CAACuG,UAAD,CAAzC;EACA,MAAMS,WAAW,GAAG9G,cAAc,CAAC6G,aAAD,CAAlC;EACA,MAAM/B,SAAS,GAAG9F,QAAQ,CAAC8H,WAAD,EAAcT,UAAd,CAA1B;EAEA,OAAO;IACLvB,SAAS,EAAE1F,UAAU,CAAC0F,SAAD,CADhB;IAELC;EAFK,CAAP;AAID;;AAKD,SAASgC,SAAT,CAAmBvF,OAAnB,EAAyD;EACvD,IAAIA,OAAO,YAAYrC,MAAvB,EAA+B,OAAOqC,OAAP,CAA/B,KACK,IAAIA,OAAO,YAAYwF,WAAvB,EAAoC,OAAO7H,MAAM,CAAC4G,IAAP,CAAYvE,OAAZ,CAAP,CAApC,KACA,OAAOrC,MAAM,CAAC4G,IAAP,CAAYvE,OAAZ,CAAP;AACN;;AAWD,OAAM,SAAUyF,WAAV,CACJzF,OADI,EAEJuD,SAFI,EAGJD,SAHI,EAGa;EAEjB,MAAM+B,aAAa,GAAGE,SAAS,CAACvF,OAAD,CAA/B;EACA,MAAMsF,WAAW,GAAG9G,cAAc,CAAC6G,aAAD,CAAlC;EAIA,OAAO3H,MAAM,CAAC4F,SAAD,EAAYgC,WAAZ,EAAyB/B,SAAzB,EAAoC;IAAEmC,MAAM,EAAE;EAAV,CAApC,CAAb;AACD;AAYD,OAAM,SAAUC,sBAAV,OAIuB;EAAA,IAJU;IACrCrC,SADqC;IAErCsC,OAFqC;IAGrCrC;EAHqC,CAIV;EAE3B,MAAM;IAAEsC,CAAF;IAAKC;EAAL,IAAW7H,4BAA4B,CAACqF,SAAD,CAA7C;EACA,MAAMyC,GAAG,GAAG,IAAIxI,SAAJ,CAAcQ,WAAW,CAAC8H,CAAD,CAAzB,EAA8B9H,WAAW,CAAC+H,CAAD,CAAzC,CAAZ;EACA,MAAME,SAAS,GAAG,OAAOJ,OAAP,KAAmB,QAAnB,GAA8BrH,WAAW,CAACqH,OAAD,CAAzC,GAAqDA,OAAvE;EAIA,OAAOlI,MAAM,CAACqI,GAAD,EAAMC,SAAN,EAAiBzC,SAAjB,EAA4B;IAAEmC,MAAM,EAAE;EAAV,CAA5B,CAAb;AACD;AAMD,OAAM,SAAUO,yBAAV,QAIuB;EAAA,IAJa;IACxC3C,SADwC;IAExCsC,OAFwC;IAGxCrC;EAHwC,CAIb;EAC3B,OAAOoC,sBAAsB,CAAC;IAC5BrC,SAAS,EAAEpF,iBAAiB,CAACoF,SAAD,CADA;IAE5BsC,OAF4B;IAG5BrC;EAH4B,CAAD,CAA7B;AAKD","names":["hmac","sha256","getPublicKey","getSharedSecret","Point","Signature","signSync","utils","verify","Buffer","bytesToHex","concatBytes","FailedDecryptionError","hexToBigInt","hexToBytes","parseRecoverableSignatureVrs","signatureRsvToVrs","toBuffer","createCipher","createHmacSha256","getPublicKeyFromPrivate","hashMessage","hashSha256Sync","hashSha512Sync","getAesCbcOutputLength","getBase64OutputLength","hmacSha256Sync","key","h","create","msgs","forEach","msg","update","digest","InvalidPublicKeyReason","aes256CbcEncrypt","iv","plaintext","cipher","result","encrypt","aes256CbcDecrypt","ciphertext","decrypt","hmacSha256","content","equalConstTime","b1","b2","length","res","i","sharedSecretToKeys","sharedSecret","hashedSecret","encryptionKey","slice","hmacKey","allHexChars","maybe","match","isValidPublicKey","pub","invalidFormat","reason_data","reason","InvalidFormat","invalidPoint","IsNotPoint","firstByte","point","fromHex","assertValidity","e","getHexFromBN","bnInput","hexOut","toString","padding","repeat","Error","getBufferFromBN","byteLength","getCipherObjectWrapper","opts","shell","ephemeralPK","mac","cipherText","wasString","cipherTextEncoding","ivLength","ephemeralPKLength","macLength","payloadValuesLength","payloadShell","JSON","stringify","getSignedCipherObjectWrapper","signature","publicKey","signatureLength","publicKeyLength","signedPayloadValuesLength","signedPayloadShell","eciesGetJsonStringLength","cipherTextLength","contentLength","encodedCipherTextLength","sign","encryptECIES","validity","ephemeralPrivateKey","randomPrivateKey","ephemeralPublicKey","sharedKeys","from","initializationVector","randomBytes","macData","cipherTextString","decryptECIES","privateKey","cipherObject","ivBuffer","cipherTextBuffer","actualMac","expectedMac","plainText","signECDSA","contentBuffer","contentHash","getBuffer","ArrayBuffer","verifyECDSA","strict","verifyMessageSignature","message","r","s","sig","hashedMsg","verifyMessageSignatureRsv"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\encryption\\src\\ec.ts"],"sourcesContent":["import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport {\n  getPublicKey,\n  getSharedSecret,\n  Point,\n  Signature,\n  signSync,\n  utils,\n  verify,\n} from '@noble/secp256k1';\nimport {\n  Buffer,\n  bytesToHex,\n  concatBytes,\n  FailedDecryptionError,\n  hexToBigInt,\n  hexToBytes,\n  parseRecoverableSignatureVrs,\n  signatureRsvToVrs,\n  toBuffer,\n} from '@stacks/common';\nimport { createCipher } from './aesCipher';\nimport { createHmacSha256 } from './hmacSha256';\nimport { getPublicKeyFromPrivate } from './keys';\nimport { hashMessage } from './messageSignature';\nimport { hashSha256Sync, hashSha512Sync } from './sha2Hash';\nimport { getAesCbcOutputLength, getBase64OutputLength } from './utils';\n\n/**\n * To use secp256k1.signSync set utils.hmacSha256Sync to a function using noble-hashes\n * secp256k1.signSync is the counter part of secp256k1.sign (async version)\n * secp256k1.signSync is used within signECDSA in this file\n * secp256k1.signSync is used to maintain the semantics of signECDSA while migrating from elliptic lib\n * utils.hmacSha256Sync docs: https://github.com/paulmillr/noble-secp256k1 readme file\n */\nutils.hmacSha256Sync = (key: Uint8Array, ...msgs: Uint8Array[]) => {\n  const h = hmac.create(sha256, key);\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\n\n/**\n * Controls how the encrypted data buffer will be encoded as a string in the JSON payload.\n * Options:\n *    `hex` -- the legacy default, file size increase 100% (2x).\n *    `base64` -- file size increased ~33%.\n * @ignore\n */\nexport type CipherTextEncoding = 'hex' | 'base64';\n\n/**\n * @ignore\n */\nexport type CipherObject = {\n  iv: string;\n  ephemeralPK: string;\n  cipherText: string;\n  /** If undefined then hex encoding is used for the `cipherText` string. */\n  cipherTextEncoding?: CipherTextEncoding;\n  mac: string;\n  wasString: boolean;\n};\n\n/**\n * @ignore\n */\nexport type SignedCipherObject = {\n  /** Hex encoded DER signature (up to 144 chars) */\n  signature: string;\n  /** Hex encoded public key (66 char length) */\n  publicKey: string;\n  /** The stringified json of a `CipherObject` */\n  cipherText: string;\n};\n\n/**\n * @ignore\n */\nexport enum InvalidPublicKeyReason {\n  InvalidFormat = 'InvalidFormat',\n  IsNotPoint = 'IsNotPoint',\n}\n\n/**\n * @ignore\n */\nexport async function aes256CbcEncrypt(\n  iv: Buffer,\n  key: Buffer,\n  plaintext: Buffer\n): Promise<Buffer> {\n  const cipher = await createCipher();\n  const result = await cipher.encrypt('aes-256-cbc', key, iv, plaintext);\n  return result;\n}\n\n/**\n * @ignore\n */\nasync function aes256CbcDecrypt(iv: Buffer, key: Buffer, ciphertext: Buffer): Promise<Buffer> {\n  const cipher = await createCipher();\n  const result = await cipher.decrypt('aes-256-cbc', key, iv, ciphertext);\n  return result;\n}\n\n/**\n * @ignore\n */\nasync function hmacSha256(key: Buffer, content: Buffer) {\n  const hmacSha256 = await createHmacSha256();\n  return hmacSha256.digest(key, content);\n}\n\n/**\n * @ignore\n */\nfunction equalConstTime(b1: Buffer, b2: Buffer) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  let res = 0;\n  for (let i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n  return res === 0;\n}\n\n/**\n * @ignore\n */\nfunction sharedSecretToKeys(sharedSecret: Buffer): { encryptionKey: Buffer; hmacKey: Buffer } {\n  // generate mac and encryption key from shared secret\n  const hashedSecret = hashSha512Sync(sharedSecret);\n  return {\n    encryptionKey: hashedSecret.slice(0, 32),\n    hmacKey: hashedSecret.slice(32),\n  };\n}\n\n/**\n * @ignore\n */\nfunction allHexChars(maybe: string): boolean {\n  return maybe.match(/^[0-9a-f]+$/i) !== null;\n}\n\n/**\n * @ignore\n */\nfunction isValidPublicKey(pub: string): {\n  result: boolean;\n  reason: string | null;\n  reason_data: string | null;\n} {\n  const invalidFormat = {\n    result: false,\n    reason_data: 'Invalid public key format',\n    reason: InvalidPublicKeyReason.InvalidFormat,\n  };\n  const invalidPoint = {\n    result: false,\n    reason_data: 'Public key is not a point',\n    reason: InvalidPublicKeyReason.IsNotPoint,\n  };\n  if (pub.length !== 66 && pub.length !== 130) return invalidFormat;\n\n  const firstByte = pub.slice(0, 2);\n\n  // uncompressed public key\n  if (pub.length === 130 && firstByte !== '04') return invalidFormat;\n\n  // compressed public key\n  if (pub.length === 66 && firstByte !== '02' && firstByte !== '03') return invalidFormat;\n\n  if (!allHexChars(pub)) return invalidFormat;\n\n  try {\n    // Converts public key to Point\n    const point = Point.fromHex(pub);\n\n    // Verify point on curve is valid if it conforms to equation\n    // Validate the public key\n    // Throws: Point is not on elliptic curve if point is not on curve\n    point.assertValidity();\n\n    // Validation passed\n    return {\n      result: true,\n      reason_data: null,\n      reason: null,\n    };\n  } catch (e) {\n    return invalidPoint;\n  }\n}\n\n/**\n * Hex encodes a 32-byte bigint instance.\n * The result string is zero padded and always 64 characters in length.\n * @ignore\n */\nexport function getHexFromBN(bnInput: bigint): string {\n  const hexOut = bnInput.toString(16);\n  if (hexOut.length === 64) {\n    return hexOut;\n  } else if (hexOut.length < 64) {\n    // pad with leading zeros\n    // the padStart function would require node 9\n    const padding = '0'.repeat(64 - hexOut.length);\n    return `${padding}${hexOut}`;\n  } else {\n    throw new Error('Generated a > 32-byte BN for encryption. Failing.');\n  }\n}\n\n/**\n * Returns a big-endian encoded 32-byte buffer instance.\n * The result Buffer is zero padded and always 32 bytes in length.\n * @ignore\n */\nexport function getBufferFromBN(bnInput: bigint): Buffer {\n  const result = toBuffer(bnInput, 32);\n  if (result.byteLength !== 32) {\n    throw new Error('Failed to generate a 32-byte buffer instance');\n  }\n  return result;\n}\n\n/**\n * Get details about the JSON envelope size overhead for ciphertext payloads.\n * @ignore\n */\nexport function getCipherObjectWrapper(opts: {\n  wasString: boolean;\n  cipherTextEncoding: CipherTextEncoding;\n}): {\n  /** The stringified JSON string of an empty `CipherObject`. */\n  payloadShell: string;\n  /** Total string length of all the `CipherObject` values that always have constant lengths. */\n  payloadValuesLength: number;\n} {\n  // Placeholder structure of the ciphertext payload, used to determine the\n  // stringified JSON overhead length.\n  const shell: CipherObject = {\n    iv: '',\n    ephemeralPK: '',\n    mac: '',\n    cipherText: '',\n    wasString: !!opts.wasString,\n  };\n  if (opts.cipherTextEncoding === 'base64') {\n    shell.cipherTextEncoding = 'base64';\n  }\n  // Hex encoded 16 byte buffer.\n  const ivLength = 32;\n  // Hex encoded, compressed EC pubkey of 33 bytes.\n  const ephemeralPKLength = 66;\n  // Hex encoded 32 byte hmac-sha256.\n  const macLength = 64;\n  return {\n    payloadValuesLength: ivLength + ephemeralPKLength + macLength,\n    payloadShell: JSON.stringify(shell),\n  };\n}\n\n/**\n * Get details about the JSON envelope size overhead for signed ciphertext payloads.\n * @param payloadShell - The JSON stringified empty `CipherObject`\n * @ignore\n */\nexport function getSignedCipherObjectWrapper(payloadShell: string): {\n  /** The stringified JSON string of an empty `SignedCipherObject`. */\n  signedPayloadValuesLength: number;\n  /** Total string length of all the `SignedCipherObject` values\n   * that always have constant lengths */\n  signedPayloadShell: string;\n} {\n  // Placeholder structure of the signed ciphertext payload, used to determine the\n  // stringified JSON overhead length.\n  const shell: SignedCipherObject = {\n    signature: '',\n    publicKey: '',\n    cipherText: payloadShell,\n  };\n  // Hex encoded DER signature, up to 72 byte length.\n  const signatureLength = 144;\n  // Hex encoded 33 byte public key.\n  const publicKeyLength = 66;\n  return {\n    signedPayloadValuesLength: signatureLength + publicKeyLength,\n    signedPayloadShell: JSON.stringify(shell),\n  };\n}\n\n/**\n * Fast function that determines the final ASCII string byte length of the\n * JSON stringified ECIES encrypted payload.\n * @ignore\n */\nexport function eciesGetJsonStringLength(opts: {\n  contentLength: number;\n  wasString: boolean;\n  sign: boolean;\n  cipherTextEncoding: CipherTextEncoding;\n}): number {\n  const { payloadShell, payloadValuesLength } = getCipherObjectWrapper(opts);\n\n  // Calculate the AES output length given the input length.\n  const cipherTextLength = getAesCbcOutputLength(opts.contentLength);\n\n  // Get the encoded string length of the cipherText.\n  let encodedCipherTextLength: number;\n  if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {\n    encodedCipherTextLength = cipherTextLength * 2;\n  } else if (opts.cipherTextEncoding === 'base64') {\n    encodedCipherTextLength = getBase64OutputLength(cipherTextLength);\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${opts.cipherTextEncoding}\"`);\n  }\n\n  if (!opts.sign) {\n    // Add the length of the JSON envelope, ciphertext length, and length of const values.\n    return payloadShell.length + payloadValuesLength + encodedCipherTextLength;\n  } else {\n    // Get the signed version of the JSON envelope\n    const { signedPayloadShell, signedPayloadValuesLength } =\n      getSignedCipherObjectWrapper(payloadShell);\n    // Add length of the JSON envelope, ciphertext length, and length of the const values.\n    return (\n      signedPayloadShell.length +\n      signedPayloadValuesLength +\n      payloadValuesLength +\n      encodedCipherTextLength\n    );\n  }\n}\n\n/**\n * Encrypt content to elliptic curve publicKey using ECIES\n * @param publicKey - secp256k1 public key hex string\n * @param content - content to encrypt\n * @return Object containing:\n *  iv (initialization vector, hex encoding),\n *  cipherText (cipher text either hex or base64 encoded),\n *  mac (message authentication code, hex encoded),\n *  ephemeral public key (hex encoded),\n *  wasString (boolean indicating with or not to return a buffer or string on decrypt)\n * @private\n * @ignore\n */\nexport async function encryptECIES(\n  publicKey: string,\n  content: Buffer,\n  wasString: boolean,\n  cipherTextEncoding?: CipherTextEncoding\n): Promise<CipherObject> {\n  const validity = isValidPublicKey(publicKey);\n  if (!validity.result) {\n    throw validity;\n  }\n  const ephemeralPrivateKey = utils.randomPrivateKey();\n  const ephemeralPublicKey = getPublicKey(ephemeralPrivateKey, true);\n  let sharedSecret = getSharedSecret(ephemeralPrivateKey, publicKey, true);\n  // Trim the compressed mode prefix byte\n  sharedSecret = sharedSecret.slice(1);\n  const sharedKeys = sharedSecretToKeys(Buffer.from(sharedSecret));\n  const initializationVector = utils.randomBytes(16);\n\n  const cipherText = await aes256CbcEncrypt(\n    Buffer.from(initializationVector),\n    sharedKeys.encryptionKey,\n    content\n  );\n\n  const macData = concatBytes(initializationVector, ephemeralPublicKey, cipherText);\n  const mac = await hmacSha256(sharedKeys.hmacKey, Buffer.from(macData));\n\n  let cipherTextString: string;\n\n  if (!cipherTextEncoding || cipherTextEncoding === 'hex') {\n    cipherTextString = bytesToHex(cipherText);\n  } else if (cipherTextEncoding === 'base64') {\n    cipherTextString = cipherText.toString('base64');\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${cipherTextEncoding}\"`);\n  }\n\n  const result: CipherObject = {\n    iv: bytesToHex(initializationVector),\n    ephemeralPK: bytesToHex(ephemeralPublicKey),\n    cipherText: cipherTextString,\n    mac: bytesToHex(mac),\n    wasString,\n  };\n  if (cipherTextEncoding && cipherTextEncoding !== 'hex') {\n    result.cipherTextEncoding = cipherTextEncoding;\n  }\n  return result;\n}\n\n/**\n * Decrypt content encrypted using ECIES\n * @param {String} privateKey - secp256k1 private key hex string\n * @param {Object} cipherObject - object to decrypt, should contain:\n *  iv (initialization vector), cipherText (cipher text),\n *  mac (message authentication code), ephemeralPublicKey\n *  wasString (boolean indicating with or not to return a buffer or string on decrypt)\n * @return {Buffer} plaintext\n * @throws {FailedDecryptionError} if unable to decrypt\n * @private\n * @ignore\n */\nexport async function decryptECIES(\n  privateKey: string,\n  cipherObject: CipherObject\n): Promise<Buffer | string> {\n  if (!cipherObject.ephemeralPK) {\n    throw new FailedDecryptionError(\n      'Unable to get public key from cipher object. ' +\n        'You might be trying to decrypt an unencrypted object.'\n    );\n  }\n  const ephemeralPK = cipherObject.ephemeralPK;\n  let sharedSecret = getSharedSecret(privateKey, ephemeralPK, true);\n  // Trim the compressed mode prefix byte\n  sharedSecret = sharedSecret.slice(1);\n  const sharedKeys = sharedSecretToKeys(Buffer.from(sharedSecret));\n  const ivBuffer = hexToBytes(cipherObject.iv);\n\n  let cipherTextBuffer: Buffer;\n\n  if (!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex') {\n    cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'hex');\n  } else if (cipherObject.cipherTextEncoding === 'base64') {\n    cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'base64');\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${cipherObject.cipherText}\"`);\n  }\n\n  const macData = concatBytes(ivBuffer, hexToBytes(ephemeralPK), cipherTextBuffer);\n  const actualMac = await hmacSha256(sharedKeys.hmacKey, Buffer.from(macData));\n  const expectedMac = hexToBytes(cipherObject.mac);\n\n  if (!equalConstTime(Buffer.from(expectedMac), actualMac)) {\n    throw new FailedDecryptionError('Decryption failed: failure in MAC check');\n  }\n  const plainText = await aes256CbcDecrypt(\n    Buffer.from(ivBuffer),\n    sharedKeys.encryptionKey,\n    cipherTextBuffer\n  );\n\n  if (cipherObject.wasString) {\n    return plainText.toString();\n  } else {\n    return plainText;\n  }\n}\n\n/**\n * Sign content using ECDSA\n *\n * @param {String} privateKey - secp256k1 private key hex string\n * @param {Object} content - content to sign\n * @return {Object} contains:\n * signature - Hex encoded DER signature\n * public key - Hex encoded private string taken from privateKey\n * @private\n * @ignore\n */\nexport function signECDSA(\n  privateKey: string,\n  content: string | Buffer\n): {\n  publicKey: string;\n  signature: string;\n} {\n  const contentBuffer = content instanceof Buffer ? content : Buffer.from(content);\n  const publicKey = getPublicKeyFromPrivate(privateKey);\n  const contentHash = hashSha256Sync(contentBuffer);\n  const signature = signSync(contentHash, privateKey);\n\n  return {\n    signature: bytesToHex(signature),\n    publicKey,\n  };\n}\n\n/**\n * @ignore\n */\nfunction getBuffer(content: string | ArrayBuffer | Buffer) {\n  if (content instanceof Buffer) return content;\n  else if (content instanceof ArrayBuffer) return Buffer.from(content);\n  else return Buffer.from(content);\n}\n\n/**\n * Verify content using ECDSA\n * @param {String | Buffer} content - Content to verify was signed\n * @param {String} publicKey - secp256k1 private key hex string\n * @param {String} signature - Hex encoded DER signature\n * @return {Boolean} returns true when signature matches publickey + content, false if not\n * @private\n * @ignore\n */\nexport function verifyECDSA(\n  content: string | ArrayBuffer | Buffer,\n  publicKey: string,\n  signature: string\n): boolean {\n  const contentBuffer = getBuffer(content);\n  const contentHash = hashSha256Sync(contentBuffer);\n  // verify() is strict: true by default. High-s signatures are rejected, which mirrors libsecp behavior\n  // Set verify options to strict: false, to support the legacy stacks implementations\n  // Reference: https://github.com/paulmillr/noble-secp256k1/releases/tag/1.4.0\n  return verify(signature, contentHash, publicKey, { strict: false });\n}\n\ninterface VerifyMessageSignatureArgs {\n  signature: string;\n  message: string | Buffer;\n  publicKey: string;\n}\n\n/**\n * Verify message signature with recoverable public key\n * @deprecated The Clarity compatible {@link verifyMessageSignatureRsv} is preferred\n */\nexport function verifyMessageSignature({\n  signature,\n  message,\n  publicKey,\n}: VerifyMessageSignatureArgs): boolean {\n  // todo: remove method and pull body to `verifyMessageSignatureRsv`\n  const { r, s } = parseRecoverableSignatureVrs(signature);\n  const sig = new Signature(hexToBigInt(r), hexToBigInt(s));\n  const hashedMsg = typeof message === 'string' ? hashMessage(message) : message;\n  // verify() is strict: true by default. High-s signatures are rejected, which mirrors libsecp behavior\n  // Set verify options to strict: false, to support the legacy stacks implementations\n  // Reference: https://github.com/paulmillr/noble-secp256k1/releases/tag/1.4.0\n  return verify(sig, hashedMsg, publicKey, { strict: false });\n}\n\n/**\n * Verifies a Clarity compatible signed message using a public key. The\n * `signature` option needs to be in RSV format.\n */\nexport function verifyMessageSignatureRsv({\n  signature,\n  message,\n  publicKey,\n}: VerifyMessageSignatureArgs): boolean {\n  return verifyMessageSignature({\n    signature: signatureRsvToVrs(signature),\n    message,\n    publicKey,\n  });\n}\n"]},"metadata":{},"sourceType":"module"}