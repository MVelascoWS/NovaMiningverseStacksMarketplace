{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenSigner = exports.createUnsecuredToken = void 0;\n\nconst base64url_1 = require(\"base64url\");\n\nconst cryptoClients_1 = require(\"./cryptoClients\");\n\nconst errors_1 = require(\"./errors\");\n\nconst sha256_1 = require(\"./cryptoClients/sha256\");\n\nfunction createSigningInput(payload, header) {\n  const tokenParts = []; // add in the header\n\n  const encodedHeader = base64url_1.default.encode(JSON.stringify(header));\n  tokenParts.push(encodedHeader); // add in the payload\n\n  const encodedPayload = base64url_1.default.encode(JSON.stringify(payload));\n  tokenParts.push(encodedPayload); // prepare the message\n\n  const signingInput = tokenParts.join('.'); // return the signing input\n\n  return signingInput;\n}\n\nfunction createUnsecuredToken(payload) {\n  const header = {\n    typ: 'JWT',\n    alg: 'none'\n  };\n  return createSigningInput(payload, header) + '.';\n}\n\nexports.createUnsecuredToken = createUnsecuredToken;\n\nclass TokenSigner {\n  constructor(signingAlgorithm, rawPrivateKey) {\n    if (!(signingAlgorithm && rawPrivateKey)) {\n      throw new errors_1.MissingParametersError('a signing algorithm and private key are required');\n    }\n\n    if (typeof signingAlgorithm !== 'string') {\n      throw new Error('signing algorithm parameter must be a string');\n    }\n\n    signingAlgorithm = signingAlgorithm.toUpperCase();\n\n    if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n      throw new Error('invalid signing algorithm');\n    }\n\n    this.tokenType = 'JWT';\n    this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n    this.rawPrivateKey = rawPrivateKey;\n  }\n\n  header() {\n    let header = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const defaultHeader = {\n      typ: this.tokenType,\n      alg: this.cryptoClient.algorithmName\n    };\n    return Object.assign({}, defaultHeader, header);\n  }\n\n  sign(payload) {\n    let expanded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let customHeader = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // generate the token header\n    const header = this.header(customHeader); // prepare the message to be signed\n\n    const signingInput = createSigningInput(payload, header);\n    const signingInputHash = (0, sha256_1.hashSha256)(signingInput);\n    return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);\n  }\n\n  signAsync(payload) {\n    let expanded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let customHeader = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      // generate the token header\n      const header = this.header(customHeader); // prepare the message to be signed\n\n      const signingInput = createSigningInput(payload, header);\n      const signingInputHash = yield (0, sha256_1.hashSha256Async)(signingInput);\n      return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);\n    });\n  }\n\n  createWithSignedHash(payload, expanded, header, signingInput, signingInputHash) {\n    // sign the message and add in the signature\n    const signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);\n\n    if (expanded) {\n      const signedToken = {\n        header: [base64url_1.default.encode(JSON.stringify(header))],\n        payload: JSON.stringify(payload),\n        signature: [signature]\n      };\n      return signedToken;\n    } else {\n      return [signingInput, signature].join('.');\n    }\n  }\n\n}\n\nexports.TokenSigner = TokenSigner;","map":{"version":3,"mappings":"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","names":["createSigningInput","payload","header","tokenParts","encodedHeader","base64url_1","encode","JSON","stringify","push","encodedPayload","signingInput","join","createUnsecuredToken","typ","alg","exports","TokenSigner","constructor","signingAlgorithm","rawPrivateKey","errors_1","Error","toUpperCase","cryptoClients_1","hasOwnProperty","tokenType","cryptoClient","defaultHeader","algorithmName","Object","assign","sign","expanded","customHeader","signingInputHash","createWithSignedHash","signAsync","signature","signHash","signedToken"],"sources":["signer.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}