{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { getCryptoLib } from './cryptoUtils';\nexport class NodeCryptoAesCipher {\n  constructor(createCipher, createDecipher) {\n    this.createCipher = createCipher;\n    this.createDecipher = createDecipher;\n  }\n\n  async encrypt(algorithm, key, iv, data) {\n    if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n\n    const cipher = this.createCipher(algorithm, key, iv);\n    const result = Buffer.concat([cipher.update(data), cipher.final()]);\n    return Promise.resolve(result);\n  }\n\n  async decrypt(algorithm, key, iv, data) {\n    if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n\n    const cipher = this.createDecipher(algorithm, key, iv);\n    const result = Buffer.concat([cipher.update(data), cipher.final()]);\n    return Promise.resolve(result);\n  }\n\n}\nexport class WebCryptoAesCipher {\n  constructor(subtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  async encrypt(algorithm, key, iv, data) {\n    let algo;\n    let length;\n\n    if (algorithm === 'aes-128-cbc') {\n      algo = 'AES-CBC';\n      length = 128;\n    } else if (algorithm === 'aes-256-cbc') {\n      algo = 'AES-CBC';\n      length = 256;\n    } else {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n\n    const cryptoKey = await this.subtleCrypto.importKey('raw', key, {\n      name: algo,\n      length\n    }, false, ['encrypt']);\n    const result = await this.subtleCrypto.encrypt({\n      name: algo,\n      iv\n    }, cryptoKey, data);\n    return Buffer.from(result);\n  }\n\n  async decrypt(algorithm, key, iv, data) {\n    let algo;\n    let length;\n\n    if (algorithm === 'aes-128-cbc') {\n      algo = 'AES-CBC';\n      length = 128;\n    } else if (algorithm === 'aes-256-cbc') {\n      algo = 'AES-CBC';\n      length = 256;\n    } else {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n\n    const cryptoKey = await this.subtleCrypto.importKey('raw', key, {\n      name: algo,\n      length\n    }, false, ['decrypt']);\n    const result = await this.subtleCrypto.decrypt({\n      name: algo,\n      iv\n    }, cryptoKey, data);\n    return Buffer.from(result);\n  }\n\n}\nexport async function createCipher() {\n  const cryptoLib = await getCryptoLib();\n\n  if (cryptoLib.name === 'subtleCrypto') {\n    return new WebCryptoAesCipher(cryptoLib.lib);\n  } else {\n    return new NodeCryptoAesCipher(cryptoLib.lib.createCipheriv, cryptoLib.lib.createDecipheriv);\n  }\n}","map":{"version":3,"mappings":"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","names":["Buffer","getCryptoLib","NodeCryptoAesCipher","constructor","createCipher","createDecipher","encrypt","algorithm","key","iv","data","Error","cipher","result","concat","update","final","Promise","resolve","decrypt","WebCryptoAesCipher","subtleCrypto","algo","length","cryptoKey","importKey","name","from","cryptoLib","lib","createCipheriv","createDecipheriv"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\encryption\\src\\aesCipher.ts"],"sourcesContent":["import { Buffer } from '@stacks/common';\nimport { getCryptoLib } from './cryptoUtils';\n\ntype NodeCryptoCreateCipher = typeof import('crypto').createCipheriv;\ntype NodeCryptoCreateDecipher = typeof import('crypto').createDecipheriv;\n\nexport type CipherAlgorithm = 'aes-256-cbc' | 'aes-128-cbc';\n\nexport interface AesCipher {\n  encrypt(algorithm: CipherAlgorithm, key: Buffer, iv: Buffer, data: Buffer): Promise<Buffer>;\n\n  decrypt(algorithm: CipherAlgorithm, key: Buffer, iv: Buffer, data: Buffer): Promise<Buffer>;\n}\n\nexport class NodeCryptoAesCipher implements AesCipher {\n  createCipher: NodeCryptoCreateCipher;\n\n  createDecipher: NodeCryptoCreateDecipher;\n\n  constructor(createCipher: NodeCryptoCreateCipher, createDecipher: NodeCryptoCreateDecipher) {\n    this.createCipher = createCipher;\n    this.createDecipher = createDecipher;\n  }\n\n  async encrypt(\n    algorithm: CipherAlgorithm,\n    key: Buffer,\n    iv: Buffer,\n    data: Buffer\n  ): Promise<Buffer> {\n    if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n    const cipher = this.createCipher(algorithm, key, iv);\n    const result = Buffer.concat([cipher.update(data), cipher.final()]);\n    return Promise.resolve(result);\n  }\n\n  async decrypt(\n    algorithm: CipherAlgorithm,\n    key: Buffer,\n    iv: Buffer,\n    data: Buffer\n  ): Promise<Buffer> {\n    if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n    const cipher = this.createDecipher(algorithm, key, iv);\n    const result = Buffer.concat([cipher.update(data), cipher.final()]);\n    return Promise.resolve(result);\n  }\n}\n\nexport class WebCryptoAesCipher implements AesCipher {\n  subtleCrypto: SubtleCrypto;\n\n  constructor(subtleCrypto: SubtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  async encrypt(\n    algorithm: CipherAlgorithm,\n    key: Buffer,\n    iv: Buffer,\n    data: Buffer\n  ): Promise<Buffer> {\n    let algo: string;\n    let length: number;\n    if (algorithm === 'aes-128-cbc') {\n      algo = 'AES-CBC';\n      length = 128;\n    } else if (algorithm === 'aes-256-cbc') {\n      algo = 'AES-CBC';\n      length = 256;\n    } else {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n    const cryptoKey = await this.subtleCrypto.importKey('raw', key, { name: algo, length }, false, [\n      'encrypt',\n    ]);\n    const result = await this.subtleCrypto.encrypt({ name: algo, iv }, cryptoKey, data);\n    return Buffer.from(result);\n  }\n\n  async decrypt(\n    algorithm: CipherAlgorithm,\n    key: Buffer,\n    iv: Buffer,\n    data: Buffer\n  ): Promise<Buffer> {\n    let algo: string;\n    let length: number;\n    if (algorithm === 'aes-128-cbc') {\n      algo = 'AES-CBC';\n      length = 128;\n    } else if (algorithm === 'aes-256-cbc') {\n      algo = 'AES-CBC';\n      length = 256;\n    } else {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n    const cryptoKey = await this.subtleCrypto.importKey('raw', key, { name: algo, length }, false, [\n      'decrypt',\n    ]);\n    const result = await this.subtleCrypto.decrypt({ name: algo, iv }, cryptoKey, data);\n    return Buffer.from(result);\n  }\n}\n\nexport async function createCipher(): Promise<AesCipher> {\n  const cryptoLib = await getCryptoLib();\n  if (cryptoLib.name === 'subtleCrypto') {\n    return new WebCryptoAesCipher(cryptoLib.lib);\n  } else {\n    return new NodeCryptoAesCipher(cryptoLib.lib.createCipheriv, cryptoLib.lib.createDecipheriv);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}