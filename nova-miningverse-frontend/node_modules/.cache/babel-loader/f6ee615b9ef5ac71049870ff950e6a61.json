{"ast":null,"code":"import { Buffer, intToBigInt } from '@stacks/common';\nimport { AnchorMode, AuthType, DEFAULT_CHAIN_ID, PayloadType, PostConditionMode, PubKeyEncoding, StacksMessageType, TransactionVersion } from './constants';\nimport { deserializeAuthorization, intoInitialSighashAuth, isSingleSig, nextSignature, serializeAuthorization, setFee, setNonce, setSponsor, setSponsorNonce, verifyOrigin } from './authorization';\nimport { createTransactionAuthField } from './signature';\nimport { BufferArray, cloneDeep, txidFromData } from './utils';\nimport { deserializePayload, serializePayload } from './payload';\nimport { createLPList, deserializeLPList, serializeLPList } from './types';\nimport { isCompressed } from './keys';\nimport { BufferReader } from './bufferReader';\nimport { SerializationError, SigningError } from './errors';\nexport class StacksTransaction {\n  constructor(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId) {\n    this.version = version;\n    this.auth = auth;\n\n    if ('amount' in payload) {\n      this.payload = Object.assign(Object.assign({}, payload), {\n        amount: intToBigInt(payload.amount, false)\n      });\n    } else {\n      this.payload = payload;\n    }\n\n    this.chainId = chainId !== null && chainId !== void 0 ? chainId : DEFAULT_CHAIN_ID;\n    this.postConditionMode = postConditionMode !== null && postConditionMode !== void 0 ? postConditionMode : PostConditionMode.Deny;\n    this.postConditions = postConditions !== null && postConditions !== void 0 ? postConditions : createLPList([]);\n\n    if (anchorMode) {\n      this.anchorMode = anchorMode;\n    } else {\n      switch (payload.payloadType) {\n        case PayloadType.Coinbase:\n        case PayloadType.PoisonMicroblock:\n          {\n            this.anchorMode = AnchorMode.OnChainOnly;\n            break;\n          }\n\n        case PayloadType.ContractCall:\n        case PayloadType.SmartContract:\n        case PayloadType.TokenTransfer:\n          {\n            this.anchorMode = AnchorMode.Any;\n            break;\n          }\n      }\n    }\n  }\n\n  signBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = intoInitialSighashAuth(tx.auth);\n    return tx.txid();\n  }\n\n  verifyBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = intoInitialSighashAuth(tx.auth);\n    return tx.txid();\n  }\n\n  verifyOrigin() {\n    return verifyOrigin(this.auth, this.verifyBegin());\n  }\n\n  signNextOrigin(sigHash, privateKey) {\n    if (this.auth.spendingCondition === undefined) {\n      throw new Error('\"auth.spendingCondition\" is undefined');\n    }\n\n    if (this.auth.authType === undefined) {\n      throw new Error('\"auth.authType\" is undefined');\n    }\n\n    return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);\n  }\n\n  signNextSponsor(sigHash, privateKey) {\n    if (this.auth.authType === AuthType.Sponsored) {\n      return this.signAndAppend(this.auth.sponsorSpendingCondition, sigHash, AuthType.Sponsored, privateKey);\n    } else {\n      throw new Error('\"auth.sponsorSpendingCondition\" is undefined');\n    }\n  }\n\n  appendPubkey(publicKey) {\n    const cond = this.auth.spendingCondition;\n\n    if (cond && !isSingleSig(cond)) {\n      const compressed = isCompressed(publicKey);\n      cond.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, publicKey));\n    } else {\n      throw new Error(`Can't append public key to a singlesig condition`);\n    }\n  }\n\n  signAndAppend(condition, curSigHash, authType, privateKey) {\n    const {\n      nextSig,\n      nextSigHash\n    } = nextSignature(curSigHash, authType, condition.fee, condition.nonce, privateKey);\n\n    if (isSingleSig(condition)) {\n      condition.signature = nextSig;\n    } else {\n      const compressed = privateKey.data.toString('hex').endsWith('01');\n      condition.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, nextSig));\n    }\n\n    return nextSigHash;\n  }\n\n  txid() {\n    const serialized = this.serialize();\n    return txidFromData(serialized);\n  }\n\n  setSponsor(sponsorSpendingCondition) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n\n    this.auth = setSponsor(this.auth, sponsorSpendingCondition);\n  }\n\n  setFee(amount) {\n    this.auth = setFee(this.auth, amount);\n  }\n\n  setNonce(nonce) {\n    this.auth = setNonce(this.auth, nonce);\n  }\n\n  setSponsorNonce(nonce) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n\n    this.auth = setSponsorNonce(this.auth, nonce);\n  }\n\n  serialize() {\n    if (this.version === undefined) {\n      throw new SerializationError('\"version\" is undefined');\n    }\n\n    if (this.chainId === undefined) {\n      throw new SerializationError('\"chainId\" is undefined');\n    }\n\n    if (this.auth === undefined) {\n      throw new SerializationError('\"auth\" is undefined');\n    }\n\n    if (this.anchorMode === undefined) {\n      throw new SerializationError('\"anchorMode\" is undefined');\n    }\n\n    if (this.payload === undefined) {\n      throw new SerializationError('\"payload\" is undefined');\n    }\n\n    const bufferArray = new BufferArray();\n    bufferArray.appendByte(this.version);\n    const chainIdBuffer = Buffer.alloc(4);\n    chainIdBuffer.writeUInt32BE(this.chainId, 0);\n    bufferArray.push(chainIdBuffer);\n    bufferArray.push(serializeAuthorization(this.auth));\n    bufferArray.appendByte(this.anchorMode);\n    bufferArray.appendByte(this.postConditionMode);\n    bufferArray.push(serializeLPList(this.postConditions));\n    bufferArray.push(serializePayload(this.payload));\n    return bufferArray.concatBuffer();\n  }\n\n}\nexport function deserializeTransaction(data) {\n  let bufferReader;\n\n  if (typeof data === 'string') {\n    if (data.slice(0, 2).toLowerCase() === '0x') {\n      bufferReader = new BufferReader(Buffer.from(data.slice(2), 'hex'));\n    } else {\n      bufferReader = new BufferReader(Buffer.from(data, 'hex'));\n    }\n  } else if (Buffer.isBuffer(data)) {\n    bufferReader = new BufferReader(data);\n  } else {\n    bufferReader = data;\n  }\n\n  const version = bufferReader.readUInt8Enum(TransactionVersion, n => {\n    throw new Error(`Could not parse ${n} as TransactionVersion`);\n  });\n  const chainId = bufferReader.readUInt32BE();\n  const auth = deserializeAuthorization(bufferReader);\n  const anchorMode = bufferReader.readUInt8Enum(AnchorMode, n => {\n    throw new Error(`Could not parse ${n} as AnchorMode`);\n  });\n  const postConditionMode = bufferReader.readUInt8Enum(PostConditionMode, n => {\n    throw new Error(`Could not parse ${n} as PostConditionMode`);\n  });\n  const postConditions = deserializeLPList(bufferReader, StacksMessageType.PostCondition);\n  const payload = deserializePayload(bufferReader);\n  return new StacksTransaction(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId);\n}","map":{"version":3,"mappings":"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","names":["Buffer","intToBigInt","AnchorMode","AuthType","DEFAULT_CHAIN_ID","PayloadType","PostConditionMode","PubKeyEncoding","StacksMessageType","TransactionVersion","deserializeAuthorization","intoInitialSighashAuth","isSingleSig","nextSignature","serializeAuthorization","setFee","setNonce","setSponsor","setSponsorNonce","verifyOrigin","createTransactionAuthField","BufferArray","cloneDeep","txidFromData","deserializePayload","serializePayload","createLPList","deserializeLPList","serializeLPList","isCompressed","BufferReader","SerializationError","SigningError","StacksTransaction","constructor","version","auth","payload","postConditions","postConditionMode","anchorMode","chainId","Object","amount","Deny","payloadType","Coinbase","PoisonMicroblock","OnChainOnly","ContractCall","SmartContract","TokenTransfer","Any","signBegin","tx","txid","verifyBegin","signNextOrigin","sigHash","privateKey","spendingCondition","undefined","Error","authType","signAndAppend","Standard","signNextSponsor","Sponsored","sponsorSpendingCondition","appendPubkey","publicKey","cond","compressed","fields","push","Compressed","Uncompressed","condition","curSigHash","nextSig","nextSigHash","fee","nonce","signature","data","toString","endsWith","serialized","serialize","bufferArray","appendByte","chainIdBuffer","alloc","writeUInt32BE","concatBuffer","deserializeTransaction","bufferReader","slice","toLowerCase","from","isBuffer","readUInt8Enum","n","readUInt32BE","PostCondition"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\connect\\node_modules\\@stacks\\transactions\\src\\transaction.ts"],"sourcesContent":["import { Buffer, IntegerType, intToBigInt } from '@stacks/common';\nimport {\n  AnchorMode,\n  AuthType,\n  ChainID,\n  DEFAULT_CHAIN_ID,\n  PayloadType,\n  PostConditionMode,\n  PubKeyEncoding,\n  StacksMessageType,\n  TransactionVersion,\n} from './constants';\n\nimport {\n  Authorization,\n  deserializeAuthorization,\n  intoInitialSighashAuth,\n  isSingleSig,\n  nextSignature,\n  serializeAuthorization,\n  setFee,\n  setNonce,\n  setSponsor,\n  setSponsorNonce,\n  SpendingConditionOpts,\n  verifyOrigin,\n} from './authorization';\nimport { createTransactionAuthField } from './signature';\n\nimport { BufferArray, cloneDeep, txidFromData } from './utils';\n\nimport { deserializePayload, Payload, PayloadInput, serializePayload } from './payload';\n\nimport { createLPList, deserializeLPList, LengthPrefixedList, serializeLPList } from './types';\n\nimport { isCompressed, StacksPrivateKey, StacksPublicKey } from './keys';\n\nimport { BufferReader } from './bufferReader';\n\nimport { SerializationError, SigningError } from './errors';\n\nexport class StacksTransaction {\n  version: TransactionVersion;\n  chainId: ChainID;\n  auth: Authorization;\n  anchorMode: AnchorMode;\n  payload: Payload;\n  postConditionMode: PostConditionMode;\n  postConditions: LengthPrefixedList;\n\n  constructor(\n    version: TransactionVersion,\n    auth: Authorization,\n    payload: PayloadInput,\n    postConditions?: LengthPrefixedList,\n    postConditionMode?: PostConditionMode,\n    anchorMode?: AnchorMode,\n    chainId?: ChainID\n  ) {\n    this.version = version;\n    this.auth = auth;\n    if ('amount' in payload) {\n      this.payload = {\n        ...payload,\n        amount: intToBigInt(payload.amount, false),\n      };\n    } else {\n      this.payload = payload;\n    }\n    this.chainId = chainId ?? DEFAULT_CHAIN_ID;\n    this.postConditionMode = postConditionMode ?? PostConditionMode.Deny;\n    this.postConditions = postConditions ?? createLPList([]);\n\n    if (anchorMode) {\n      this.anchorMode = anchorMode;\n    } else {\n      switch (payload.payloadType) {\n        case PayloadType.Coinbase:\n        case PayloadType.PoisonMicroblock: {\n          this.anchorMode = AnchorMode.OnChainOnly;\n          break;\n        }\n        case PayloadType.ContractCall:\n        case PayloadType.SmartContract:\n        case PayloadType.TokenTransfer: {\n          this.anchorMode = AnchorMode.Any;\n          break;\n        }\n      }\n    }\n  }\n\n  signBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = intoInitialSighashAuth(tx.auth);\n    return tx.txid();\n  }\n\n  verifyBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = intoInitialSighashAuth(tx.auth);\n    return tx.txid();\n  }\n\n  verifyOrigin(): string {\n    return verifyOrigin(this.auth, this.verifyBegin());\n  }\n\n  signNextOrigin(sigHash: string, privateKey: StacksPrivateKey): string {\n    if (this.auth.spendingCondition === undefined) {\n      throw new Error('\"auth.spendingCondition\" is undefined');\n    }\n    if (this.auth.authType === undefined) {\n      throw new Error('\"auth.authType\" is undefined');\n    }\n    return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);\n  }\n\n  signNextSponsor(sigHash: string, privateKey: StacksPrivateKey): string {\n    if (this.auth.authType === AuthType.Sponsored) {\n      return this.signAndAppend(\n        this.auth.sponsorSpendingCondition,\n        sigHash,\n        AuthType.Sponsored,\n        privateKey\n      );\n    } else {\n      throw new Error('\"auth.sponsorSpendingCondition\" is undefined');\n    }\n  }\n\n  appendPubkey(publicKey: StacksPublicKey) {\n    const cond = this.auth.spendingCondition;\n    if (cond && !isSingleSig(cond)) {\n      const compressed = isCompressed(publicKey);\n      cond.fields.push(\n        createTransactionAuthField(\n          compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed,\n          publicKey\n        )\n      );\n    } else {\n      throw new Error(`Can't append public key to a singlesig condition`);\n    }\n  }\n\n  signAndAppend(\n    condition: SpendingConditionOpts,\n    curSigHash: string,\n    authType: AuthType,\n    privateKey: StacksPrivateKey\n  ): string {\n    const { nextSig, nextSigHash } = nextSignature(\n      curSigHash,\n      authType,\n      condition.fee,\n      condition.nonce,\n      privateKey\n    );\n    if (isSingleSig(condition)) {\n      condition.signature = nextSig;\n    } else {\n      const compressed = privateKey.data.toString('hex').endsWith('01');\n      condition.fields.push(\n        createTransactionAuthField(\n          compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed,\n          nextSig\n        )\n      );\n    }\n\n    return nextSigHash;\n  }\n\n  txid(): string {\n    const serialized = this.serialize();\n    return txidFromData(serialized);\n  }\n\n  setSponsor(sponsorSpendingCondition: SpendingConditionOpts) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n\n    this.auth = setSponsor(this.auth, sponsorSpendingCondition);\n  }\n\n  /**\n   * Set the total fee to be paid for this transaction\n   *\n   * @param fee - the fee amount in microstacks\n   */\n  setFee(amount: IntegerType) {\n    this.auth = setFee(this.auth, amount);\n  }\n\n  /**\n   * Set the transaction nonce\n   *\n   * @param nonce - the nonce value\n   */\n  setNonce(nonce: IntegerType) {\n    this.auth = setNonce(this.auth, nonce);\n  }\n\n  /**\n   * Set the transaction sponsor nonce\n   *\n   * @param nonce - the sponsor nonce value\n   */\n  setSponsorNonce(nonce: IntegerType) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n\n    this.auth = setSponsorNonce(this.auth, nonce);\n  }\n\n  serialize(): Buffer {\n    if (this.version === undefined) {\n      throw new SerializationError('\"version\" is undefined');\n    }\n    if (this.chainId === undefined) {\n      throw new SerializationError('\"chainId\" is undefined');\n    }\n    if (this.auth === undefined) {\n      throw new SerializationError('\"auth\" is undefined');\n    }\n    if (this.anchorMode === undefined) {\n      throw new SerializationError('\"anchorMode\" is undefined');\n    }\n    if (this.payload === undefined) {\n      throw new SerializationError('\"payload\" is undefined');\n    }\n\n    const bufferArray: BufferArray = new BufferArray();\n\n    bufferArray.appendByte(this.version);\n    const chainIdBuffer = Buffer.alloc(4);\n    chainIdBuffer.writeUInt32BE(this.chainId, 0);\n    bufferArray.push(chainIdBuffer);\n    bufferArray.push(serializeAuthorization(this.auth));\n    bufferArray.appendByte(this.anchorMode);\n    bufferArray.appendByte(this.postConditionMode);\n    bufferArray.push(serializeLPList(this.postConditions));\n    bufferArray.push(serializePayload(this.payload));\n\n    return bufferArray.concatBuffer();\n  }\n}\n\n/**\n * @param data Buffer or hex string\n */\nexport function deserializeTransaction(data: BufferReader | Buffer | string) {\n  let bufferReader: BufferReader;\n  if (typeof data === 'string') {\n    if (data.slice(0, 2).toLowerCase() === '0x') {\n      bufferReader = new BufferReader(Buffer.from(data.slice(2), 'hex'));\n    } else {\n      bufferReader = new BufferReader(Buffer.from(data, 'hex'));\n    }\n  } else if (Buffer.isBuffer(data)) {\n    bufferReader = new BufferReader(data);\n  } else {\n    bufferReader = data;\n  }\n  const version = bufferReader.readUInt8Enum(TransactionVersion, n => {\n    throw new Error(`Could not parse ${n} as TransactionVersion`);\n  });\n  const chainId = bufferReader.readUInt32BE();\n  const auth = deserializeAuthorization(bufferReader);\n  const anchorMode = bufferReader.readUInt8Enum(AnchorMode, n => {\n    throw new Error(`Could not parse ${n} as AnchorMode`);\n  });\n  const postConditionMode = bufferReader.readUInt8Enum(PostConditionMode, n => {\n    throw new Error(`Could not parse ${n} as PostConditionMode`);\n  });\n  const postConditions = deserializeLPList(bufferReader, StacksMessageType.PostCondition);\n  const payload = deserializePayload(bufferReader);\n\n  return new StacksTransaction(\n    version,\n    auth,\n    payload,\n    postConditions,\n    postConditionMode,\n    anchorMode,\n    chainId\n  );\n}\n"]},"metadata":{},"sourceType":"module"}