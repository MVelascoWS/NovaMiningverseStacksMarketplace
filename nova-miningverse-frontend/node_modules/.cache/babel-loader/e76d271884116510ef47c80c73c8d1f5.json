{"ast":null,"code":"import { isSingleSig, nextVerification } from './authorization';\nimport { cloneDeep } from './utils';\nimport { AuthType, PubKeyEncoding, StacksMessageType } from './constants';\nimport { SigningError } from './errors';\nexport class TransactionSigner {\n  constructor(transaction) {\n    this.transaction = transaction;\n    this.sigHash = transaction.signBegin();\n    this.originDone = false;\n    this.checkOversign = true;\n    this.checkOverlap = true;\n    const spendingCondition = transaction.auth.spendingCondition;\n\n    if (spendingCondition && !isSingleSig(spendingCondition)) {\n      if (spendingCondition.fields.filter(field => field.contents.type === StacksMessageType.MessageSignature).length >= spendingCondition.signaturesRequired) {\n        throw new Error('SpendingCondition has more signatures than are expected');\n      }\n\n      spendingCondition.fields.forEach(field => {\n        if (field.contents.type === StacksMessageType.MessageSignature) {\n          const signature = field.contents;\n          const nextVerify = nextVerification(this.sigHash, transaction.auth.authType, spendingCondition.fee, spendingCondition.nonce, PubKeyEncoding.Compressed, signature);\n          this.sigHash = nextVerify.nextSigHash;\n        }\n      });\n    }\n  }\n\n  static createSponsorSigner(transaction, spendingCondition) {\n    if (transaction.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot add sponsor to non-sponsored transaction');\n    }\n\n    const tx = cloneDeep(transaction);\n    tx.setSponsor(spendingCondition);\n    const originSigHash = tx.verifyOrigin();\n    const signer = new this(tx);\n    signer.originDone = true;\n    signer.sigHash = originSigHash;\n    signer.checkOversign = true;\n    signer.checkOverlap = true;\n    return signer;\n  }\n\n  signOrigin(privateKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw new SigningError('Cannot sign origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new SigningError('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    if (!isSingleSig(this.transaction.auth.spendingCondition)) {\n      const spendingCondition = this.transaction.auth.spendingCondition;\n\n      if (this.checkOversign && spendingCondition.fields.filter(field => field.contents.type === StacksMessageType.MessageSignature).length >= spendingCondition.signaturesRequired) {\n        throw new Error('Origin would have too many signatures');\n      }\n    }\n\n    const nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n  }\n\n  appendOrigin(publicKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw Error('Cannot append public key to origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new Error('\"transaction.auth\" is undefined');\n    }\n\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new Error('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    this.transaction.appendPubkey(publicKey);\n  }\n\n  signSponsor(privateKey) {\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n\n    if (this.transaction.auth.authType !== AuthType.Sponsored) {\n      throw new SigningError('\"transaction.auth.authType\" is not AuthType.Sponsored');\n    }\n\n    const nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n    this.originDone = true;\n  }\n\n  getTxInComplete() {\n    return cloneDeep(this.transaction);\n  }\n\n  resume(transaction) {\n    this.transaction = cloneDeep(transaction);\n    this.sigHash = transaction.signBegin();\n  }\n\n}","map":{"version":3,"mappings":"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","names":["isSingleSig","nextVerification","cloneDeep","AuthType","PubKeyEncoding","StacksMessageType","SigningError","TransactionSigner","constructor","transaction","sigHash","signBegin","originDone","checkOversign","checkOverlap","spendingCondition","auth","fields","filter","field","contents","type","MessageSignature","length","signaturesRequired","Error","forEach","signature","nextVerify","authType","fee","nonce","Compressed","nextSigHash","createSponsorSigner","Sponsored","tx","setSponsor","originSigHash","verifyOrigin","signer","signOrigin","privateKey","undefined","nextSighash","signNextOrigin","appendOrigin","publicKey","appendPubkey","signSponsor","signNextSponsor","getTxInComplete","resume"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\transactions\\src\\signer.ts"],"sourcesContent":["import { StacksTransaction } from './transaction';\n\nimport { StacksPrivateKey, StacksPublicKey } from './keys';\nimport { isSingleSig, nextVerification, SpendingConditionOpts } from './authorization';\nimport { cloneDeep } from './utils';\nimport { AuthType, PubKeyEncoding, StacksMessageType } from './constants';\nimport { SigningError } from './errors';\n\nexport class TransactionSigner {\n  transaction: StacksTransaction;\n  sigHash: string;\n  originDone: boolean;\n  checkOversign: boolean;\n  checkOverlap: boolean;\n\n  constructor(transaction: StacksTransaction) {\n    this.transaction = transaction;\n    this.sigHash = transaction.signBegin();\n    this.originDone = false;\n    this.checkOversign = true;\n    this.checkOverlap = true;\n\n    // If multi-sig spending condition exists, iterate over\n    // auth fields and reconstruct sigHash\n    const spendingCondition = transaction.auth.spendingCondition;\n    if (spendingCondition && !isSingleSig(spendingCondition)) {\n      if (\n        spendingCondition.fields.filter(\n          field => field.contents.type === StacksMessageType.MessageSignature\n        ).length >= spendingCondition.signaturesRequired\n      ) {\n        throw new Error('SpendingCondition has more signatures than are expected');\n      }\n\n      spendingCondition.fields.forEach(field => {\n        if (field.contents.type === StacksMessageType.MessageSignature) {\n          const signature = field.contents;\n          const nextVerify = nextVerification(\n            this.sigHash,\n            transaction.auth.authType,\n            spendingCondition.fee,\n            spendingCondition.nonce,\n            PubKeyEncoding.Compressed, // always compressed for multisig\n            signature\n          );\n          this.sigHash = nextVerify.nextSigHash;\n        }\n      });\n    }\n  }\n\n  static createSponsorSigner(\n    transaction: StacksTransaction,\n    spendingCondition: SpendingConditionOpts\n  ) {\n    if (transaction.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot add sponsor to non-sponsored transaction');\n    }\n\n    const tx: StacksTransaction = cloneDeep(transaction);\n    tx.setSponsor(spendingCondition);\n    const originSigHash = tx.verifyOrigin();\n    const signer = new this(tx);\n    signer.originDone = true;\n    signer.sigHash = originSigHash;\n    signer.checkOversign = true;\n    signer.checkOverlap = true;\n    return signer;\n  }\n\n  signOrigin(privateKey: StacksPrivateKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw new SigningError('Cannot sign origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new SigningError('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    if (!isSingleSig(this.transaction.auth.spendingCondition)) {\n      const spendingCondition = this.transaction.auth.spendingCondition;\n      if (\n        this.checkOversign &&\n        spendingCondition.fields.filter(\n          field => field.contents.type === StacksMessageType.MessageSignature\n        ).length >= spendingCondition.signaturesRequired\n      ) {\n        throw new Error('Origin would have too many signatures');\n      }\n    }\n\n    const nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n  }\n\n  appendOrigin(publicKey: StacksPublicKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw Error('Cannot append public key to origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new Error('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new Error('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    this.transaction.appendPubkey(publicKey);\n  }\n\n  signSponsor(privateKey: StacksPrivateKey) {\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.authType !== AuthType.Sponsored) {\n      throw new SigningError('\"transaction.auth.authType\" is not AuthType.Sponsored');\n    }\n\n    const nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n    this.originDone = true;\n  }\n\n  getTxInComplete(): StacksTransaction {\n    return cloneDeep(this.transaction);\n  }\n\n  resume(transaction: StacksTransaction) {\n    this.transaction = cloneDeep(transaction);\n    this.sigHash = transaction.signBegin();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}