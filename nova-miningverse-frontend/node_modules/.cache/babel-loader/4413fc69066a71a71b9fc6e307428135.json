{"ast":null,"code":"import { MAX_STRING_LENGTH_BYTES, PostConditionPrincipalID, StacksMessageType } from './constants';\nimport { c32addressDecode } from 'c32check';\nimport { exceedsMaxLengthBytes } from './utils';\nexport function parseAssetInfoString(id) {\n  const [assetAddress, assetContractName, assetTokenName] = id.split(/\\.|::/);\n  const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);\n  return assetInfo;\n}\nexport function createLPString(content, lengthPrefixBytes, maxLengthBytes) {\n  const prefixLength = lengthPrefixBytes || 1;\n  const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;\n\n  if (exceedsMaxLengthBytes(content, maxLength)) {\n    throw new Error(`String length exceeds maximum bytes ${maxLength.toString()}`);\n  }\n\n  return {\n    type: StacksMessageType.LengthPrefixedString,\n    content,\n    lengthPrefixBytes: prefixLength,\n    maxLengthBytes: maxLength\n  };\n}\nexport function createAssetInfo(addressString, contractName, assetName) {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: createAddress(addressString),\n    contractName: createLPString(contractName),\n    assetName: createLPString(assetName)\n  };\n}\nexport function createAddress(c32AddressString) {\n  const addressData = c32addressDecode(c32AddressString);\n  return {\n    type: StacksMessageType.Address,\n    version: addressData[0],\n    hash160: addressData[1]\n  };\n}\nexport function parsePrincipalString(principalString) {\n  if (principalString.includes('.')) {\n    const [address, contractName] = principalString.split('.');\n    return createContractPrincipal(address, contractName);\n  } else {\n    return createStandardPrincipal(principalString);\n  }\n}\nexport function createContractPrincipal(addressString, contractName) {\n  const addr = createAddress(addressString);\n  const name = createLPString(contractName);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Contract,\n    address: addr,\n    contractName: name\n  };\n}\nexport function createStandardPrincipal(addressString) {\n  const addr = createAddress(addressString);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Standard,\n    address: addr\n  };\n}","map":{"version":3,"mappings":"AAAA,SAEEA,uBAFF,EAIEC,wBAJF,EAMEC,iBANF,QAOO,aAPP;AAQA,SAASC,gBAAT,QAAiC,UAAjC;AAGA,SAASC,qBAAT,QAAsC,SAAtC;AAyDA,OAAM,SAAUC,oBAAV,CAA+BC,EAA/B,EAAyC;EAC7C,MAAM,CAACC,YAAD,EAAeC,iBAAf,EAAkCC,cAAlC,IAAoDH,EAAE,CAACI,KAAH,CAAS,OAAT,CAA1D;EACA,MAAMC,SAAS,GAAGC,eAAe,CAACL,YAAD,EAAeC,iBAAf,EAAkCC,cAAlC,CAAjC;EACA,OAAOE,SAAP;AACD;AASD,OAAM,SAAUE,cAAV,CACJC,OADI,EAEJC,iBAFI,EAGJC,cAHI,EAGmB;EAEvB,MAAMC,YAAY,GAAGF,iBAAiB,IAAI,CAA1C;EACA,MAAMG,SAAS,GAAGF,cAAc,IAAIhB,uBAApC;;EACA,IAAII,qBAAqB,CAACU,OAAD,EAAUI,SAAV,CAAzB,EAA+C;IAC7C,MAAM,IAAIC,KAAJ,CAAU,uCAAuCD,SAAS,CAACE,QAAV,EAAoB,EAArE,CAAN;EACD;;EACD,OAAO;IACLC,IAAI,EAAEnB,iBAAiB,CAACoB,oBADnB;IAELR,OAFK;IAGLC,iBAAiB,EAAEE,YAHd;IAILD,cAAc,EAAEE;EAJX,CAAP;AAMD;AAED,OAAM,SAAUN,eAAV,CACJW,aADI,EAEJC,YAFI,EAGJC,SAHI,EAGa;EAEjB,OAAO;IACLJ,IAAI,EAAEnB,iBAAiB,CAACwB,SADnB;IAELC,OAAO,EAAEC,aAAa,CAACL,aAAD,CAFjB;IAGLC,YAAY,EAAEX,cAAc,CAACW,YAAD,CAHvB;IAILC,SAAS,EAAEZ,cAAc,CAACY,SAAD;EAJpB,CAAP;AAMD;AAED,OAAM,SAAUG,aAAV,CAAwBC,gBAAxB,EAAgD;EACpD,MAAMC,WAAW,GAAG3B,gBAAgB,CAAC0B,gBAAD,CAApC;EACA,OAAO;IACLR,IAAI,EAAEnB,iBAAiB,CAAC6B,OADnB;IAELC,OAAO,EAAEF,WAAW,CAAC,CAAD,CAFf;IAGLG,OAAO,EAAEH,WAAW,CAAC,CAAD;EAHf,CAAP;AAKD;AAQD,OAAM,SAAUI,oBAAV,CACJC,eADI,EACmB;EAEvB,IAAIA,eAAe,CAACC,QAAhB,CAAyB,GAAzB,CAAJ,EAAmC;IACjC,MAAM,CAACT,OAAD,EAAUH,YAAV,IAA0BW,eAAe,CAACzB,KAAhB,CAAsB,GAAtB,CAAhC;IACA,OAAO2B,uBAAuB,CAACV,OAAD,EAAUH,YAAV,CAA9B;EACD,CAHD,MAGO;IACL,OAAOc,uBAAuB,CAACH,eAAD,CAA9B;EACD;AACF;AAED,OAAM,SAAUE,uBAAV,CACJd,aADI,EAEJC,YAFI,EAEgB;EAEpB,MAAMe,IAAI,GAAGX,aAAa,CAACL,aAAD,CAA1B;EACA,MAAMiB,IAAI,GAAG3B,cAAc,CAACW,YAAD,CAA3B;EACA,OAAO;IACLH,IAAI,EAAEnB,iBAAiB,CAACuC,SADnB;IAELC,MAAM,EAAEzC,wBAAwB,CAAC0C,QAF5B;IAGLhB,OAAO,EAAEY,IAHJ;IAILf,YAAY,EAAEgB;EAJT,CAAP;AAMD;AAED,OAAM,SAAUF,uBAAV,CAAkCf,aAAlC,EAAuD;EAC3D,MAAMgB,IAAI,GAAGX,aAAa,CAACL,aAAD,CAA1B;EACA,OAAO;IACLF,IAAI,EAAEnB,iBAAiB,CAACuC,SADnB;IAELC,MAAM,EAAEzC,wBAAwB,CAAC2C,QAF5B;IAGLjB,OAAO,EAAEY;EAHJ,CAAP;AAKD","names":["MAX_STRING_LENGTH_BYTES","PostConditionPrincipalID","StacksMessageType","c32addressDecode","exceedsMaxLengthBytes","parseAssetInfoString","id","assetAddress","assetContractName","assetTokenName","split","assetInfo","createAssetInfo","createLPString","content","lengthPrefixBytes","maxLengthBytes","prefixLength","maxLength","Error","toString","type","LengthPrefixedString","addressString","contractName","assetName","AssetInfo","address","createAddress","c32AddressString","addressData","Address","version","hash160","parsePrincipalString","principalString","includes","createContractPrincipal","createStandardPrincipal","addr","name","Principal","prefix","Contract","Standard"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\connect-react\\node_modules\\@stacks\\transactions\\src\\postcondition-types.ts"],"sourcesContent":["import {\n  FungibleConditionCode,\n  MAX_STRING_LENGTH_BYTES,\n  NonFungibleConditionCode,\n  PostConditionPrincipalID,\n  PostConditionType,\n  StacksMessageType,\n} from './constants';\nimport { c32addressDecode } from 'c32check';\nimport { Address } from './common';\nimport { ClarityValue } from './clarity';\nimport { exceedsMaxLengthBytes } from './utils';\n\nexport interface StandardPrincipal {\n  readonly type: StacksMessageType.Principal;\n  readonly prefix: PostConditionPrincipalID.Standard;\n  readonly address: Address;\n}\n\nexport interface ContractPrincipal {\n  readonly type: StacksMessageType.Principal;\n  readonly prefix: PostConditionPrincipalID.Contract;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n}\n\nexport interface LengthPrefixedString {\n  readonly type: StacksMessageType.LengthPrefixedString;\n  readonly content: string;\n  readonly lengthPrefixBytes: number;\n  readonly maxLengthBytes: number;\n}\n\nexport interface AssetInfo {\n  readonly type: StacksMessageType.AssetInfo;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n  readonly assetName: LengthPrefixedString;\n}\n\nexport interface STXPostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.STX;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: FungibleConditionCode;\n  readonly amount: bigint;\n}\n\nexport interface FungiblePostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.Fungible;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: FungibleConditionCode;\n  readonly amount: bigint;\n  readonly assetInfo: AssetInfo;\n}\n\nexport interface NonFungiblePostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.NonFungible;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: NonFungibleConditionCode;\n  /** Structure that identifies the token type. */\n  readonly assetInfo: AssetInfo;\n  /** The Clarity value that names the token instance. */\n  readonly assetName: ClarityValue;\n}\n\nexport function parseAssetInfoString(id: string): AssetInfo {\n  const [assetAddress, assetContractName, assetTokenName] = id.split(/\\.|::/);\n  const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);\n  return assetInfo;\n}\n\nexport function createLPString(content: string): LengthPrefixedString;\nexport function createLPString(content: string, lengthPrefixBytes: number): LengthPrefixedString;\nexport function createLPString(\n  content: string,\n  lengthPrefixBytes: number,\n  maxLengthBytes: number\n): LengthPrefixedString;\nexport function createLPString(\n  content: string,\n  lengthPrefixBytes?: number,\n  maxLengthBytes?: number\n): LengthPrefixedString {\n  const prefixLength = lengthPrefixBytes || 1;\n  const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;\n  if (exceedsMaxLengthBytes(content, maxLength)) {\n    throw new Error(`String length exceeds maximum bytes ${maxLength.toString()}`);\n  }\n  return {\n    type: StacksMessageType.LengthPrefixedString,\n    content,\n    lengthPrefixBytes: prefixLength,\n    maxLengthBytes: maxLength,\n  };\n}\n\nexport function createAssetInfo(\n  addressString: string,\n  contractName: string,\n  assetName: string\n): AssetInfo {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: createAddress(addressString),\n    contractName: createLPString(contractName),\n    assetName: createLPString(assetName),\n  };\n}\n\nexport function createAddress(c32AddressString: string): Address {\n  const addressData = c32addressDecode(c32AddressString);\n  return {\n    type: StacksMessageType.Address,\n    version: addressData[0],\n    hash160: addressData[1],\n  };\n}\n\n/**\n * Parses a principal string for either a standard principal or contract principal.\n * @param principalString - String in the format `{address}.{contractName}`\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G.example-contract\"\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G\"\n */\nexport function parsePrincipalString(\n  principalString: string\n): StandardPrincipal | ContractPrincipal {\n  if (principalString.includes('.')) {\n    const [address, contractName] = principalString.split('.');\n    return createContractPrincipal(address, contractName);\n  } else {\n    return createStandardPrincipal(principalString);\n  }\n}\n\nexport function createContractPrincipal(\n  addressString: string,\n  contractName: string\n): ContractPrincipal {\n  const addr = createAddress(addressString);\n  const name = createLPString(contractName);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Contract,\n    address: addr,\n    contractName: name,\n  };\n}\n\nexport function createStandardPrincipal(addressString: string): StandardPrincipal {\n  const addr = createAddress(addressString);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Standard,\n    address: addr,\n  };\n}\n\nexport type PostCondition = STXPostCondition | FungiblePostCondition | NonFungiblePostCondition;\n\nexport type PostConditionPrincipal = StandardPrincipal | ContractPrincipal;\n"]},"metadata":{},"sourceType":"module"}