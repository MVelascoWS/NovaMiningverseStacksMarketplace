{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { ClarityType, intCV, uintCV, bufferCV, trueCV, falseCV, standardPrincipalCVFromAddress, contractPrincipalCVFromAddress, responseOkCV, responseErrorCV, noneCV, someCV, listCV, tupleCV } from '.';\nimport { BufferReader } from '../bufferReader';\nimport { deserializeAddress, deserializeLPString } from '../types';\nimport { DeserializationError } from '../errors';\nimport { stringAsciiCV, stringUtf8CV } from './types/stringCV';\nexport default function deserializeCV(serializedClarityValue) {\n  let bufferReader;\n\n  if (typeof serializedClarityValue === 'string') {\n    const hasHexPrefix = serializedClarityValue.slice(0, 2).toLowerCase() === '0x';\n    bufferReader = new BufferReader(Buffer.from(hasHexPrefix ? serializedClarityValue.slice(2) : serializedClarityValue, 'hex'));\n  } else if (Buffer.isBuffer(serializedClarityValue)) {\n    bufferReader = new BufferReader(serializedClarityValue);\n  } else {\n    bufferReader = serializedClarityValue;\n  }\n\n  const type = bufferReader.readUInt8Enum(ClarityType, n => {\n    throw new DeserializationError(`Cannot recognize Clarity Type: ${n}`);\n  });\n\n  switch (type) {\n    case ClarityType.Int:\n      return intCV(bufferReader.readBuffer(16));\n\n    case ClarityType.UInt:\n      return uintCV(bufferReader.readBuffer(16));\n\n    case ClarityType.Buffer:\n      const bufferLength = bufferReader.readUInt32BE();\n      return bufferCV(bufferReader.readBuffer(bufferLength));\n\n    case ClarityType.BoolTrue:\n      return trueCV();\n\n    case ClarityType.BoolFalse:\n      return falseCV();\n\n    case ClarityType.PrincipalStandard:\n      const sAddress = deserializeAddress(bufferReader);\n      return standardPrincipalCVFromAddress(sAddress);\n\n    case ClarityType.PrincipalContract:\n      const cAddress = deserializeAddress(bufferReader);\n      const contractName = deserializeLPString(bufferReader);\n      return contractPrincipalCVFromAddress(cAddress, contractName);\n\n    case ClarityType.ResponseOk:\n      return responseOkCV(deserializeCV(bufferReader));\n\n    case ClarityType.ResponseErr:\n      return responseErrorCV(deserializeCV(bufferReader));\n\n    case ClarityType.OptionalNone:\n      return noneCV();\n\n    case ClarityType.OptionalSome:\n      return someCV(deserializeCV(bufferReader));\n\n    case ClarityType.List:\n      const listLength = bufferReader.readUInt32BE();\n      const listContents = [];\n\n      for (let i = 0; i < listLength; i++) {\n        listContents.push(deserializeCV(bufferReader));\n      }\n\n      return listCV(listContents);\n\n    case ClarityType.Tuple:\n      const tupleLength = bufferReader.readUInt32BE();\n      const tupleContents = {};\n\n      for (let i = 0; i < tupleLength; i++) {\n        const clarityName = deserializeLPString(bufferReader).content;\n\n        if (clarityName === undefined) {\n          throw new DeserializationError('\"content\" is undefined');\n        }\n\n        tupleContents[clarityName] = deserializeCV(bufferReader);\n      }\n\n      return tupleCV(tupleContents);\n\n    case ClarityType.StringASCII:\n      const asciiStrLen = bufferReader.readUInt32BE();\n      const asciiStr = bufferReader.readBuffer(asciiStrLen).toString('ascii');\n      return stringAsciiCV(asciiStr);\n\n    case ClarityType.StringUTF8:\n      const utf8StrLen = bufferReader.readUInt32BE();\n      const utf8Str = bufferReader.readBuffer(utf8StrLen).toString('utf8');\n      return stringUtf8CV(utf8Str);\n\n    default:\n      throw new DeserializationError('Unable to deserialize Clarity Value from buffer. Could not find valid Clarity Type.');\n  }\n}","map":{"version":3,"mappings":"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","names":["Buffer","ClarityType","intCV","uintCV","bufferCV","trueCV","falseCV","standardPrincipalCVFromAddress","contractPrincipalCVFromAddress","responseOkCV","responseErrorCV","noneCV","someCV","listCV","tupleCV","BufferReader","deserializeAddress","deserializeLPString","DeserializationError","stringAsciiCV","stringUtf8CV","deserializeCV","serializedClarityValue","bufferReader","hasHexPrefix","slice","toLowerCase","from","isBuffer","type","readUInt8Enum","n","Int","readBuffer","UInt","bufferLength","readUInt32BE","BoolTrue","BoolFalse","PrincipalStandard","sAddress","PrincipalContract","cAddress","contractName","ResponseOk","ResponseErr","OptionalNone","OptionalSome","List","listLength","listContents","i","push","Tuple","tupleLength","tupleContents","clarityName","content","undefined","StringASCII","asciiStrLen","asciiStr","toString","StringUTF8","utf8StrLen","utf8Str"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\transactions\\src\\clarity\\deserialize.ts"],"sourcesContent":["import { Buffer } from '@stacks/common';\nimport {\n  ClarityType,\n  ClarityValue,\n  intCV,\n  uintCV,\n  bufferCV,\n  trueCV,\n  falseCV,\n  standardPrincipalCVFromAddress,\n  contractPrincipalCVFromAddress,\n  responseOkCV,\n  responseErrorCV,\n  noneCV,\n  someCV,\n  listCV,\n  tupleCV,\n} from '.';\nimport { BufferReader } from '../bufferReader';\nimport { deserializeAddress, deserializeLPString } from '../types';\nimport { DeserializationError } from '../errors';\nimport { stringAsciiCV, stringUtf8CV } from './types/stringCV';\n\n/**\n * Deserializes clarity value to clarity type\n *\n * @param {value} Buffer | string value to be converted to clarity type\n **\n * @returns {ClarityType} returns the clarity type instance\n *\n * @example\n * ```\n *  import { intCV, serializeCV, deserializeCV } from '@stacks/transactions';\n *\n *  const serialized = serializeCV(intCV(100)); // Similarly works for other clarity types as well like listCV, booleanCV ...\n *\n *  // <Buffer 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 64>\n *\n *  const deserialized = deserializeCV(serialized);\n *  // { type: 0, value: 100n }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nexport default function deserializeCV<T extends ClarityValue = ClarityValue>(\n  serializedClarityValue: BufferReader | Buffer | string\n): T {\n  let bufferReader: BufferReader;\n  if (typeof serializedClarityValue === 'string') {\n    const hasHexPrefix = serializedClarityValue.slice(0, 2).toLowerCase() === '0x';\n    bufferReader = new BufferReader(\n      Buffer.from(hasHexPrefix ? serializedClarityValue.slice(2) : serializedClarityValue, 'hex')\n    );\n  } else if (Buffer.isBuffer(serializedClarityValue)) {\n    bufferReader = new BufferReader(serializedClarityValue);\n  } else {\n    bufferReader = serializedClarityValue;\n  }\n  const type = bufferReader.readUInt8Enum(ClarityType, n => {\n    throw new DeserializationError(`Cannot recognize Clarity Type: ${n}`);\n  });\n\n  switch (type) {\n    case ClarityType.Int:\n      return intCV(bufferReader.readBuffer(16)) as T;\n\n    case ClarityType.UInt:\n      return uintCV(bufferReader.readBuffer(16)) as T;\n\n    case ClarityType.Buffer:\n      const bufferLength = bufferReader.readUInt32BE();\n      return bufferCV(bufferReader.readBuffer(bufferLength)) as T;\n\n    case ClarityType.BoolTrue:\n      return trueCV() as T;\n\n    case ClarityType.BoolFalse:\n      return falseCV() as T;\n\n    case ClarityType.PrincipalStandard:\n      const sAddress = deserializeAddress(bufferReader);\n      return standardPrincipalCVFromAddress(sAddress) as T;\n\n    case ClarityType.PrincipalContract:\n      const cAddress = deserializeAddress(bufferReader);\n      const contractName = deserializeLPString(bufferReader);\n      return contractPrincipalCVFromAddress(cAddress, contractName) as T;\n\n    case ClarityType.ResponseOk:\n      return responseOkCV(deserializeCV(bufferReader)) as T;\n\n    case ClarityType.ResponseErr:\n      return responseErrorCV(deserializeCV(bufferReader)) as T;\n\n    case ClarityType.OptionalNone:\n      return noneCV() as T;\n\n    case ClarityType.OptionalSome:\n      return someCV(deserializeCV(bufferReader)) as T;\n\n    case ClarityType.List:\n      const listLength = bufferReader.readUInt32BE();\n      const listContents: ClarityValue[] = [];\n      for (let i = 0; i < listLength; i++) {\n        listContents.push(deserializeCV(bufferReader));\n      }\n      return listCV(listContents) as T;\n\n    case ClarityType.Tuple:\n      const tupleLength = bufferReader.readUInt32BE();\n      const tupleContents: { [key: string]: ClarityValue } = {};\n      for (let i = 0; i < tupleLength; i++) {\n        const clarityName = deserializeLPString(bufferReader).content;\n        if (clarityName === undefined) {\n          throw new DeserializationError('\"content\" is undefined');\n        }\n        tupleContents[clarityName] = deserializeCV(bufferReader);\n      }\n      return tupleCV(tupleContents) as T;\n\n    case ClarityType.StringASCII:\n      const asciiStrLen = bufferReader.readUInt32BE();\n      const asciiStr = bufferReader.readBuffer(asciiStrLen).toString('ascii');\n      return stringAsciiCV(asciiStr) as T;\n\n    case ClarityType.StringUTF8:\n      const utf8StrLen = bufferReader.readUInt32BE();\n      const utf8Str = bufferReader.readBuffer(utf8StrLen).toString('utf8');\n      return stringUtf8CV(utf8Str) as T;\n\n    default:\n      throw new DeserializationError(\n        'Unable to deserialize Clarity Value from buffer. Could not find valid Clarity Type.'\n      );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}