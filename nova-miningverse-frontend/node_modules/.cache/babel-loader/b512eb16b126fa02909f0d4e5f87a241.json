{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport Ripemd160Polyfill from 'ripemd160-min';\nexport class Ripemd160PolyfillDigest {\n  digest(data) {\n    const instance = new Ripemd160Polyfill();\n    instance.update(data);\n    const hash = instance.digest();\n\n    if (Array.isArray(hash)) {\n      return Buffer.from(hash);\n    } else {\n      return Buffer.from(hash.buffer);\n    }\n  }\n\n}\nexport class NodeCryptoRipemd160Digest {\n  constructor(nodeCryptoCreateHash) {\n    this.nodeCryptoCreateHash = nodeCryptoCreateHash;\n  }\n\n  digest(data) {\n    try {\n      return this.nodeCryptoCreateHash('rmd160').update(data).digest();\n    } catch (error) {\n      try {\n        return this.nodeCryptoCreateHash('ripemd160').update(data).digest();\n      } catch (_err) {\n        console.log(error);\n        console.log('Node.js `crypto.createHash` exists but failing to digest for ripemd160, falling back to js implementation');\n        const polyfill = new Ripemd160PolyfillDigest();\n        return polyfill.digest(data);\n      }\n    }\n  }\n\n}\nexport function createHashRipemd160() {\n  return new Ripemd160PolyfillDigest();\n}\nexport function hashRipemd160(data) {\n  const hash = createHashRipemd160();\n  return hash.digest(data);\n}","map":{"version":3,"mappings":"AAAA,SAASA,MAAT,QAAuB,gBAAvB;AACA,OAAOC,iBAAP,MAA8B,eAA9B;AAQA,OAAM,MAAOC,uBAAP,CAA8B;EAClCC,MAAM,CAACC,IAAD,EAAa;IACjB,MAAMC,QAAQ,GAAG,IAAIJ,iBAAJ,EAAjB;IACAI,QAAQ,CAACC,MAAT,CAAgBF,IAAhB;IACA,MAAMG,IAAI,GAAGF,QAAQ,CAACF,MAAT,EAAb;;IACA,IAAIK,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAJ,EAAyB;MACvB,OAAOP,MAAM,CAACU,IAAP,CAAYH,IAAZ,CAAP;IACD,CAFD,MAEO;MACL,OAAOP,MAAM,CAACU,IAAP,CAAYH,IAAI,CAACI,MAAjB,CAAP;IACD;EACF;;AAViC;AAapC,OAAM,MAAOC,yBAAP,CAAgC;EAGpCC,YAAYC,oBAAZ,EAAsD;IACpD,KAAKA,oBAAL,GAA4BA,oBAA5B;EACD;;EAEDX,MAAM,CAACC,IAAD,EAAa;IACjB,IAAI;MACF,OAAO,KAAKU,oBAAL,CAA0B,QAA1B,EAAoCR,MAApC,CAA2CF,IAA3C,EAAiDD,MAAjD,EAAP;IACD,CAFD,CAEE,OAAOY,KAAP,EAAc;MACd,IAAI;QACF,OAAO,KAAKD,oBAAL,CAA0B,WAA1B,EAAuCR,MAAvC,CAA8CF,IAA9C,EAAoDD,MAApD,EAAP;MACD,CAFD,CAEE,OAAOa,IAAP,EAAa;QACbC,OAAO,CAACC,GAAR,CAAYH,KAAZ;QACAE,OAAO,CAACC,GAAR,CACE,2GADF;QAGA,MAAMC,QAAQ,GAAG,IAAIjB,uBAAJ,EAAjB;QACA,OAAOiB,QAAQ,CAAChB,MAAT,CAAgBC,IAAhB,CAAP;MACD;IACF;EACF;;AAtBmC;AAyBtC,OAAM,SAAUgB,mBAAV,GAA6B;EAWjC,OAAO,IAAIlB,uBAAJ,EAAP;AACD;AAED,OAAM,SAAUmB,aAAV,CAAwBjB,IAAxB,EAAoC;EACxC,MAAMG,IAAI,GAAGa,mBAAmB,EAAhC;EACA,OAAOb,IAAI,CAACJ,MAAL,CAAYC,IAAZ,CAAP;AACD","names":["Buffer","Ripemd160Polyfill","Ripemd160PolyfillDigest","digest","data","instance","update","hash","Array","isArray","from","buffer","NodeCryptoRipemd160Digest","constructor","nodeCryptoCreateHash","error","_err","console","log","polyfill","createHashRipemd160","hashRipemd160"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\encryption\\src\\hashRipemd160.ts"],"sourcesContent":["import { Buffer } from '@stacks/common';\nimport Ripemd160Polyfill from 'ripemd160-min';\n\ntype NodeCryptoCreateHash = typeof import('crypto').createHash;\n\nexport interface Ripemd160Digest {\n  digest(data: Buffer): Buffer;\n}\n\nexport class Ripemd160PolyfillDigest implements Ripemd160Digest {\n  digest(data: Buffer): Buffer {\n    const instance = new Ripemd160Polyfill();\n    instance.update(data);\n    const hash = instance.digest();\n    if (Array.isArray(hash)) {\n      return Buffer.from(hash);\n    } else {\n      return Buffer.from(hash.buffer);\n    }\n  }\n}\n\nexport class NodeCryptoRipemd160Digest implements Ripemd160Digest {\n  nodeCryptoCreateHash: NodeCryptoCreateHash;\n\n  constructor(nodeCryptoCreateHash: NodeCryptoCreateHash) {\n    this.nodeCryptoCreateHash = nodeCryptoCreateHash;\n  }\n\n  digest(data: Buffer): Buffer {\n    try {\n      return this.nodeCryptoCreateHash('rmd160').update(data).digest();\n    } catch (error) {\n      try {\n        return this.nodeCryptoCreateHash('ripemd160').update(data).digest();\n      } catch (_err) {\n        console.log(error);\n        console.log(\n          'Node.js `crypto.createHash` exists but failing to digest for ripemd160, falling back to js implementation'\n        );\n        const polyfill = new Ripemd160PolyfillDigest();\n        return polyfill.digest(data);\n      }\n    }\n  }\n}\n\nexport function createHashRipemd160() {\n  // // disable node hashRipemd160, because it doesn't work with node 17,18 openSSL\n  // const nodeCryptoCreateHash = isNodeCryptoAvailable(nodeCrypto => {\n  //   if (typeof nodeCrypto.createHash === 'function') {\n  //     return nodeCrypto.createHash;\n  //   }\n  //   return false;\n  // });\n  // if (nodeCryptoCreateHash) {\n  //   return new NodeCryptoRipemd160Digest(nodeCryptoCreateHash);\n  // } else {\n  return new Ripemd160PolyfillDigest();\n}\n\nexport function hashRipemd160(data: Buffer) {\n  const hash = createHashRipemd160();\n  return hash.digest(data);\n}\n"]},"metadata":{},"sourceType":"module"}