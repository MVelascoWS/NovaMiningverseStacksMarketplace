{"ast":null,"code":"import { AddressHashMode, AddressVersion, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType, TransactionVersion } from './constants';\nimport { Buffer } from '@stacks/common';\nimport { c32address } from 'c32check';\nexport function createMessageSignature(signature) {\n  const length = Buffer.from(signature, 'hex').byteLength;\n\n  if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {\n    throw Error('Invalid signature');\n  }\n\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: signature\n  };\n}\nexport function addressHashModeToVersion(hashMode, txVersion) {\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetSingleSig;\n\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetSingleSig;\n\n        default:\n          throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);\n      }\n\n    case AddressHashMode.SerializeP2SH:\n    case AddressHashMode.SerializeP2WPKH:\n    case AddressHashMode.SerializeP2WSH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetMultiSig;\n\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetMultiSig;\n\n        default:\n          throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);\n      }\n\n    default:\n      throw new Error(`Unexpected hashMode ${JSON.stringify(hashMode)}`);\n  }\n}\nexport function addressFromVersionHash(version, hash) {\n  return {\n    type: StacksMessageType.Address,\n    version,\n    hash160: hash\n  };\n}\nexport function addressToString(address) {\n  return c32address(address.version, address.hash160).toString();\n}","map":{"version":3,"mappings":"AAAA,SACEA,eADF,EAEEC,cAFF,EAGEC,kCAHF,EAIEC,iBAJF,EAKEC,kBALF,QAMO,aANP;AAOA,SAASC,MAAT,QAAuB,gBAAvB;AACA,SAASC,UAAT,QAA2B,UAA3B;AAaA,OAAM,SAAUC,sBAAV,CAAiCC,SAAjC,EAAkD;EACtD,MAAMC,MAAM,GAAGJ,MAAM,CAACK,IAAP,CAAYF,SAAZ,EAAuB,KAAvB,EAA8BG,UAA7C;;EACA,IAAIF,MAAM,IAAIP,kCAAd,EAAkD;IAChD,MAAMU,KAAK,CAAC,mBAAD,CAAX;EACD;;EAED,OAAO;IACLC,IAAI,EAAEV,iBAAiB,CAACW,gBADnB;IAELC,IAAI,EAAEP;EAFD,CAAP;AAID;AAMD,OAAM,SAAUQ,wBAAV,CACJC,QADI,EAEJC,SAFI,EAEyB;EAE7B,QAAQD,QAAR;IACE,KAAKjB,eAAe,CAACmB,cAArB;MACE,QAAQD,SAAR;QACE,KAAKd,kBAAkB,CAACgB,OAAxB;UACE,OAAOnB,cAAc,CAACoB,gBAAtB;;QACF,KAAKjB,kBAAkB,CAACkB,OAAxB;UACE,OAAOrB,cAAc,CAACsB,gBAAtB;;QACF;UACE,MAAM,IAAIX,KAAJ,CACJ,wBAAwBY,IAAI,CAACC,SAAL,CAAeP,SAAf,CAAyB,iBAAiBD,QAAQ,EADtE,CAAN;MANJ;;IAUF,KAAKjB,eAAe,CAAC0B,aAArB;IACA,KAAK1B,eAAe,CAAC2B,eAArB;IACA,KAAK3B,eAAe,CAAC4B,cAArB;MACE,QAAQV,SAAR;QACE,KAAKd,kBAAkB,CAACgB,OAAxB;UACE,OAAOnB,cAAc,CAAC4B,eAAtB;;QACF,KAAKzB,kBAAkB,CAACkB,OAAxB;UACE,OAAOrB,cAAc,CAAC6B,eAAtB;;QACF;UACE,MAAM,IAAIlB,KAAJ,CACJ,wBAAwBY,IAAI,CAACC,SAAL,CAAeP,SAAf,CAAyB,iBAAiBD,QAAQ,EADtE,CAAN;MANJ;;IAUF;MACE,MAAM,IAAIL,KAAJ,CAAU,uBAAuBY,IAAI,CAACC,SAAL,CAAeR,QAAf,CAAwB,EAAzD,CAAN;EA1BJ;AA4BD;AAED,OAAM,SAAUc,sBAAV,CAAiCC,OAAjC,EAA0DC,IAA1D,EAAsE;EAC1E,OAAO;IAAEpB,IAAI,EAAEV,iBAAiB,CAAC+B,OAA1B;IAAmCF,OAAnC;IAA4CG,OAAO,EAAEF;EAArD,CAAP;AACD;AAED,OAAM,SAAUG,eAAV,CAA0BC,OAA1B,EAA0C;EAC9C,OAAO/B,UAAU,CAAC+B,OAAO,CAACL,OAAT,EAAkBK,OAAO,CAACF,OAA1B,CAAV,CAA6CG,QAA7C,EAAP;AACD","names":["AddressHashMode","AddressVersion","RECOVERABLE_ECDSA_SIG_LENGTH_BYTES","StacksMessageType","TransactionVersion","Buffer","c32address","createMessageSignature","signature","length","from","byteLength","Error","type","MessageSignature","data","addressHashModeToVersion","hashMode","txVersion","SerializeP2PKH","Mainnet","MainnetSingleSig","Testnet","TestnetSingleSig","JSON","stringify","SerializeP2SH","SerializeP2WPKH","SerializeP2WSH","MainnetMultiSig","TestnetMultiSig","addressFromVersionHash","version","hash","Address","hash160","addressToString","address","toString"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\transactions\\src\\common.ts"],"sourcesContent":["import {\n  AddressHashMode,\n  AddressVersion,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  StacksMessageType,\n  TransactionVersion,\n} from './constants';\nimport { Buffer } from '@stacks/common';\nimport { c32address } from 'c32check';\n\nexport interface Address {\n  readonly type: StacksMessageType.Address;\n  readonly version: AddressVersion;\n  readonly hash160: string;\n}\n\nexport interface MessageSignature {\n  readonly type: StacksMessageType.MessageSignature;\n  data: string;\n}\n\nexport function createMessageSignature(signature: string): MessageSignature {\n  const length = Buffer.from(signature, 'hex').byteLength;\n  if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {\n    throw Error('Invalid signature');\n  }\n\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: signature,\n  };\n}\n\n/**\n * Translates the tx auth hash mode to the corresponding address version.\n * @see https://github.com/blockstack/stacks-blockchain/blob/master/sip/sip-005-blocks-and-transactions.md#transaction-authorization\n */\nexport function addressHashModeToVersion(\n  hashMode: AddressHashMode,\n  txVersion: TransactionVersion\n): AddressVersion {\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetSingleSig;\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetSingleSig;\n        default:\n          throw new Error(\n            `Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`\n          );\n      }\n    case AddressHashMode.SerializeP2SH:\n    case AddressHashMode.SerializeP2WPKH:\n    case AddressHashMode.SerializeP2WSH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetMultiSig;\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetMultiSig;\n        default:\n          throw new Error(\n            `Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`\n          );\n      }\n    default:\n      throw new Error(`Unexpected hashMode ${JSON.stringify(hashMode)}`);\n  }\n}\n\nexport function addressFromVersionHash(version: AddressVersion, hash: string): Address {\n  return { type: StacksMessageType.Address, version, hash160: hash };\n}\n\nexport function addressToString(address: Address): string {\n  return c32address(address.version, address.hash160).toString();\n}\n"]},"metadata":{},"sourceType":"module"}