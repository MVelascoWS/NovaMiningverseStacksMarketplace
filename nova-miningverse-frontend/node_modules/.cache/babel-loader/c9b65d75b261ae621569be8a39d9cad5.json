{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenVerifier = void 0;\n\nconst base64url_1 = require(\"base64url\");\n\nconst cryptoClients_1 = require(\"./cryptoClients\");\n\nconst errors_1 = require(\"./errors\");\n\nconst sha256_1 = require(\"./cryptoClients/sha256\");\n\nclass TokenVerifier {\n  constructor(signingAlgorithm, rawPublicKey) {\n    if (!(signingAlgorithm && rawPublicKey)) {\n      throw new errors_1.MissingParametersError('a signing algorithm and public key are required');\n    }\n\n    if (typeof signingAlgorithm !== 'string') {\n      throw 'signing algorithm parameter must be a string';\n    }\n\n    signingAlgorithm = signingAlgorithm.toUpperCase();\n\n    if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n      throw 'invalid signing algorithm';\n    }\n\n    this.tokenType = 'JWT';\n    this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n    this.rawPublicKey = rawPublicKey;\n  }\n\n  verify(token) {\n    if (typeof token === 'string') {\n      return this.verifyCompact(token, false);\n    } else if (typeof token === 'object') {\n      return this.verifyExpanded(token, false);\n    } else {\n      return false;\n    }\n  }\n\n  verifyAsync(token) {\n    if (typeof token === 'string') {\n      return this.verifyCompact(token, true);\n    } else if (typeof token === 'object') {\n      return this.verifyExpanded(token, true);\n    } else {\n      return Promise.resolve(false);\n    }\n  }\n\n  verifyCompact(token, async) {\n    // decompose the token into parts\n    const tokenParts = token.split('.'); // calculate the signing input hash\n\n    const signingInput = tokenParts[0] + '.' + tokenParts[1];\n\n    const performVerify = signingInputHash => {\n      // extract the signature as a DER array\n      const derSignatureBuffer = this.cryptoClient.loadSignature(tokenParts[2]); // verify the signed hash\n\n      return this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, this.rawPublicKey);\n    };\n\n    if (async) {\n      return (0, sha256_1.hashSha256Async)(signingInput).then(signingInputHash => performVerify(signingInputHash));\n    } else {\n      const signingInputHash = (0, sha256_1.hashSha256)(signingInput);\n      return performVerify(signingInputHash);\n    }\n  }\n\n  verifyExpanded(token, async) {\n    const signingInput = [token['header'].join('.'), base64url_1.default.encode(token['payload'])].join('.');\n    let verified = true;\n\n    const performVerify = signingInputHash => {\n      token['signature'].map(signature => {\n        const derSignatureBuffer = this.cryptoClient.loadSignature(signature);\n        const signatureVerified = this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, this.rawPublicKey);\n\n        if (!signatureVerified) {\n          verified = false;\n        }\n      });\n      return verified;\n    };\n\n    if (async) {\n      return (0, sha256_1.hashSha256Async)(signingInput).then(signingInputHash => performVerify(signingInputHash));\n    } else {\n      const signingInputHash = (0, sha256_1.hashSha256)(signingInput);\n      return performVerify(signingInputHash);\n    }\n  }\n\n}\n\nexports.TokenVerifier = TokenVerifier;","map":{"version":3,"mappings":"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","names":["TokenVerifier","constructor","signingAlgorithm","rawPublicKey","errors_1","toUpperCase","cryptoClients_1","hasOwnProperty","tokenType","cryptoClient","verify","token","verifyCompact","verifyExpanded","verifyAsync","Promise","resolve","async","tokenParts","split","signingInput","performVerify","signingInputHash","derSignatureBuffer","loadSignature","verifyHash","then","join","base64url_1","encode","verified","map","signature","signatureVerified","exports"],"sources":["verifier.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}