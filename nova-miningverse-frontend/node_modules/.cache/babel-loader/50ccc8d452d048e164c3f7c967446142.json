{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SECP256K1Client = void 0;\n\nconst hmac_1 = require(\"@noble/hashes/hmac\");\n\nconst sha256_1 = require(\"@noble/hashes/sha256\");\n\nconst secp = require(\"@noble/secp256k1\");\n\nconst ecdsa_sig_formatter_1 = require(\"ecdsa-sig-formatter\");\n\nconst errors_1 = require(\"../errors\"); // required to use noble secp https://github.com/paulmillr/noble-secp256k1\n\n\nsecp.utils.hmacSha256Sync = function (key) {\n  const h = hmac_1.hmac.create(sha256_1.sha256, key);\n\n  for (var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    msgs[_key - 1] = arguments[_key];\n  }\n\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\n\nclass SECP256K1Client {\n  static derivePublicKey(privateKey) {\n    let compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (privateKey.length === 66) {\n      privateKey = privateKey.slice(0, 64);\n    }\n\n    if (privateKey.length < 64) {\n      // backward compatibly accept too short private keys\n      privateKey = privateKey.padStart(64, '0');\n    }\n\n    return Buffer.from(secp.getPublicKey(privateKey, compressed)).toString('hex');\n  }\n\n  static signHash(signingInputHash, privateKey) {\n    let format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'jose';\n\n    // make sure the required parameters are provided\n    if (!signingInputHash || !privateKey) {\n      throw new errors_1.MissingParametersError('a signing input hash and private key are all required');\n    }\n\n    const derSignature = Buffer.from(secp.signSync(signingInputHash, privateKey.slice(0, 64), {\n      der: true,\n      canonical: false\n    }));\n    if (format === 'der') return derSignature.toString('hex');\n    if (format === 'jose') return (0, ecdsa_sig_formatter_1.derToJose)(derSignature, 'ES256');\n    throw Error('Invalid signature format');\n  }\n\n  static loadSignature(joseSignature) {\n    // create and return the DER-formatted signature buffer\n    return (0, ecdsa_sig_formatter_1.joseToDer)(joseSignature, 'ES256');\n  }\n\n  static verifyHash(signingInputHash, derSignatureBuffer, publicKey) {\n    // make sure the required parameters are provided\n    if (!signingInputHash || !derSignatureBuffer || !publicKey) {\n      throw new errors_1.MissingParametersError('a signing input hash, der signature, and public key are all required');\n    }\n\n    return secp.verify(derSignatureBuffer, signingInputHash, publicKey, {\n      strict: false\n    });\n  }\n\n}\n\nexports.SECP256K1Client = SECP256K1Client;\nSECP256K1Client.algorithmName = 'ES256K';","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA,sC,CAEA;;;AACAA,IAAI,CAACC,KAAL,CAAWC,cAAX,GAA4B,UAACC,GAAD,EAA2C;EACrE,MAAMC,CAAC,GAAGC,YAAKC,MAAL,CAAYC,eAAZ,EAAoBJ,GAApB,CAAV;;EADqE,kCAAtBK,IAAsB;IAAtBA,IAAsB;EAAA;;EAErEA,IAAI,CAACC,OAAL,CAAaC,GAAG,IAAIN,CAAC,CAACO,MAAF,CAASD,GAAT,CAApB;EACA,OAAON,CAAC,CAACQ,MAAF,EAAP;AACD,CAJD;;AAMA,MAAaC,eAAb,CAA4B;EAGJ,OAAfC,eAAe,CAACC,UAAD,EAAsC;IAAA,IAAjBC,UAAiB,uEAAJ,IAAI;;IAC1D,IAAID,UAAU,CAACE,MAAX,KAAsB,EAA1B,EAA8B;MAC5BF,UAAU,GAAGA,UAAU,CAACG,KAAX,CAAiB,CAAjB,EAAoB,EAApB,CAAb;IACD;;IACD,IAAIH,UAAU,CAACE,MAAX,GAAoB,EAAxB,EAA4B;MAC1B;MACAF,UAAU,GAAGA,UAAU,CAACI,QAAX,CAAoB,EAApB,EAAwB,GAAxB,CAAb;IACD;;IACD,OAAOC,MAAM,CAACC,IAAP,CAAYrB,IAAI,CAACsB,YAAL,CAAkBP,UAAlB,EAA8BC,UAA9B,CAAZ,EAAuDO,QAAvD,CAAgE,KAAhE,CAAP;EACD;;EAEc,OAARC,QAAQ,CAACC,gBAAD,EAAoCV,UAApC,EAAuE;IAAA,IAAfW,MAAe,uEAAN,MAAM;;IACpF;IACA,IAAI,CAACD,gBAAD,IAAqB,CAACV,UAA1B,EAAsC;MACpC,MAAM,IAAIY,+BAAJ,CAA2B,uDAA3B,CAAN;IACD;;IAED,MAAMC,YAAY,GAAGR,MAAM,CAACC,IAAP,CACnBrB,IAAI,CAAC6B,QAAL,CAAcJ,gBAAd,EAAgCV,UAAU,CAACG,KAAX,CAAiB,CAAjB,EAAoB,EAApB,CAAhC,EAAyD;MAAEY,GAAG,EAAE,IAAP;MAAaC,SAAS,EAAE;IAAxB,CAAzD,CADmB,CAArB;IAIA,IAAIL,MAAM,KAAK,KAAf,EAAsB,OAAOE,YAAY,CAACL,QAAb,CAAsB,KAAtB,CAAP;IACtB,IAAIG,MAAM,KAAK,MAAf,EAAuB,OAAO,qCAAUE,YAAV,EAAwB,OAAxB,CAAP;IAEvB,MAAMI,KAAK,CAAC,0BAAD,CAAX;EACD;;EAEmB,OAAbC,aAAa,CAACC,aAAD,EAA+B;IACjD;IACA,OAAO,qCAAUA,aAAV,EAAyB,OAAzB,CAAP;EACD;;EAEgB,OAAVC,UAAU,CACfV,gBADe,EAEfW,kBAFe,EAGfC,SAHe,EAGW;IAE1B;IACA,IAAI,CAACZ,gBAAD,IAAqB,CAACW,kBAAtB,IAA4C,CAACC,SAAjD,EAA4D;MAC1D,MAAM,IAAIV,+BAAJ,CACJ,sEADI,CAAN;IAGD;;IAED,OAAO3B,IAAI,CAACsC,MAAL,CAAYF,kBAAZ,EAAgCX,gBAAhC,EAAkDY,SAAlD,EAA6D;MAAEE,MAAM,EAAE;IAAV,CAA7D,CAAP;EACD;;AAhDyB;;AAA5BC;AACS3B,gCAAgB,QAAhB","names":["secp","utils","hmacSha256Sync","key","h","hmac_1","create","sha256_1","msgs","forEach","msg","update","digest","SECP256K1Client","derivePublicKey","privateKey","compressed","length","slice","padStart","Buffer","from","getPublicKey","toString","signHash","signingInputHash","format","errors_1","derSignature","signSync","der","canonical","Error","loadSignature","joseSignature","verifyHash","derSignatureBuffer","publicKey","verify","strict","exports"],"sources":["cryptoClients/secp256k1.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}