{"ast":null,"code":"import { extends as _extends, asyncToGenerator as _asyncToGenerator, objectWithoutPropertiesLoose as _objectWithoutPropertiesLoose } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport _regeneratorRuntime from 'regenerator-runtime';\nimport { createUnsecuredToken, TokenSigner } from 'jsontokens';\nimport { getStacksProvider } from '../utils.esm.js';\nimport { ChainID } from '@stacks/transactions';\nimport { StacksTestnet } from '@stacks/network';\nimport { getUserSession, hasAppPrivateKey, getKeys } from '../transactions/index.esm.js';\nvar _excluded = [\"userSession\"];\n\nfunction getStxAddress(options) {\n  var _userSession$loadUser, _chainIdToKey;\n\n  var userSession = options.userSession,\n      network = options.network;\n  if (!userSession || !network) return void 0;\n  var stxAddresses = userSession == null ? void 0 : (_userSession$loadUser = userSession.loadUserData().profile) == null ? void 0 : _userSession$loadUser.stxAddress;\n  var chainIdToKey = (_chainIdToKey = {}, _chainIdToKey[ChainID.Mainnet] = \"mainnet\", _chainIdToKey[ChainID.Testnet] = \"testnet\", _chainIdToKey);\n  var address = stxAddresses == null ? void 0 : stxAddresses[chainIdToKey[network.chainId]];\n  return address;\n}\n\nfunction signPayload(_x, _x2) {\n  return _signPayload.apply(this, arguments);\n}\n\nfunction _signPayload() {\n  _signPayload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(payload, privateKey) {\n    var tokenSigner;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            tokenSigner = new TokenSigner(\"ES256k\", privateKey);\n            return _context2.abrupt(\"return\", tokenSigner.signAsync(_extends({}, payload)));\n\n          case 2:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _signPayload.apply(this, arguments);\n}\n\nfunction getDefaultSignatureRequestOptions(options) {\n  var network = options.network || new StacksTestnet();\n  var userSession = getUserSession(options.userSession);\n\n  var defaults = _extends({}, options, {\n    network: network,\n    userSession: userSession\n  });\n\n  return _extends({\n    stxAddress: getStxAddress(defaults)\n  }, defaults);\n}\n\nfunction openSignaturePopup(_x3) {\n  return _openSignaturePopup.apply(this, arguments);\n}\n\nfunction _openSignaturePopup() {\n  _openSignaturePopup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref) {\n    var token, options, provider, signatureResponse;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            token = _ref.token, options = _ref.options;\n            provider = getStacksProvider();\n\n            if (provider) {\n              _context3.next = 4;\n              break;\n            }\n\n            throw new Error(\"Hiro Wallet not installed.\");\n\n          case 4:\n            _context3.prev = 4;\n            _context3.next = 7;\n            return provider.signatureRequest(token);\n\n          case 7:\n            signatureResponse = _context3.sent;\n            options.onFinish == null ? void 0 : options.onFinish(signatureResponse);\n            _context3.next = 15;\n            break;\n\n          case 11:\n            _context3.prev = 11;\n            _context3.t0 = _context3[\"catch\"](4);\n            console.error(\"[Connect] Error during signature request\", _context3.t0);\n            options.onCancel == null ? void 0 : options.onCancel();\n\n          case 15:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[4, 11]]);\n  }));\n  return _openSignaturePopup.apply(this, arguments);\n}\n\nvar signMessage = /*#__PURE__*/function () {\n  var _ref2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(options) {\n    var userSession, _options, _getKeys, privateKey, publicKey, payload2, payload;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            userSession = options.userSession, _options = _objectWithoutPropertiesLoose(options, _excluded);\n\n            if (!hasAppPrivateKey(userSession)) {\n              _context.next = 5;\n              break;\n            }\n\n            _getKeys = getKeys(userSession), privateKey = _getKeys.privateKey, publicKey = _getKeys.publicKey;\n            payload2 = _extends({}, _options, {\n              publicKey: publicKey\n            });\n            return _context.abrupt(\"return\", signPayload(payload2, privateKey));\n\n          case 5:\n            payload = _extends({}, _options);\n            return _context.abrupt(\"return\", createUnsecuredToken(payload));\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function signMessage(_x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nfunction generateTokenAndOpenPopup(_x5, _x6) {\n  return _generateTokenAndOpenPopup.apply(this, arguments);\n}\n\nfunction _generateTokenAndOpenPopup() {\n  _generateTokenAndOpenPopup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(options, makeTokenFn) {\n    var token;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return makeTokenFn(_extends({}, getDefaultSignatureRequestOptions(options), options));\n\n          case 2:\n            token = _context4.sent;\n            return _context4.abrupt(\"return\", openSignaturePopup({\n              token: token,\n              options: options\n            }));\n\n          case 4:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _generateTokenAndOpenPopup.apply(this, arguments);\n}\n\nfunction openSignatureRequestPopup(options) {\n  return generateTokenAndOpenPopup(options, signMessage);\n}\n\nexport { getDefaultSignatureRequestOptions, openSignatureRequestPopup, signMessage };","map":{"version":3,"mappings":";;;;;;;;;AAaA,uBAAuBA,OAAvB,EAA+D;EAAA;;MACrDC,cAAyBD,QAAzBC;MAAaC,UAAYF,QAAZE;MAEjB,CAACD,WAAD,IAAgB,CAACC,gBAAgB,MAAhBA;MACfC,eAAeF,oEAAaG,YAAbH,GAA4BI,OAA5BJ,KAA4BI,IAA5BJ,GAA4BI,MAA5BJ,yBAAqCK;MACpDC,kDACHC,QAAQC,OADLF,IACe,SADfA,EACeG,cAClBF,QAAQG,OADU,IACA,SAFfJ,EAEeG,aAFfH;MAIAK,UAA8BT,6CAAeI,aAAaL,QAAQW,OAArBN,CAAfJ;SAC7BS;;;;;;;;0EAGT,kBAA2BE,OAA3B,EAAsDC,UAAtD;IAAA;IAAA;MAAA;QAAA;UAAA;YACQC,WADR,GACsB,IAAIC,WAAJ,CAAgB,QAAhB,EAA0BF,UAA1B,CAAdC;YADR,kCAGSA,YAAYE,SAAZF,cAA2BF,OAA3B,EAHT;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA;;;;2CAMkDd,SAAwC;MAClFE,UAAUF,QAAQE,OAARF,IAAmB,IAAImB,aAAJ;MAC7BlB,cAAcmB,eAAepB,QAAQC,WAAvBmB;;MACdC,wBACDrB,OADCqB,EACDrB;IACHE,gBADGF;IAEHC;EAFGD,CADCqB;;;IAMJf,YAAYgB,cAAcD,QAAdC;KACTD;;;;;;;;iFAIP;IAAA;IAAA;MAAA;QAAA;UAAA;YAAoCE,KAApC,QAAoCA,OAAOvB,OAA3C,QAA2CA,OAAPuB;YAC5BC,QADR,GACmBC,mBAAXD;;YADR,IAEOA,QAFP;cAAAE;cAAA;YAAA;;YAAA,MAGU,IAAIC,KAAJ,CAAU,4BAAV,CAHV;;UAAA;YAAAD;YAAAA;YAAA,OAOoCF,SAASI,gBAATJ,CAA0BD,KAA1BC,CAPpC;;UAAA;YAOUK,iBAPV,iBAOUA;oBACEC,6CAAWD,iBAAXC;YARZJ;YAAA;;UAAA;YAAAA;YAAAA;oBAUYK,MAAM;oBACNC;;UAXZ;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA;;;;IAmBaC;oFAAc,iBAAOjC,OAAP;IAAA;;IAAA;MAAA;QAAA;UAAA;YACjBC,WADiB,GACYD,OADZ,CACjBC,aAAgBiC,QADC,iCACYlC,OADZ,YACjBC;;YADiB,KAErBkC,iBAAiBlC,WAAjBkC,CAFqB;cAAAC;cAAA;YAAA;;YAAAC,WAGWC,QAAQrC,WAARqC,CAHX,EAGfvB,UAHe,YAGfA,UAHe,EAGHwB,SAHG,YAGHA,SAHG;YAKjBC,QALiB,gBAMlBN,QANkB;cAOrBK;YAPqB,EAKjBC;YALiB,iCAUhBC,YAAYD,QAAZC,EAAqB1B,UAArB0B,CAVgB;;UAAA;YAYnB3B,OAZmB,gBAYJoB,QAZI,CAYnBpB;YAZmB,iCAalB4B,qBAAqB5B,OAArB4B,CAbkB;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA;;kBAAdT;;;CAAAA;;;;;;;wFAgBb,kBACEjC,OADF,EAEE2C,WAFF;IAAA;IAAA;MAAA;QAAA;UAAA;YAAAC;YAAA,OAIsBD,yBACfE,kCAAkC7C,OAAlC6C,CADeF,EAEf3C,OAFe2C,EAJtB;;UAAA;YAIQpB,KAJR,iBAIQA;YAJR,kCAQSuB,mBAAmB;cAAEvB,YAAF;cAASvB;YAAT,CAAnB8C,CART;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA;;;;mCAW0C9C,SAAkC;SACnE+C,0BAA0B/C,OAA1B+C,EAAmCd,WAAnCc","names":["options","userSession","network","stxAddresses","loadUserData","profile","stxAddress","chainIdToKey","ChainID","Mainnet","_chainIdToKey","Testnet","address","chainId","payload","privateKey","tokenSigner","TokenSigner","signAsync","StacksTestnet","getUserSession","defaults","getStxAddress","token","provider","getStacksProvider","_context3","Error","signatureRequest","signatureResponse","onFinish","error","onCancel","signMessage","_options","hasAppPrivateKey","_context","_getKeys","getKeys","publicKey","payload2","signPayload","createUnsecuredToken","makeTokenFn","_context4","getDefaultSignatureRequestOptions","openSignaturePopup","generateTokenAndOpenPopup"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\connect\\src\\signature\\index.ts"],"sourcesContent":["import { StacksTestnet } from '@stacks/network';\nimport { ChainID } from '@stacks/transactions';\nimport { createUnsecuredToken, TokenSigner } from 'jsontokens';\nimport { getKeys, getUserSession, hasAppPrivateKey } from '../transactions';\nimport {\n  CommonSignatureRequestOptions,\n  SignatureOptions,\n  SignaturePayload,\n  SignaturePopup,\n  SignatureRequestOptions,\n} from '../types/signature';\nimport { getStacksProvider } from '../utils';\n\nfunction getStxAddress(options: CommonSignatureRequestOptions) {\n  const { userSession, network } = options;\n\n  if (!userSession || !network) return undefined;\n  const stxAddresses = userSession?.loadUserData().profile?.stxAddress;\n  const chainIdToKey = {\n    [ChainID.Mainnet]: 'mainnet',\n    [ChainID.Testnet]: 'testnet',\n  };\n  const address: string | undefined = stxAddresses?.[chainIdToKey[network.chainId]];\n  return address;\n}\n\nasync function signPayload(payload: SignaturePayload, privateKey: string) {\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  return tokenSigner.signAsync({ ...payload } as any);\n}\n\nexport function getDefaultSignatureRequestOptions(options: CommonSignatureRequestOptions) {\n  const network = options.network || new StacksTestnet();\n  const userSession = getUserSession(options.userSession);\n  const defaults: CommonSignatureRequestOptions = {\n    ...options,\n    network,\n    userSession,\n  };\n  return {\n    stxAddress: getStxAddress(defaults),\n    ...defaults,\n  };\n}\n\nasync function openSignaturePopup({ token, options }: SignaturePopup) {\n  const provider = getStacksProvider();\n  if (!provider) {\n    throw new Error('Hiro Wallet not installed.');\n  }\n\n  try {\n    const signatureResponse = await provider.signatureRequest(token);\n    options.onFinish?.(signatureResponse);\n  } catch (error) {\n    console.error('[Connect] Error during signature request', error);\n    options.onCancel?.();\n  }\n}\n\nexport interface SignatureRequestPayload {\n  message: string;\n}\n\nexport const signMessage = async (options: SignatureRequestOptions) => {\n  const { userSession, ..._options } = options;\n  if (hasAppPrivateKey(userSession)) {\n    const { privateKey, publicKey } = getKeys(userSession);\n\n    const payload: SignaturePayload = {\n      ..._options,\n      publicKey,\n    };\n\n    return signPayload(payload, privateKey);\n  }\n  const payload = { ..._options };\n  return createUnsecuredToken(payload as any);\n};\n\nasync function generateTokenAndOpenPopup<T extends SignatureOptions>(\n  options: T,\n  makeTokenFn: (options: T) => Promise<string>\n) {\n  const token = await makeTokenFn({\n    ...getDefaultSignatureRequestOptions(options),\n    ...options,\n  } as T);\n  return openSignaturePopup({ token, options });\n}\n\nexport function openSignatureRequestPopup(options: SignatureRequestOptions) {\n  return generateTokenAndOpenPopup(options, signMessage);\n}\n"]},"metadata":{},"sourceType":"module"}