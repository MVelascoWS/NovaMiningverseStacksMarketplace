{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar React = require('react');\n\nvar React__default = _interopDefault(React);\n\nvar connect = require('@stacks/connect');\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar States;\n\n(function (States2) {\n  States2[\"UPDATE_AUTH_OPTIONS\"] = \"data/update-auth-options\";\n})(States || (States = {}));\n\nvar initialState = {\n  isOpen: false,\n  isAuthenticating: false,\n  authData: void 0,\n  userSession: void 0,\n  authOptions: {\n    redirectTo: \"\",\n    manifestPath: \"\",\n    onFinish: function onFinish() {\n      return null;\n    },\n    authOrigin: void 0,\n    sendToSignIn: false,\n    appDetails: {\n      name: \"\",\n      icon: \"\"\n    }\n  }\n};\n\nvar connectReducer = function connectReducer(state, _ref) {\n  var type = _ref.type,\n      payload = _ref.payload;\n\n  switch (type) {\n    case States.UPDATE_AUTH_OPTIONS:\n      {\n        return _extends({}, state, {\n          authOptions: _extends({}, state.authOptions, payload)\n        });\n      }\n\n    default:\n      {\n        throw new Error(\"Unhandled action type: \" + type);\n      }\n  }\n};\n\nvar ConnectContext = /*#__PURE__*/React.createContext(initialState);\nvar ConnectDispatchContext = /*#__PURE__*/React.createContext(void 0);\n\nvar ConnectProvider = function ConnectProvider(_ref2) {\n  var authOptions = _ref2.authOptions,\n      children = _ref2.children;\n\n  var _useReducer = React.useReducer(connectReducer, initialState),\n      state = _useReducer[0],\n      dispatch = _useReducer[1];\n\n  return /* @__PURE__ */React__default.createElement(ConnectContext.Provider, {\n    value: _extends({}, state, {\n      authOptions: authOptions\n    })\n  }, /* @__PURE__ */React__default.createElement(ConnectDispatchContext.Provider, {\n    value: dispatch\n  }, children));\n};\n\nvar Connect = function Connect(_ref) {\n  var authOptions = _ref.authOptions,\n      children = _ref.children;\n  return /* @__PURE__ */React__default.createElement(ConnectProvider, {\n    authOptions: authOptions\n  }, children);\n};\n\nvar useConnectDispatch = function useConnectDispatch() {\n  var dispatch = React.useContext(ConnectDispatchContext);\n\n  if (!dispatch) {\n    throw new Error(\"This must be used within the ConnectProvider component.\");\n  }\n\n  return dispatch;\n};\n\nvar useConnect = function useConnect() {\n  var _useContext = React.useContext(ConnectContext),\n      isOpen = _useContext.isOpen,\n      isAuthenticating = _useContext.isAuthenticating,\n      authData = _useContext.authData,\n      authOptions = _useContext.authOptions,\n      userSession = _useContext.userSession;\n\n  var dispatch = useConnectDispatch();\n\n  var doUpdateAuthOptions = function doUpdateAuthOptions(payload) {\n    return dispatch({\n      type: States.UPDATE_AUTH_OPTIONS,\n      payload: payload\n    });\n  };\n\n  var doOpenAuth = function doOpenAuth(signIn, options) {\n    if (signIn) {\n      var _options = _extends({}, authOptions, options, {\n        onFinish: function onFinish(payload) {\n          var _authOptions$onFinish;\n\n          (_authOptions$onFinish = authOptions.onFinish) === null || _authOptions$onFinish === void 0 ? void 0 : _authOptions$onFinish.call(authOptions, payload);\n        },\n        sendToSignIn: true\n      });\n\n      void connect.authenticate(_options);\n      return;\n    } else {\n      connect.showBlockstackConnect(_extends({}, authOptions, {\n        sendToSignIn: false\n      }));\n    }\n\n    authOptions && doUpdateAuthOptions(authOptions);\n  };\n\n  var doAuth = function doAuth(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    void connect.authenticate(_extends({}, authOptions, options, {\n      onFinish: function onFinish(payload) {\n        var _authOptions$onFinish2;\n\n        (_authOptions$onFinish2 = authOptions.onFinish) === null || _authOptions$onFinish2 === void 0 ? void 0 : _authOptions$onFinish2.call(authOptions, payload);\n      }\n    }));\n  };\n\n  function doContractCall(options) {\n    return connect.openContractCall(_extends({}, options, {\n      authOrigin: authOptions.authOrigin,\n      appDetails: authOptions.appDetails\n    }));\n  }\n\n  function doContractDeploy(options) {\n    return connect.openContractDeploy(_extends({}, options, {\n      authOrigin: authOptions.authOrigin,\n      appDetails: authOptions.appDetails\n    }));\n  }\n\n  function doSTXTransfer(options) {\n    return connect.openSTXTransfer(_extends({}, options, {\n      authOrigin: authOptions.authOrigin,\n      appDetails: authOptions.appDetails\n    }));\n  }\n\n  function sign(options) {\n    return connect.openSignatureRequestPopup(_extends({}, options, {\n      authOrigin: authOptions.authOrigin,\n      appDetails: authOptions.appDetails\n    }));\n  }\n\n  function signStructuredData(options) {\n    return connect.openStructuredDataSignatureRequestPopup(_extends({}, options, {\n      authOrigin: authOptions.authOrigin,\n      appDetails: authOptions.appDetails\n    }));\n  }\n\n  return {\n    isOpen: isOpen,\n    isAuthenticating: isAuthenticating,\n    authData: authData,\n    authOptions: authOptions,\n    userSession: userSession,\n    doOpenAuth: doOpenAuth,\n    doAuth: doAuth,\n    authenticate: connect.authenticate,\n    doContractCall: doContractCall,\n    doContractDeploy: doContractDeploy,\n    doSTXTransfer: doSTXTransfer,\n    sign: sign,\n    signStructuredData: signStructuredData\n  };\n};\n\nObject.keys(connect).forEach(function (k) {\n  if (k !== 'default') Object.defineProperty(exports, k, {\n    enumerable: true,\n    get: function () {\n      return connect[k];\n    }\n  });\n});\nexports.Connect = Connect;\nexports.useConnect = useConnect;","map":{"version":3,"mappings":"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","names":["States","States2","initialState","isOpen","isAuthenticating","authData","userSession","authOptions","redirectTo","manifestPath","onFinish","authOrigin","sendToSignIn","appDetails","name","icon","connectReducer","state","type","payload","UPDATE_AUTH_OPTIONS","Error","ConnectContext","createContext","ConnectDispatchContext","ConnectProvider","children","useReducer","dispatch","Provider","value","Connect","useConnectDispatch","useContext","useConnect","doUpdateAuthOptions","doOpenAuth","signIn","options","_options","authenticate","doAuth","openContractCall","openContractDeploy","openSTXTransfer","openSignatureRequestPopup","openStructuredDataSignatureRequestPopup","doContractCall","doContractDeploy","doSTXTransfer","sign","signStructuredData"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\connect-react\\src\\react\\components\\connect\\context.tsx","D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\connect-react\\src\\react\\components\\connect\\index.tsx","D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\connect-react\\src\\react\\hooks\\use-connect.ts"],"sourcesContent":["import React, { useReducer, createContext } from 'react';\nimport { AuthOptions, FinishedAuthData } from '@stacks/connect';\nimport { UserSession } from '@stacks/auth';\n\nenum States {\n  UPDATE_AUTH_OPTIONS = 'data/update-auth-options',\n}\n\ntype Action = { type: string; payload?: any };\n\ntype Dispatch = (action: Action) => void;\n\ntype State = {\n  isOpen: boolean;\n  isAuthenticating: boolean;\n  authData?: FinishedAuthData;\n  authOptions: AuthOptions;\n  userSession?: UserSession;\n};\n\nconst initialState: State = {\n  isOpen: false,\n  isAuthenticating: false,\n  authData: undefined,\n  userSession: undefined,\n  authOptions: {\n    redirectTo: '',\n    manifestPath: '',\n    onFinish: () => null,\n    authOrigin: undefined,\n    sendToSignIn: false,\n    appDetails: {\n      name: '',\n      icon: '',\n    },\n  },\n};\n\nconst connectReducer = (state: State, { type, payload }: { type: string; payload?: any }) => {\n  switch (type) {\n    case States.UPDATE_AUTH_OPTIONS: {\n      return {\n        ...state,\n        authOptions: {\n          ...state.authOptions,\n          ...payload,\n        },\n      };\n    }\n\n    default: {\n      throw new Error(`Unhandled action type: ${type}`);\n    }\n  }\n};\n\nconst ConnectContext = createContext<State>(initialState);\n\nconst ConnectDispatchContext = createContext<Dispatch | undefined>(undefined);\n\nconst ConnectProvider = ({\n  authOptions,\n  children,\n}: {\n  authOptions: AuthOptions;\n  children: any;\n}) => {\n  const [state, dispatch] = useReducer(connectReducer, initialState);\n\n  return (\n    <ConnectContext.Provider value={{ ...state, authOptions }}>\n      <ConnectDispatchContext.Provider value={dispatch}>{children}</ConnectDispatchContext.Provider>\n    </ConnectContext.Provider>\n  );\n};\n\nexport {\n  initialState,\n  connectReducer,\n  ConnectContext,\n  ConnectDispatchContext,\n  ConnectProvider,\n  States,\n};\n","import React from 'react';\nimport { ConnectProvider } from './context';\nimport { AuthOptions } from '@stacks/connect';\n\n/**\n * Usage\n *\n *\n * const auth = {\n      manifestPath: '/static/manifest.json',\n      redirectTo: '/',\n      finished: ({userSession}) => {\n        doFinishSignIn();\n      },\n      authOrigin,\n      appDetails: {\n        name: 'Wink',\n        icon: 'url'\n      }\n    }\n *\n * <Connect authOptions={authOptions} />\n */\nconst Connect = ({ authOptions, children }: { authOptions: AuthOptions; children: any }) => {\n  return <ConnectProvider authOptions={authOptions}>{children}</ConnectProvider>;\n};\n\nexport { Connect };\n","import { useContext } from 'react';\nimport {\n  authenticate,\n  AuthOptions,\n  ContractCallOptions,\n  ContractDeployOptions,\n  STXTransferOptions,\n  openContractCall,\n  openContractDeploy,\n  openSTXTransfer,\n  showBlockstackConnect,\n  ContractCallRegularOptions,\n  ContractCallSponsoredOptions,\n  ContractDeployRegularOptions,\n  ContractDeploySponsoredOptions,\n  STXTransferRegularOptions,\n  STXTransferSponsoredOptions,\n  FinishedAuthData,\n  openStructuredDataSignatureRequestPopup,\n  openSignatureRequestPopup,\n} from '@stacks/connect';\nimport { ConnectContext, ConnectDispatchContext, States } from '../components/connect/context';\nimport { SignatureRequestOptions } from '@stacks/connect';\nimport { StructuredDataSignatureRequestOptions } from '@stacks/connect/src/types/structuredDataSignature';\n\nconst useConnectDispatch = () => {\n  const dispatch = useContext(ConnectDispatchContext);\n  if (!dispatch) {\n    throw new Error('This must be used within the ConnectProvider component.');\n  }\n  return dispatch;\n};\n\nexport const useConnect = () => {\n  const { isOpen, isAuthenticating, authData, authOptions, userSession } =\n    useContext(ConnectContext);\n\n  const dispatch = useConnectDispatch();\n\n  const doUpdateAuthOptions = (payload: Partial<AuthOptions>) => {\n    return dispatch({ type: States.UPDATE_AUTH_OPTIONS, payload });\n  };\n\n  /**\n   *\n   * @param signIn Whether the user should be sent to sign in\n   * @param options\n   */\n  const doOpenAuth = (signIn?: boolean, options?: Partial<AuthOptions>) => {\n    if (signIn) {\n      const _options: AuthOptions = {\n        ...authOptions,\n        ...options,\n        onFinish: (payload: FinishedAuthData) => {\n          authOptions.onFinish?.(payload);\n        },\n        sendToSignIn: true,\n      };\n      void authenticate(_options);\n      return;\n    } else {\n      showBlockstackConnect({\n        ...authOptions,\n        sendToSignIn: false,\n      });\n    }\n    authOptions && doUpdateAuthOptions(authOptions);\n  };\n\n  const doAuth = (options: Partial<AuthOptions> = {}) => {\n    void authenticate({\n      ...authOptions,\n      ...options,\n      onFinish: (payload: FinishedAuthData) => {\n        authOptions.onFinish?.(payload);\n      },\n    });\n  };\n\n  function doContractCall(options: ContractCallRegularOptions): Promise<void>;\n  function doContractCall(options: ContractCallSponsoredOptions): Promise<void>;\n  function doContractCall(options: ContractCallOptions): Promise<void>;\n  function doContractCall(options: ContractCallOptions) {\n    return openContractCall({\n      ...options,\n      authOrigin: authOptions.authOrigin,\n      appDetails: authOptions.appDetails,\n    });\n  }\n\n  function doContractDeploy(options: ContractDeployRegularOptions): Promise<void>;\n  function doContractDeploy(options: ContractDeploySponsoredOptions): Promise<void>;\n  function doContractDeploy(options: ContractDeployOptions): Promise<void>;\n  function doContractDeploy(options: ContractDeployOptions) {\n    return openContractDeploy({\n      ...options,\n      authOrigin: authOptions.authOrigin,\n      appDetails: authOptions.appDetails,\n    });\n  }\n\n  function doSTXTransfer(options: STXTransferRegularOptions): Promise<void>;\n  function doSTXTransfer(options: STXTransferSponsoredOptions): Promise<void>;\n  function doSTXTransfer(options: STXTransferOptions): Promise<void>;\n  function doSTXTransfer(options: STXTransferOptions) {\n    return openSTXTransfer({\n      ...options,\n      authOrigin: authOptions.authOrigin,\n      appDetails: authOptions.appDetails,\n    });\n  }\n\n  function sign(options: SignatureRequestOptions) {\n    return openSignatureRequestPopup({\n      ...options,\n      authOrigin: authOptions.authOrigin,\n      appDetails: authOptions.appDetails,\n    });\n  }\n\n  function signStructuredData(options: StructuredDataSignatureRequestOptions) {\n    return openStructuredDataSignatureRequestPopup({\n      ...options,\n      authOrigin: authOptions.authOrigin,\n      appDetails: authOptions.appDetails,\n    });\n  }\n\n  return {\n    isOpen,\n    isAuthenticating,\n    authData,\n    authOptions,\n    userSession,\n    doOpenAuth,\n    doAuth,\n    authenticate,\n    doContractCall,\n    doContractDeploy,\n    doSTXTransfer,\n    sign,\n    signStructuredData,\n  };\n};\n"]},"metadata":{},"sourceType":"script"}