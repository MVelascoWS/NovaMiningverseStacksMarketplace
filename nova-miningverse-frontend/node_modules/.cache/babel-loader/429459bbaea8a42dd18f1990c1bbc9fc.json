{"ast":null,"code":"import { Buffer, intToBigInt } from '@stacks/common';\nimport { StacksNetwork, StacksMainnet, StacksTestnet, createFetchFn } from '@stacks/network';\nimport { c32address } from 'c32check';\nimport { createMultiSigSpendingCondition, createSingleSigSpendingCondition, createSponsoredAuth, createStandardAuth } from './authorization';\nimport { AddressHashMode, AddressVersion, PayloadType, PostConditionMode, TransactionVersion, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType } from './constants';\nimport { validateContractCall } from './contract-abi';\nimport { createStacksPrivateKey, createStacksPublicKey, getPublicKey, pubKeyfromPrivKey, publicKeyFromBuffer, publicKeyToAddress, publicKeyToString } from './keys';\nimport { createContractCallPayload, createSmartContractPayload, createTokenTransferPayload, serializePayload } from './payload';\nimport { createFungiblePostCondition, createNonFungiblePostCondition, createSTXPostCondition } from './postcondition';\nimport { createContractPrincipal, createStandardPrincipal } from './postcondition-types';\nimport { TransactionSigner } from './signer';\nimport { StacksTransaction } from './transaction';\nimport { createLPList } from './types';\nimport { cvToHex, omit, parseReadOnlyResponse, validateTxId } from './utils';\nexport async function getNonce(address, network) {\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : new StacksMainnet());\n  const url = derivedNetwork.getAccountApiUrl(address);\n  const response = await derivedNetwork.fetchFn(url);\n\n  if (!response.ok) {\n    let msg = '';\n\n    try {\n      msg = await response.text();\n    } catch (error) {}\n\n    throw new Error(`Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n\n  const responseText = await response.text();\n  const result = JSON.parse(responseText);\n  return BigInt(result.nonce);\n}\nexport async function estimateTransfer(transaction, network) {\n  if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {\n    throw new Error(`Transaction fee estimation only possible with ${PayloadType[PayloadType.TokenTransfer]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text'\n  };\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders\n  };\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n\n  if (!response.ok) {\n    let msg = '';\n\n    try {\n      msg = await response.text();\n    } catch (error) {}\n\n    throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n\n  const feeRateResult = await response.text();\n  const txBytes = BigInt(transaction.serialize().byteLength);\n  const feeRate = BigInt(feeRateResult);\n  return feeRate * txBytes;\n}\nexport async function estimateTransaction(transactionPayload, estimatedLen, network) {\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(Object.assign({\n      transaction_payload: serializePayload(transactionPayload).toString('hex')\n    }, estimatedLen ? {\n      estimated_len: estimatedLen\n    } : {}))\n  };\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : new StacksMainnet());\n  const url = derivedNetwork.getTransactionFeeEstimateApiUrl();\n  const response = await derivedNetwork.fetchFn(url, options);\n\n  if (!response.ok) {\n    let msg = '';\n\n    try {\n      msg = await response.text();\n    } catch (error) {}\n\n    throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n\n  const data = await response.json();\n  return data.estimations;\n}\nexport async function broadcastTransaction(transaction, network, attachment) {\n  const rawTx = transaction.serialize();\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : deriveNetwork(transaction));\n  const url = derivedNetwork.getBroadcastApiUrl();\n  return broadcastRawTransaction(rawTx, url, attachment, derivedNetwork.fetchFn);\n}\nexport async function broadcastRawTransaction(rawTx, url, attachment) {\n  let fetchFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : createFetchFn();\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': attachment ? 'application/json' : 'application/octet-stream'\n    },\n    body: attachment ? JSON.stringify({\n      tx: rawTx.toString('hex'),\n      attachment: attachment.toString('hex')\n    }) : rawTx\n  };\n  const response = await fetchFn(url, options);\n\n  if (!response.ok) {\n    try {\n      return await response.json();\n    } catch (e) {\n      throw Error(`Failed to broadcast transaction: ${e.message}`);\n    }\n  }\n\n  const text = await response.text();\n  const txid = text.replace(/[\"]+/g, '');\n  const isValidTxId = validateTxId(txid);\n\n  if (!isValidTxId) {\n    throw new Error(text);\n  }\n\n  return {\n    txid\n  };\n}\nexport async function getAbi(address, contractName, network) {\n  const options = {\n    method: 'GET'\n  };\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\n  const url = derivedNetwork.getAbiApiUrl(address, contractName);\n  const response = await derivedNetwork.fetchFn(url, options);\n\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error fetching contract ABI for contract \"${contractName}\" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n\n  return JSON.parse(await response.text());\n}\n\nfunction deriveNetwork(transaction) {\n  switch (transaction.version) {\n    case TransactionVersion.Mainnet:\n      return new StacksMainnet();\n\n    case TransactionVersion.Testnet:\n      return new StacksTestnet();\n  }\n}\n\nexport async function makeUnsignedSTXTokenTransfer(txOptions) {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    memo: '',\n    sponsored: false\n  };\n  const options = Object.assign(defaultOptions, txOptions);\n  const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n  let authorization = null;\n  let spendingCondition = null;\n\n  if ('publicKey' in options) {\n    spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n  } else {\n    spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const postConditions = [];\n\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const estimatedLen = estimateTransactionByteLength(transaction);\n    const txFee = await estimateTransaction(payload, estimatedLen, options.network);\n    transaction.setFee(txFee[1].fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\nexport async function makeSTXTokenTransfer(txOptions) {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedSTXTokenTransfer(Object.assign({\n      publicKey\n    }, options));\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedSTXTokenTransfer(options);\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n    }\n\n    return transaction;\n  }\n}\nexport async function estimateContractDeploy(transaction, network) {\n  if (transaction.payload.payloadType !== PayloadType.SmartContract) {\n    throw new Error(`Contract deploy fee estimation only possible with ${PayloadType[PayloadType.SmartContract]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text'\n  };\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders\n  };\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\nexport async function makeContractDeploy(txOptions) {\n  const privKey = createStacksPrivateKey(txOptions.senderKey);\n  const stacksPublicKey = getPublicKey(privKey);\n  const publicKey = publicKeyToString(stacksPublicKey);\n  const unsignedTxOptions = Object.assign(Object.assign({}, txOptions), {\n    publicKey\n  });\n  const transaction = await makeUnsignedContractDeploy(unsignedTxOptions);\n\n  if (txOptions.senderKey) {\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n  }\n\n  return transaction;\n}\nexport async function makeUnsignedContractDeploy(txOptions) {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false\n  };\n  const options = Object.assign(defaultOptions, txOptions);\n  const payload = createSmartContractPayload(options.contractName, options.codeBody);\n  const addressHashMode = AddressHashMode.SerializeP2PKH;\n  const pubKey = createStacksPublicKey(options.publicKey);\n  let authorization = null;\n  const spendingCondition = createSingleSigSpendingCondition(addressHashMode, publicKeyToString(pubKey), options.nonce, options.fee);\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const postConditions = [];\n\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const estimatedLen = estimateTransactionByteLength(transaction);\n    const txFee = await estimateTransaction(payload, estimatedLen, options.network);\n    transaction.setFee(txFee[1].fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = publicKeyToAddress(addressVersion, pubKey);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\nexport async function estimateContractFunctionCall(transaction, network) {\n  if (transaction.payload.payloadType !== PayloadType.ContractCall) {\n    throw new Error(`Contract call fee estimation only possible with ${PayloadType[PayloadType.ContractCall]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text'\n  };\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders\n  };\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\nexport async function makeUnsignedContractCall(txOptions) {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false\n  };\n  const options = Object.assign(defaultOptions, txOptions);\n  const payload = createContractCallPayload(options.contractAddress, options.contractName, options.functionName, options.functionArgs);\n\n  if (options === null || options === void 0 ? void 0 : options.validateWithAbi) {\n    let abi;\n\n    if (typeof options.validateWithAbi === 'boolean') {\n      if (options === null || options === void 0 ? void 0 : options.network) {\n        abi = await getAbi(options.contractAddress, options.contractName, options.network);\n      } else {\n        throw new Error('Network option must be provided in order to validate with ABI');\n      }\n    } else {\n      abi = options.validateWithAbi;\n    }\n\n    validateContractCall(payload, abi);\n  }\n\n  let spendingCondition = null;\n  let authorization = null;\n\n  if ('publicKey' in options) {\n    spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n  } else {\n    spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const postConditions = [];\n\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const estimatedLen = estimateTransactionByteLength(transaction);\n    const txFee = await estimateTransaction(payload, estimatedLen, network);\n    transaction.setFee(txFee[1].fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion = network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n    const txNonce = await getNonce(senderAddress, network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\nexport async function makeContractCall(txOptions) {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractCall(Object.assign({\n      publicKey\n    }, options));\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractCall(options);\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n    }\n\n    return transaction;\n  }\n}\nexport function makeStandardSTXPostCondition(address, conditionCode, amount) {\n  return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\nexport function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {\n  return createSTXPostCondition(createContractPrincipal(address, contractName), conditionCode, amount);\n}\nexport function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {\n  return createFungiblePostCondition(createStandardPrincipal(address), conditionCode, amount, assetInfo);\n}\nexport function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {\n  return createFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, amount, assetInfo);\n}\nexport function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetName) {\n  return createNonFungiblePostCondition(createStandardPrincipal(address), conditionCode, assetInfo, assetName);\n}\nexport function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetName) {\n  return createNonFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, assetInfo, assetName);\n}\nexport async function callReadOnlyFunction(readOnlyFunctionOptions) {\n  const defaultOptions = {\n    network: new StacksMainnet()\n  };\n  const options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n  const {\n    contractName,\n    contractAddress,\n    functionName,\n    functionArgs,\n    senderAddress\n  } = options;\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n  const args = functionArgs.map(arg => cvToHex(arg));\n  const body = JSON.stringify({\n    sender: senderAddress,\n    arguments: args\n  });\n  const response = await network.fetchFn(url, {\n    method: 'POST',\n    body,\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n\n  return response.json().then(responseJson => parseReadOnlyResponse(responseJson));\n}\nexport async function sponsorTransaction(sponsorOptions) {\n  const defaultOptions = {\n    fee: 0,\n    sponsorNonce: 0,\n    sponsorAddressHashmode: AddressHashMode.SerializeP2PKH,\n    network: sponsorOptions.transaction.version === TransactionVersion.Mainnet ? new StacksMainnet() : new StacksTestnet()\n  };\n  const options = Object.assign(defaultOptions, sponsorOptions);\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n\n  if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {\n    let txFee = 0;\n\n    switch (options.transaction.payload.payloadType) {\n      case PayloadType.TokenTransfer:\n      case PayloadType.SmartContract:\n      case PayloadType.ContractCall:\n        const estimatedLen = estimateTransactionByteLength(options.transaction);\n\n        try {\n          txFee = (await estimateTransaction(options.transaction.payload, estimatedLen, network))[1].fee;\n        } catch (e) {\n          throw e;\n        }\n\n        break;\n\n      default:\n        throw new Error(`Sponsored transactions not supported for transaction type ${PayloadType[options.transaction.payload.payloadType]}`);\n    }\n\n    options.transaction.setFee(txFee);\n    options.fee = txFee;\n  }\n\n  if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {\n    const addressVersion = network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n    const sponsorNonce = await getNonce(senderAddress, network);\n    options.sponsorNonce = sponsorNonce;\n  }\n\n  const sponsorSpendingCondition = createSingleSigSpendingCondition(options.sponsorAddressHashmode, publicKeyToString(sponsorPubKey), options.sponsorNonce, options.fee);\n  options.transaction.setSponsor(sponsorSpendingCondition);\n  const privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n  const signer = TransactionSigner.createSponsorSigner(options.transaction, sponsorSpendingCondition);\n  signer.signSponsor(privKey);\n  return signer.transaction;\n}\nexport function estimateTransactionByteLength(transaction) {\n  const hashMode = transaction.auth.spendingCondition.hashMode;\n  const multiSigHashModes = [AddressHashMode.SerializeP2SH, AddressHashMode.SerializeP2WSH];\n\n  if (multiSigHashModes.includes(hashMode)) {\n    const multiSigSpendingCondition = transaction.auth.spendingCondition;\n    const existingSignatures = multiSigSpendingCondition.fields.filter(field => field.contents.type === StacksMessageType.MessageSignature).length;\n    const totalSignatureLength = (multiSigSpendingCondition.signaturesRequired - existingSignatures) * (RECOVERABLE_ECDSA_SIG_LENGTH_BYTES + 1);\n    return transaction.serialize().byteLength + totalSignatureLength;\n  } else {\n    return transaction.serialize().byteLength;\n  }\n}","map":{"version":3,"mappings":"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","names":["Buffer","intToBigInt","StacksNetwork","StacksMainnet","StacksTestnet","createFetchFn","c32address","createMultiSigSpendingCondition","createSingleSigSpendingCondition","createSponsoredAuth","createStandardAuth","AddressHashMode","AddressVersion","PayloadType","PostConditionMode","TransactionVersion","RECOVERABLE_ECDSA_SIG_LENGTH_BYTES","StacksMessageType","validateContractCall","createStacksPrivateKey","createStacksPublicKey","getPublicKey","pubKeyfromPrivKey","publicKeyFromBuffer","publicKeyToAddress","publicKeyToString","createContractCallPayload","createSmartContractPayload","createTokenTransferPayload","serializePayload","createFungiblePostCondition","createNonFungiblePostCondition","createSTXPostCondition","createContractPrincipal","createStandardPrincipal","TransactionSigner","StacksTransaction","createLPList","cvToHex","omit","parseReadOnlyResponse","validateTxId","getNonce","address","network","derivedNetwork","fromNameOrNetwork","url","getAccountApiUrl","response","fetchFn","ok","msg","text","error","Error","status","statusText","responseText","result","JSON","parse","BigInt","nonce","estimateTransfer","transaction","payload","payloadType","TokenTransfer","requestHeaders","Accept","fetchOptions","method","headers","deriveNetwork","getTransferFeeEstimateApiUrl","feeRateResult","txBytes","serialize","byteLength","feeRate","estimateTransaction","transactionPayload","estimatedLen","options","body","stringify","Object","transaction_payload","toString","estimated_len","getTransactionFeeEstimateApiUrl","data","json","estimations","broadcastTransaction","attachment","rawTx","getBroadcastApiUrl","broadcastRawTransaction","tx","e","message","txid","replace","isValidTxId","getAbi","contractName","getAbiApiUrl","catch","version","Mainnet","Testnet","makeUnsignedSTXTokenTransfer","txOptions","defaultOptions","fee","postConditionMode","Deny","memo","sponsored","assign","recipient","amount","authorization","spendingCondition","SerializeP2PKH","publicKey","SerializeP2SH","numSignatures","publicKeys","postConditions","length","forEach","postCondition","push","lpPostConditions","anchorMode","chainId","undefined","estimateTransactionByteLength","txFee","setFee","addressVersion","MainnetSingleSig","TestnetSingleSig","senderAddress","auth","signer","txNonce","setNonce","makeSTXTokenTransfer","senderKey","privKey","signOrigin","pubKeys","key","signerKeys","pubKey","filter","pk","appendOrigin","from","estimateContractDeploy","SmartContract","makeContractDeploy","stacksPublicKey","unsignedTxOptions","makeUnsignedContractDeploy","codeBody","addressHashMode","estimateContractFunctionCall","ContractCall","makeUnsignedContractCall","contractAddress","functionName","functionArgs","validateWithAbi","abi","makeContractCall","makeStandardSTXPostCondition","conditionCode","makeContractSTXPostCondition","makeStandardFungiblePostCondition","assetInfo","makeContractFungiblePostCondition","makeStandardNonFungiblePostCondition","assetName","makeContractNonFungiblePostCondition","callReadOnlyFunction","readOnlyFunctionOptions","getReadOnlyFunctionCallApiUrl","args","map","arg","sender","arguments","then","responseJson","sponsorTransaction","sponsorOptions","sponsorNonce","sponsorAddressHashmode","sponsorPubKey","sponsorPrivateKey","sponsorSpendingCondition","setSponsor","createSponsorSigner","signSponsor","hashMode","multiSigHashModes","SerializeP2WSH","includes","multiSigSpendingCondition","existingSignatures","fields","field","contents","type","MessageSignature","totalSignatureLength","signaturesRequired"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\connect-react\\node_modules\\@stacks\\transactions\\src\\builders.ts"],"sourcesContent":["import { Buffer, IntegerType, intToBigInt } from '@stacks/common';\nimport {\n  StacksNetwork,\n  StacksMainnet,\n  StacksNetworkName,\n  StacksTestnet,\n  FetchFn,\n  createFetchFn,\n} from '@stacks/network';\nimport { c32address } from 'c32check';\nimport {\n  Authorization,\n  createMultiSigSpendingCondition,\n  createSingleSigSpendingCondition,\n  createSponsoredAuth,\n  createStandardAuth,\n  SpendingCondition,\n  MultiSigSpendingCondition,\n} from './authorization';\nimport { ClarityValue, PrincipalCV } from './clarity';\nimport {\n  AddressHashMode,\n  AddressVersion,\n  AnchorMode,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  PayloadType,\n  PostConditionMode,\n  SingleSigHashMode,\n  TransactionVersion,\n  TxRejectedReason,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  StacksMessageType,\n} from './constants';\nimport { ClarityAbi, validateContractCall } from './contract-abi';\nimport {\n  createStacksPrivateKey,\n  createStacksPublicKey,\n  getPublicKey,\n  pubKeyfromPrivKey,\n  publicKeyFromBuffer,\n  publicKeyToAddress,\n  publicKeyToString,\n} from './keys';\nimport {\n  createContractCallPayload,\n  createSmartContractPayload,\n  createTokenTransferPayload,\n  Payload,\n  serializePayload,\n} from './payload';\nimport {\n  createFungiblePostCondition,\n  createNonFungiblePostCondition,\n  createSTXPostCondition,\n} from './postcondition';\nimport {\n  AssetInfo,\n  createContractPrincipal,\n  createStandardPrincipal,\n  FungiblePostCondition,\n  NonFungiblePostCondition,\n  PostCondition,\n  STXPostCondition,\n} from './postcondition-types';\nimport { TransactionSigner } from './signer';\nimport { StacksTransaction } from './transaction';\nimport { createLPList } from './types';\nimport { cvToHex, omit, parseReadOnlyResponse, validateTxId } from './utils';\n\n/**\n * Lookup the nonce for an address from a core node\n *\n * @param {string} address - the c32check address to look up\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to look up address on\n *\n * @return a promise that resolves to an integer\n */\nexport async function getNonce(\n  address: string,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());\n  const url = derivedNetwork.getAccountApiUrl(address);\n\n  const response = await derivedNetwork.fetchFn(url);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const responseText = await response.text();\n  const result = JSON.parse(responseText) as { nonce: string };\n  return BigInt(result.nonce);\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function insterad.\n *\n * Estimate the total transaction fee in microstacks for a token transfer\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateTransfer(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {\n    throw new Error(\n      `Transaction fee estimation only possible with ${\n        PayloadType[PayloadType.TokenTransfer]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = BigInt(transaction.serialize().byteLength);\n  const feeRate = BigInt(feeRateResult);\n  return feeRate * txBytes;\n}\n\ninterface FeeEstimation {\n  fee: number;\n  fee_rate: number;\n}\ninterface FeeEstimateResponse {\n  cost_scalar_change_by_byte: bigint;\n  estimated_cost: {\n    read_count: bigint;\n    read_length: bigint;\n    runtime: bigint;\n    write_count: bigint;\n    write_length: bigint;\n  };\n  estimated_cost_scalar: bigint;\n  estimations: [FeeEstimation, FeeEstimation, FeeEstimation];\n}\n\n/**\n * Estimate the total transaction fee in microstacks for a Stacks transaction\n *\n * @param {StacksTransaction} transaction - the transaction to estimate fees for\n * @param {number} estimatedLen - is an optional argument that provides the endpoint with an\n * estimation of the final length (in bytes) of the transaction, including any post-conditions\n * and signatures\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction fees for\n *\n * @return a promise that resolves to FeeEstimate\n */\nexport async function estimateTransaction(\n  transactionPayload: Payload,\n  estimatedLen?: number,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<[FeeEstimation, FeeEstimation, FeeEstimation]> {\n  const options = {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      transaction_payload: serializePayload(transactionPayload).toString('hex'),\n      ...(estimatedLen ? { estimated_len: estimatedLen } : {}),\n    }),\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());\n  const url = derivedNetwork.getTransactionFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, options);\n\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  const data: FeeEstimateResponse = await response.json();\n  return data.estimations;\n}\n\nexport type SerializationRejection = {\n  error: string;\n  reason: TxRejectedReason.Serialization;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type DeserializationRejection = {\n  error: string;\n  reason: TxRejectedReason.Deserialization;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type SignatureValidationRejection = {\n  error: string;\n  reason: TxRejectedReason.SignatureValidation;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type BadNonceRejection = {\n  error: string;\n  reason: TxRejectedReason.BadNonce;\n  reason_data: {\n    expected: number;\n    actual: number;\n    is_origin: boolean;\n    principal: boolean;\n  };\n  txid: string;\n};\n\nexport type FeeTooLowRejection = {\n  error: string;\n  reason: TxRejectedReason.FeeTooLow;\n  reason_data: {\n    expected: number;\n    actual: number;\n  };\n  txid: string;\n};\n\nexport type NotEnoughFundsRejection = {\n  error: string;\n  reason: TxRejectedReason.NotEnoughFunds;\n  reason_data: {\n    expected: string;\n    actual: string;\n  };\n  txid: string;\n};\n\nexport type NoSuchContractRejection = {\n  error: string;\n  reason: TxRejectedReason.NoSuchContract;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type NoSuchPublicFunctionRejection = {\n  error: string;\n  reason: TxRejectedReason.NoSuchPublicFunction;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type BadFunctionArgumentRejection = {\n  error: string;\n  reason: TxRejectedReason.BadFunctionArgument;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type ContractAlreadyExistsRejection = {\n  error: string;\n  reason: TxRejectedReason.ContractAlreadyExists;\n  reason_data: {\n    contract_identifier: string;\n  };\n  txid: string;\n};\n\nexport type PoisonMicroblocksDoNotConflictRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblocksDoNotConflict;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type PoisonMicroblockHasUnknownPubKeyHashRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblockHasUnknownPubKeyHash;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type PoisonMicroblockIsInvalidRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblockIsInvalid;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type BadAddressVersionByteRejection = {\n  error: string;\n  reason: TxRejectedReason.BadAddressVersionByte;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type NoCoinbaseViaMempoolRejection = {\n  error: string;\n  reason: TxRejectedReason.NoCoinbaseViaMempool;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type ServerFailureNoSuchChainTipRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureNoSuchChainTip;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type ServerFailureDatabaseRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureDatabase;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type ServerFailureOtherRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureOther;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type TxBroadcastResultOk = {\n  txid: string;\n  error?: undefined;\n  reason?: undefined;\n  reason_data?: undefined;\n};\n\nexport type TxBroadcastResultRejected =\n  | SerializationRejection\n  | DeserializationRejection\n  | SignatureValidationRejection\n  | BadNonceRejection\n  | FeeTooLowRejection\n  | NotEnoughFundsRejection\n  | NoSuchContractRejection\n  | NoSuchPublicFunctionRejection\n  | BadFunctionArgumentRejection\n  | ContractAlreadyExistsRejection\n  | PoisonMicroblocksDoNotConflictRejection\n  | PoisonMicroblockHasUnknownPubKeyHashRejection\n  | PoisonMicroblockIsInvalidRejection\n  | BadAddressVersionByteRejection\n  | NoCoinbaseViaMempoolRejection\n  | ServerFailureNoSuchChainTipRejection\n  | ServerFailureDatabaseRejection\n  | ServerFailureOtherRejection;\n\nexport type TxBroadcastResult = TxBroadcastResultOk | TxBroadcastResultRejected;\n\n/**\n * Broadcast the signed transaction to a core node\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to broadcast\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to broadcast transaction to\n *\n * @returns {Promise} that resolves to a response if the operation succeeds\n */\nexport async function broadcastTransaction(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork,\n  attachment?: Buffer\n): Promise<TxBroadcastResult> {\n  const rawTx = transaction.serialize();\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getBroadcastApiUrl();\n\n  return broadcastRawTransaction(rawTx, url, attachment, derivedNetwork.fetchFn);\n}\n\n/**\n * Broadcast the signed transaction to a core node\n *\n * @param {Buffer} rawTx - the raw serialized transaction buffer to broadcast\n * @param {string} url - the broadcast endpoint URL\n *\n * @returns {Promise} that resolves to a response if the operation succeeds\n */\nexport async function broadcastRawTransaction(\n  rawTx: Buffer,\n  url: string,\n  attachment?: Buffer,\n  fetchFn: FetchFn = createFetchFn()\n): Promise<TxBroadcastResult> {\n  const options = {\n    method: 'POST',\n    headers: { 'Content-Type': attachment ? 'application/json' : 'application/octet-stream' },\n    body: attachment\n      ? JSON.stringify({\n          tx: rawTx.toString('hex'),\n          attachment: attachment.toString('hex'),\n        })\n      : rawTx,\n  };\n\n  const response = await fetchFn(url, options);\n  if (!response.ok) {\n    try {\n      return (await response.json()) as TxBroadcastResult;\n    } catch (e) {\n      throw Error(`Failed to broadcast transaction: ${(e as Error).message}`);\n    }\n  }\n\n  const text = await response.text();\n  // Replace extra quotes around txid string\n  const txid = text.replace(/[\"]+/g, '');\n  const isValidTxId = validateTxId(txid);\n  if (!isValidTxId) {\n    throw new Error(text);\n  }\n  return {\n    txid,\n  } as TxBroadcastResult;\n}\n\n/**\n * Fetch a contract's ABI\n *\n * @param {string} address - the contracts address\n * @param {string} contractName - the contracts name\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to broadcast transaction to\n *\n * @returns {Promise} that resolves to a ClarityAbi if the operation succeeds\n */\nexport async function getAbi(\n  address: string,\n  contractName: string,\n  network: StacksNetworkName | StacksNetwork\n): Promise<ClarityAbi> {\n  const options = {\n    method: 'GET',\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\n  const url = derivedNetwork.getAbiApiUrl(address, contractName);\n\n  const response = await derivedNetwork.fetchFn(url, options);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error fetching contract ABI for contract \"${contractName}\" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  return JSON.parse(await response.text()) as ClarityAbi;\n}\n\nfunction deriveNetwork(transaction: StacksTransaction) {\n  switch (transaction.version) {\n    case TransactionVersion.Mainnet:\n      return new StacksMainnet();\n    case TransactionVersion.Testnet:\n      return new StacksTestnet();\n  }\n}\n\nexport interface MultiSigOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys?: string[];\n}\n\n/**\n * STX token transfer transaction options\n */\nexport interface TokenTransferOptions {\n  /** the address of the recipient of the token transfer */\n  recipient: string | PrincipalCV;\n  /** the amount to be transfered in microstacks */\n  amount: IntegerType;\n  /** the transaction fee in microstacks */\n  fee?: IntegerType;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the network that the transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorMode;\n  /** an arbitrary string to include in the transaction, must be less than 34 bytes */\n  memo?: string;\n  /** the post condition mode, specifying whether or not post-conditions must fully cover all\n   * transfered assets */\n  postConditionMode?: PostConditionMode;\n  /** a list of post conditions to add to the transaction */\n  postConditions?: PostCondition[];\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface UnsignedTokenTransferOptions extends TokenTransferOptions {\n  publicKey: string;\n}\n\nexport interface SignedTokenTransferOptions extends TokenTransferOptions {\n  senderKey: string;\n}\n\nexport interface UnsignedMultiSigTokenTransferOptions extends TokenTransferOptions {\n  numSignatures: number;\n  publicKeys: string[];\n}\n\nexport interface SignedMultiSigTokenTransferOptions extends TokenTransferOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys: string[];\n}\n\n/**\n * Generates an unsigned Stacks token transfer transaction\n *\n * Returns a Stacks token transfer transaction.\n *\n * @param  {UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\n *\n * @return {Promise<StacksTransaction>}\n */\nexport async function makeUnsignedSTXTokenTransfer(\n  txOptions: UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    memo: '',\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n\n  let authorization: Authorization | null = null;\n  let spendingCondition: SpendingCondition | null = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    spendingCondition = createMultiSigSpendingCondition(\n      AddressHashMode.SerializeP2SH,\n      options.numSignatures,\n      options.publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n  const lpPostConditions = createLPList(postConditions);\n\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const estimatedLen = estimateTransactionByteLength(transaction);\n    const txFee = await estimateTransaction(payload, estimatedLen, options.network);\n    transaction.setFee(txFee[1].fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Generates a signed Stacks token transfer transaction\n *\n * Returns a signed Stacks token transfer transaction.\n *\n * @param  {SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\n *\n * @return {StacksTransaction}\n */\nexport async function makeSTXTokenTransfer(\n  txOptions: SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    // txOptions is SignedTokenTransferOptions\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedSTXTokenTransfer({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    // txOptions is SignedMultiSigTokenTransferOptions\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedSTXTokenTransfer(options);\n\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n    }\n\n    return transaction;\n  }\n}\n\n/**\n * Contract deploy transaction options\n */\nexport interface BaseContractDeployOptions {\n  contractName: string;\n  /** the Clarity code to be deployed */\n  codeBody: string;\n  /** transaction fee in microstacks */\n  fee?: IntegerType;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the network that the transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorMode;\n  /** the post condition mode, specifying whether or not post-conditions must fully cover all\n   * transfered assets */\n  postConditionMode?: PostConditionMode;\n  /** a list of post conditions to add to the transaction */\n  postConditions?: PostCondition[];\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface ContractDeployOptions extends BaseContractDeployOptions {\n  /** a hex string of the private key of the transaction sender */\n  senderKey: string;\n}\n\nexport interface UnsignedContractDeployOptions extends BaseContractDeployOptions {\n  /** a hex string of the public key of the transaction sender */\n  publicKey: string;\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function insterad.\n *\n * Estimate the total transaction fee in microstacks for a contract deploy\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateContractDeploy(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (transaction.payload.payloadType !== PayloadType.SmartContract) {\n    throw new Error(\n      `Contract deploy fee estimation only possible with ${\n        PayloadType[PayloadType.SmartContract]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  // Place holder estimate until contract deploy fee estimation is fully implemented on Stacks\n  // blockchain core\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\n\n/**\n * Generates a Clarity smart contract deploy transaction\n *\n * @param  {ContractDeployOptions} txOptions - an options object for the contract deploy\n *\n * Returns a signed Stacks smart contract deploy transaction.\n *\n * @return {StacksTransaction}\n */\nexport async function makeContractDeploy(\n  txOptions: ContractDeployOptions\n): Promise<StacksTransaction> {\n  const privKey = createStacksPrivateKey(txOptions.senderKey);\n  const stacksPublicKey = getPublicKey(privKey);\n  const publicKey = publicKeyToString(stacksPublicKey);\n  const unsignedTxOptions: UnsignedContractDeployOptions = { ...txOptions, publicKey };\n  const transaction: StacksTransaction = await makeUnsignedContractDeploy(unsignedTxOptions);\n\n  if (txOptions.senderKey) {\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n  }\n\n  return transaction;\n}\n\nexport async function makeUnsignedContractDeploy(\n  txOptions: UnsignedContractDeployOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createSmartContractPayload(options.contractName, options.codeBody);\n\n  const addressHashMode = AddressHashMode.SerializeP2PKH;\n  const pubKey = createStacksPublicKey(options.publicKey);\n\n  let authorization: Authorization | null = null;\n\n  const spendingCondition = createSingleSigSpendingCondition(\n    addressHashMode,\n    publicKeyToString(pubKey),\n    options.nonce,\n    options.fee\n  );\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n  const lpPostConditions = createLPList(postConditions);\n\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const estimatedLen = estimateTransactionByteLength(transaction);\n    const txFee = await estimateTransaction(payload, estimatedLen, options.network);\n    transaction.setFee(txFee[1].fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = publicKeyToAddress(addressVersion, pubKey);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Contract function call transaction options\n */\nexport interface ContractCallOptions {\n  /** the Stacks address of the contract */\n  contractAddress: string;\n  contractName: string;\n  functionName: string;\n  functionArgs: ClarityValue[];\n  /** transaction fee in microstacks */\n  fee?: IntegerType;\n  feeEstimateApiUrl?: string;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the Stacks blockchain network that will ultimately be used to broadcast this transaction */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorMode;\n  /** the post condition mode, specifying whether or not post-conditions must fully cover all\n   * transfered assets */\n  postConditionMode?: PostConditionMode;\n  /** a list of post conditions to add to the transaction */\n  postConditions?: PostCondition[];\n  /** set to true to validate that the supplied function args match those specified in\n   * the published contract */\n  validateWithAbi?: boolean | ClarityAbi;\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface UnsignedContractCallOptions extends ContractCallOptions {\n  publicKey: string;\n}\n\nexport interface SignedContractCallOptions extends ContractCallOptions {\n  senderKey: string;\n}\n\nexport interface UnsignedMultiSigContractCallOptions extends ContractCallOptions {\n  numSignatures: number;\n  publicKeys: string[];\n}\n\nexport interface SignedMultiSigContractCallOptions extends ContractCallOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys: string[];\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function insterad.\n *\n * Estimate the total transaction fee in microstacks for a contract function call\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateContractFunctionCall(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (transaction.payload.payloadType !== PayloadType.ContractCall) {\n    throw new Error(\n      `Contract call fee estimation only possible with ${\n        PayloadType[PayloadType.ContractCall]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  // Place holder estimate until contract call fee estimation is fully implemented on Stacks\n  // blockchain core\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\n\n/**\n * Generates an unsigned Clarity smart contract function call transaction\n *\n * @param {UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions} txOptions - an options object for the contract call\n *\n * @returns {Promise<StacksTransaction>}\n */\nexport async function makeUnsignedContractCall(\n  txOptions: UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createContractCallPayload(\n    options.contractAddress,\n    options.contractName,\n    options.functionName,\n    options.functionArgs\n  );\n\n  if (options?.validateWithAbi) {\n    let abi: ClarityAbi;\n    if (typeof options.validateWithAbi === 'boolean') {\n      if (options?.network) {\n        abi = await getAbi(options.contractAddress, options.contractName, options.network);\n      } else {\n        throw new Error('Network option must be provided in order to validate with ABI');\n      }\n    } else {\n      abi = options.validateWithAbi;\n    }\n\n    validateContractCall(payload, abi);\n  }\n\n  let spendingCondition: SpendingCondition | null = null;\n  let authorization: Authorization | null = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    spendingCondition = createMultiSigSpendingCondition(\n      AddressHashMode.SerializeP2SH,\n      options.numSignatures,\n      options.publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const estimatedLen = estimateTransactionByteLength(transaction);\n    const txFee = await estimateTransaction(payload, estimatedLen, network);\n    transaction.setFee(txFee[1].fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Generates a Clarity smart contract function call transaction\n *\n * @param  {SignedContractCallOptions | SignedMultiSigContractCallOptions} txOptions - an options object for the contract function call\n *\n * Returns a signed Stacks smart contract function call transaction.\n *\n * @return {StacksTransaction}\n */\nexport async function makeContractCall(\n  txOptions: SignedContractCallOptions | SignedMultiSigContractCallOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractCall({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractCall(options);\n\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n    }\n\n    return transaction;\n  }\n}\n\n/**\n * Generates a STX post condition with a standard principal\n *\n * Returns a STX post condition object\n *\n * @param address - the c32check address\n * @param conditionCode - the condition code\n * @param amount - the amount of STX tokens\n */\nexport function makeStandardSTXPostCondition(\n  address: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType\n): STXPostCondition {\n  return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\n\n/**\n * Generates a STX post condition with a contract principal\n *\n * Returns a STX post condition object\n *\n * @param address - the c32check address of the contract\n * @param contractName - the name of the contract\n * @param conditionCode - the condition code\n * @param amount - the amount of STX tokens\n *\n * @return {STXPostCondition}\n */\nexport function makeContractSTXPostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType\n): STXPostCondition {\n  return createSTXPostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    amount\n  );\n}\n\n/**\n * Generates a fungible token post condition with a standard principal\n *\n * Returns a fungible token post condition object\n *\n * @param address - the c32check address\n * @param conditionCode - the condition code\n * @param amount - the amount of fungible tokens\n * @param assetInfo - asset info describing the fungible token\n */\nexport function makeStandardFungiblePostCondition(\n  address: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  return createFungiblePostCondition(\n    createStandardPrincipal(address),\n    conditionCode,\n    amount,\n    assetInfo\n  );\n}\n\n/**\n * Generates a fungible token post condition with a contract principal\n *\n * Returns a fungible token post condition object\n *\n * @param address - the c32check address\n * @param contractName - the name of the contract\n * @param conditionCode - the condition code\n * @param amount - the amount of fungible tokens\n * @param assetInfo - asset info describing the fungible token\n */\nexport function makeContractFungiblePostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  return createFungiblePostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    amount,\n    assetInfo\n  );\n}\n\n/**\n * Generates a non-fungible token post condition with a standard principal\n *\n * Returns a non-fungible token post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {AssetInfo} assetInfo - asset info describing the non-fungible token\n * @param  {ClarityValue} assetName - asset name describing the non-fungible token\n *\n * @return {NonFungiblePostCondition}\n */\nexport function makeStandardNonFungiblePostCondition(\n  address: string,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetName: ClarityValue\n): NonFungiblePostCondition {\n  return createNonFungiblePostCondition(\n    createStandardPrincipal(address),\n    conditionCode,\n    assetInfo,\n    assetName\n  );\n}\n\n/**\n * Generates a non-fungible token post condition with a contract principal\n *\n * Returns a non-fungible token post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {String} contractName - the name of the contract\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {AssetInfo} assetInfo - asset info describing the non-fungible token\n * @param  {ClarityValue} assetName - asset name describing the non-fungible token\n *\n * @return {NonFungiblePostCondition}\n */\nexport function makeContractNonFungiblePostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetName: ClarityValue\n): NonFungiblePostCondition {\n  return createNonFungiblePostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    assetInfo,\n    assetName\n  );\n}\n\n/**\n * Read only function options\n *\n * @param  {String} contractAddress - the c32check address of the contract\n * @param  {String} contractName - the contract name\n * @param  {String} functionName - name of the function to be called\n * @param  {[ClarityValue]} functionArgs - an array of Clarity values as arguments to the function call\n * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n * @param  {String} senderAddress - the c32check address of the sender\n */\n\nexport interface ReadOnlyFunctionOptions {\n  contractName: string;\n  contractAddress: string;\n  functionName: string;\n  functionArgs: ClarityValue[];\n  /** the network that the contract which contains the function is deployed to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** address of the sender */\n  senderAddress: string;\n}\n\n/**\n * Calls a function as read-only from a contract interface\n * It is not necessary that the function is defined as read-only in the contract\n *\n * @param  {ReadOnlyFunctionOptions} readOnlyFunctionOptions - the options object\n *\n * Returns an object with a status bool (okay) and a result string that is a serialized clarity value in hex format.\n *\n * @return {ClarityValue}\n */\nexport async function callReadOnlyFunction(\n  readOnlyFunctionOptions: ReadOnlyFunctionOptions\n): Promise<ClarityValue> {\n  const defaultOptions = {\n    network: new StacksMainnet(),\n  };\n\n  const options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n\n  const { contractName, contractAddress, functionName, functionArgs, senderAddress } = options;\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n\n  const args = functionArgs.map(arg => cvToHex(arg));\n\n  const body = JSON.stringify({\n    sender: senderAddress,\n    arguments: args,\n  });\n\n  const response = await network.fetchFn(url, {\n    method: 'POST',\n    body,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  return response.json().then(responseJson => parseReadOnlyResponse(responseJson));\n}\n\n/**\n * Sponsored transaction options\n */\nexport interface SponsorOptionsOpts {\n  /** the origin-signed transaction */\n  transaction: StacksTransaction;\n  /** the sponsor's private key */\n  sponsorPrivateKey: string;\n  /** the transaction fee amount to sponsor */\n  fee?: IntegerType;\n  /** the nonce of the sponsor account */\n  sponsorNonce?: IntegerType;\n  /** the hashmode of the sponsor's address */\n  sponsorAddressHashmode?: AddressHashMode;\n  /** the Stacks blockchain network that this transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n}\n\n/**\n * Constructs and signs a sponsored transaction as the sponsor\n *\n * @param  {SponsorOptionsOpts} sponsorOptions - the sponsor options object\n *\n * Returns a signed sponsored transaction.\n *\n * @return {ClarityValue}\n */\nexport async function sponsorTransaction(\n  sponsorOptions: SponsorOptionsOpts\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: 0 as IntegerType,\n    sponsorNonce: 0 as IntegerType,\n    sponsorAddressHashmode: AddressHashMode.SerializeP2PKH as SingleSigHashMode,\n    network:\n      sponsorOptions.transaction.version === TransactionVersion.Mainnet\n        ? new StacksMainnet()\n        : new StacksTestnet(),\n  };\n\n  const options = Object.assign(defaultOptions, sponsorOptions);\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n\n  if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {\n    let txFee = 0;\n    switch (options.transaction.payload.payloadType) {\n      case PayloadType.TokenTransfer:\n      case PayloadType.SmartContract:\n      case PayloadType.ContractCall:\n        const estimatedLen = estimateTransactionByteLength(options.transaction);\n        try {\n          txFee = (await estimateTransaction(options.transaction.payload, estimatedLen, network))[1]\n            .fee;\n        } catch (e) {\n          throw e;\n        }\n        break;\n      default:\n        throw new Error(\n          `Sponsored transactions not supported for transaction type ${\n            PayloadType[options.transaction.payload.payloadType]\n          }`\n        );\n    }\n    options.transaction.setFee(txFee);\n    options.fee = txFee;\n  }\n\n  if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {\n    const addressVersion =\n      network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n\n    const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n    const sponsorNonce = await getNonce(senderAddress, network);\n    options.sponsorNonce = sponsorNonce;\n  }\n\n  const sponsorSpendingCondition = createSingleSigSpendingCondition(\n    options.sponsorAddressHashmode,\n    publicKeyToString(sponsorPubKey),\n    options.sponsorNonce,\n    options.fee\n  );\n\n  options.transaction.setSponsor(sponsorSpendingCondition);\n\n  const privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n  const signer = TransactionSigner.createSponsorSigner(\n    options.transaction,\n    sponsorSpendingCondition\n  );\n  signer.signSponsor(privKey);\n\n  return signer.transaction;\n}\n\n/**\n * Estimates transaction byte length\n * Context:\n * 1) Multi-sig transaction byte length increases by adding signatures\n *    which causes the incorrect fee estimation because the fee value is set while creating unsigned transaction\n * 2) Single-sig transaction byte length remain same due to empty message signature which allocates the space for signature\n * @param {transaction} - StacksTransaction object to be estimated\n * @return {number} Estimated transaction byte length\n */\nexport function estimateTransactionByteLength(transaction: StacksTransaction): number {\n  const hashMode = transaction.auth.spendingCondition.hashMode;\n  // List of Multi-sig transaction hash modes\n  const multiSigHashModes = [AddressHashMode.SerializeP2SH, AddressHashMode.SerializeP2WSH];\n\n  // Check if its a Multi-sig transaction\n  if (multiSigHashModes.includes(hashMode)) {\n    const multiSigSpendingCondition: MultiSigSpendingCondition = transaction.auth\n      .spendingCondition as MultiSigSpendingCondition;\n\n    // Find number of existing signatures if the transaction is signed or partially signed\n    const existingSignatures = multiSigSpendingCondition.fields.filter(\n      field => field.contents.type === StacksMessageType.MessageSignature\n    ).length; // existingSignatures will be 0 if its a unsigned transaction\n\n    // Estimate total signature bytes size required for this multi-sig transaction\n    // Formula: totalSignatureLength = (signaturesRequired - existingSignatures) * (SIG_LEN_BYTES + 1 byte of type of signature)\n    const totalSignatureLength =\n      (multiSigSpendingCondition.signaturesRequired - existingSignatures) *\n      (RECOVERABLE_ECDSA_SIG_LENGTH_BYTES + 1);\n\n    return transaction.serialize().byteLength + totalSignatureLength;\n  } else {\n    // Single-sig transaction\n    // Signature space already allocated by empty message signature\n    return transaction.serialize().byteLength;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}