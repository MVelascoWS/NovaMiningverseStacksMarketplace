{"ast":null,"code":"import { asyncToGenerator as _asyncToGenerator } from './_virtual/_rollupPluginBabelHelpers.js';\nimport _regeneratorRuntime from 'regenerator-runtime';\nimport { AppConfig, UserSession } from '@stacks/auth';\nimport { decodeToken } from 'jsontokens';\nimport { getStacksProvider } from './utils.esm.js';\nvar defaultAuthURL = \"https://app.blockstack.org\";\nvar version = \"6.10.0\";\n\nif (typeof window !== \"undefined\") {\n  window.__CONNECT_VERSION__ = version;\n}\n\nvar isMobile = function isMobile() {\n  var ua = navigator.userAgent;\n\n  if (/android/i.test(ua)) {\n    return true;\n  }\n\n  if (/iPad|iPhone|iPod/.test(ua)) {\n    return true;\n  }\n\n  return /windows phone/i.test(ua);\n};\n\nvar shouldUsePopup = function shouldUsePopup() {\n  return !isMobile();\n};\n\nvar getOrCreateUserSession = function getOrCreateUserSession(userSession) {\n  if (!userSession) {\n    var appConfig = new AppConfig([\"store_write\"], document.location.href);\n    userSession = new UserSession({\n      appConfig: appConfig\n    });\n  }\n\n  return userSession;\n};\n\nvar authenticate = /*#__PURE__*/function () {\n  var _ref = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(authOptions) {\n    var provider, _authOptions$redirect, redirectTo, manifestPath, onFinish, onCancel, _authOptions$sendToSi, sendToSignIn, _userSession, appDetails, userSession, transitKey, authRequest, authResponse, token, payload, authResponsePayload;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            provider = getStacksProvider();\n\n            if (provider) {\n              _context.next = 3;\n              break;\n            }\n\n            throw new Error(\"Unable to authenticate without Hiro Wallet extension\");\n\n          case 3:\n            _authOptions$redirect = authOptions.redirectTo, redirectTo = _authOptions$redirect === void 0 ? \"/\" : _authOptions$redirect, manifestPath = authOptions.manifestPath, onFinish = authOptions.onFinish, onCancel = authOptions.onCancel, _authOptions$sendToSi = authOptions.sendToSignIn, sendToSignIn = _authOptions$sendToSi === void 0 ? false : _authOptions$sendToSi, _userSession = authOptions.userSession, appDetails = authOptions.appDetails;\n            userSession = getOrCreateUserSession(_userSession);\n\n            if (userSession.isUserSignedIn()) {\n              userSession.signUserOut();\n            }\n\n            transitKey = userSession.generateAndStoreTransitKey();\n            authRequest = userSession.makeAuthRequest(transitKey, \"\" + document.location.origin + redirectTo, \"\" + document.location.origin + manifestPath, userSession.appConfig.scopes, void 0, void 0, {\n              sendToSignIn: sendToSignIn,\n              appDetails: appDetails,\n              connectVersion: version\n            });\n            _context.prev = 8;\n            _context.next = 11;\n            return provider.authenticationRequest(authRequest);\n\n          case 11:\n            authResponse = _context.sent;\n            _context.next = 14;\n            return userSession.handlePendingSignIn(authResponse);\n\n          case 14:\n            token = decodeToken(authResponse);\n            payload = token == null ? void 0 : token.payload;\n            authResponsePayload = payload;\n            onFinish == null ? void 0 : onFinish({\n              authResponse: authResponse,\n              authResponsePayload: authResponsePayload,\n              userSession: userSession\n            });\n            _context.next = 24;\n            break;\n\n          case 20:\n            _context.prev = 20;\n            _context.t0 = _context[\"catch\"](8);\n            console.error(\"[Connect] Error during auth request\", _context.t0);\n            onCancel == null ? void 0 : onCancel();\n\n          case 24:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[8, 20]]);\n  }));\n\n  return function authenticate(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar getUserData = /*#__PURE__*/function () {\n  var _ref2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(userSession) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            userSession = getOrCreateUserSession(userSession);\n\n            if (!userSession.isUserSignedIn()) {\n              _context2.next = 3;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", userSession.loadUserData());\n\n          case 3:\n            if (!userSession.isSignInPending()) {\n              _context2.next = 5;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", userSession.handlePendingSignIn());\n\n          case 5:\n            return _context2.abrupt(\"return\", null);\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function getUserData(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexport { authenticate, defaultAuthURL, getOrCreateUserSession, getUserData, isMobile, shouldUsePopup };","map":{"version":3,"mappings":"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","names":["defaultAuthURL","version","__VERSION__","window","__CONNECT_VERSION__","isMobile","ua","navigator","userAgent","test","shouldUsePopup","getOrCreateUserSession","userSession","appConfig","AppConfig","document","location","href","UserSession","authenticate","authOptions","provider","getStacksProvider","_context","Error","_authOptions$redirect","redirectTo","manifestPath","onFinish","onCancel","sendToSignIn","_userSession","appDetails","isUserSignedIn","signUserOut","transitKey","generateAndStoreTransitKey","authRequest","makeAuthRequest","origin","scopes","connectVersion","authenticationRequest","authResponse","handlePendingSignIn","token","decodeToken","payload","authResponsePayload","error","getUserData","_context2","loadUserData","isSignInPending"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\connect\\src\\auth.ts"],"sourcesContent":["import { AppConfig, UserSession } from '@stacks/auth';\nimport { decodeToken } from 'jsontokens';\nimport type { AuthOptions, AuthResponsePayload } from './types';\n\nimport { getStacksProvider } from './utils';\n\nexport const defaultAuthURL = 'https://app.blockstack.org';\n\nconst version = __VERSION__;\n\nif (typeof window !== 'undefined') {\n  window.__CONNECT_VERSION__ = version;\n}\n\nexport const isMobile = () => {\n  const ua = navigator.userAgent;\n  if (/android/i.test(ua)) {\n    return true;\n  }\n  if (/iPad|iPhone|iPod/.test(ua)) {\n    return true;\n  }\n  return /windows phone/i.test(ua);\n};\n\n/**\n * mobile should not use a 'popup' type of window.\n */\nexport const shouldUsePopup = () => {\n  return !isMobile();\n};\n\nexport const getOrCreateUserSession = (userSession?: UserSession): UserSession => {\n  if (!userSession) {\n    const appConfig = new AppConfig(['store_write'], document.location.href);\n    userSession = new UserSession({ appConfig });\n  }\n  return userSession;\n};\n\nexport const authenticate = async (authOptions: AuthOptions) => {\n  const provider = getStacksProvider();\n  if (!provider) {\n    throw new Error('Unable to authenticate without Hiro Wallet extension');\n  }\n\n  const {\n    redirectTo = '/',\n    manifestPath,\n    onFinish,\n    onCancel,\n    sendToSignIn = false,\n    userSession: _userSession,\n    appDetails,\n  } = authOptions;\n  const userSession = getOrCreateUserSession(_userSession);\n  if (userSession.isUserSignedIn()) {\n    userSession.signUserOut();\n  }\n  const transitKey = userSession.generateAndStoreTransitKey();\n  const authRequest = userSession.makeAuthRequest(\n    transitKey,\n    `${document.location.origin}${redirectTo}`,\n    `${document.location.origin}${manifestPath}`,\n    userSession.appConfig.scopes,\n    undefined,\n    undefined,\n    {\n      sendToSignIn,\n      appDetails,\n      connectVersion: version,\n    }\n  );\n\n  try {\n    const authResponse = await provider.authenticationRequest(authRequest);\n    await userSession.handlePendingSignIn(authResponse);\n    const token = decodeToken(authResponse);\n    const payload = token?.payload;\n    const authResponsePayload = payload as unknown as AuthResponsePayload;\n    onFinish?.({\n      authResponse,\n      authResponsePayload,\n      userSession,\n    });\n  } catch (error) {\n    console.error('[Connect] Error during auth request', error);\n    onCancel?.();\n  }\n};\n\nexport const getUserData = async (userSession?: UserSession) => {\n  userSession = getOrCreateUserSession(userSession);\n  if (userSession.isUserSignedIn()) {\n    return userSession.loadUserData();\n  }\n  if (userSession.isSignInPending()) {\n    return userSession.handlePendingSignIn();\n  }\n  return null;\n};\n"]},"metadata":{},"sourceType":"module"}