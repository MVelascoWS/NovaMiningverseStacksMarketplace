{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { cloneDeep } from './utils';\nimport { uintCV, intCV, contractPrincipalCV, standardPrincipalCV, noneCV, bufferCV, falseCV, trueCV, ClarityType, getCVTypeString, bufferCVFromString } from './clarity';\nimport { NotImplementedError } from './errors';\nimport { stringAsciiCV, stringUtf8CV } from './clarity/types/stringCV';\nexport var ClarityAbiTypeId;\n\n(function (ClarityAbiTypeId) {\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeUInt128\"] = 1] = \"ClarityAbiTypeUInt128\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeInt128\"] = 2] = \"ClarityAbiTypeInt128\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeBool\"] = 3] = \"ClarityAbiTypeBool\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypePrincipal\"] = 4] = \"ClarityAbiTypePrincipal\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeNone\"] = 5] = \"ClarityAbiTypeNone\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeBuffer\"] = 6] = \"ClarityAbiTypeBuffer\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeResponse\"] = 7] = \"ClarityAbiTypeResponse\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeOptional\"] = 8] = \"ClarityAbiTypeOptional\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeTuple\"] = 9] = \"ClarityAbiTypeTuple\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeList\"] = 10] = \"ClarityAbiTypeList\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeStringAscii\"] = 11] = \"ClarityAbiTypeStringAscii\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeStringUtf8\"] = 12] = \"ClarityAbiTypeStringUtf8\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeTraitReference\"] = 13] = \"ClarityAbiTypeTraitReference\";\n})(ClarityAbiTypeId || (ClarityAbiTypeId = {}));\n\nexport const isClarityAbiPrimitive = val => typeof val === 'string';\nexport const isClarityAbiBuffer = val => val.buffer !== undefined;\nexport const isClarityAbiStringAscii = val => val['string-ascii'] !== undefined;\nexport const isClarityAbiStringUtf8 = val => val['string-utf8'] !== undefined;\nexport const isClarityAbiResponse = val => val.response !== undefined;\nexport const isClarityAbiOptional = val => val.optional !== undefined;\nexport const isClarityAbiTuple = val => val.tuple !== undefined;\nexport const isClarityAbiList = val => val.list !== undefined;\nexport function getTypeUnion(val) {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'uint128') {\n      return {\n        id: ClarityAbiTypeId.ClarityAbiTypeUInt128,\n        type: val\n      };\n    } else if (val === 'int128') {\n      return {\n        id: ClarityAbiTypeId.ClarityAbiTypeInt128,\n        type: val\n      };\n    } else if (val === 'bool') {\n      return {\n        id: ClarityAbiTypeId.ClarityAbiTypeBool,\n        type: val\n      };\n    } else if (val === 'principal') {\n      return {\n        id: ClarityAbiTypeId.ClarityAbiTypePrincipal,\n        type: val\n      };\n    } else if (val === 'trait_reference') {\n      return {\n        id: ClarityAbiTypeId.ClarityAbiTypeTraitReference,\n        type: val\n      };\n    } else if (val === 'none') {\n      return {\n        id: ClarityAbiTypeId.ClarityAbiTypeNone,\n        type: val\n      };\n    } else {\n      throw new Error(`Unexpected Clarity ABI type primitive: ${JSON.stringify(val)}`);\n    }\n  } else if (isClarityAbiBuffer(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeBuffer,\n      type: val\n    };\n  } else if (isClarityAbiResponse(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeResponse,\n      type: val\n    };\n  } else if (isClarityAbiOptional(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeOptional,\n      type: val\n    };\n  } else if (isClarityAbiTuple(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeTuple,\n      type: val\n    };\n  } else if (isClarityAbiList(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeList,\n      type: val\n    };\n  } else if (isClarityAbiStringAscii(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeStringAscii,\n      type: val\n    };\n  } else if (isClarityAbiStringUtf8(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8,\n      type: val\n    };\n  } else {\n    throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(val)}`);\n  }\n}\n\nfunction encodeClarityValue(input, val) {\n  let union;\n\n  if (input.id !== undefined) {\n    union = input;\n  } else {\n    union = getTypeUnion(input);\n  }\n\n  switch (union.id) {\n    case ClarityAbiTypeId.ClarityAbiTypeUInt128:\n      return uintCV(val);\n\n    case ClarityAbiTypeId.ClarityAbiTypeInt128:\n      return intCV(val);\n\n    case ClarityAbiTypeId.ClarityAbiTypeBool:\n      if (val === 'false' || val === '0') return falseCV();else if (val === 'true' || val === '1') return trueCV();else throw new Error(`Unexpected Clarity bool value: ${JSON.stringify(val)}`);\n\n    case ClarityAbiTypeId.ClarityAbiTypePrincipal:\n      if (val.includes('.')) {\n        const [addr, name] = val.split('.');\n        return contractPrincipalCV(addr, name);\n      } else {\n        return standardPrincipalCV(val);\n      }\n\n    case ClarityAbiTypeId.ClarityAbiTypeTraitReference:\n      const [addr, name] = val.split('.');\n      return contractPrincipalCV(addr, name);\n\n    case ClarityAbiTypeId.ClarityAbiTypeNone:\n      return noneCV();\n\n    case ClarityAbiTypeId.ClarityAbiTypeBuffer:\n      return bufferCV(Buffer.from(val, 'utf8'));\n\n    case ClarityAbiTypeId.ClarityAbiTypeStringAscii:\n      return stringAsciiCV(val);\n\n    case ClarityAbiTypeId.ClarityAbiTypeStringUtf8:\n      return stringUtf8CV(val);\n\n    case ClarityAbiTypeId.ClarityAbiTypeResponse:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n\n    case ClarityAbiTypeId.ClarityAbiTypeOptional:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n\n    case ClarityAbiTypeId.ClarityAbiTypeTuple:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n\n    case ClarityAbiTypeId.ClarityAbiTypeList:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n\n    default:\n      throw new Error(`Unexpected Clarity type ID: ${JSON.stringify(union)}`);\n  }\n}\n\nexport { encodeClarityValue };\nexport function getTypeString(val) {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'int128') {\n      return 'int';\n    } else if (val === 'uint128') {\n      return 'uint';\n    }\n\n    return val;\n  } else if (isClarityAbiBuffer(val)) {\n    return `(buff ${val.buffer.length})`;\n  } else if (isClarityAbiStringAscii(val)) {\n    return `(string-ascii ${val['string-ascii'].length})`;\n  } else if (isClarityAbiStringUtf8(val)) {\n    return `(string-utf8 ${val['string-utf8'].length})`;\n  } else if (isClarityAbiResponse(val)) {\n    return `(response ${getTypeString(val.response.ok)} ${getTypeString(val.response.error)})`;\n  } else if (isClarityAbiOptional(val)) {\n    return `(optional ${getTypeString(val.optional)})`;\n  } else if (isClarityAbiTuple(val)) {\n    return `(tuple ${val.tuple.map(t => `(${t.name} ${getTypeString(t.type)})`).join(' ')})`;\n  } else if (isClarityAbiList(val)) {\n    return `(list ${val.list.length} ${getTypeString(val.list.type)})`;\n  } else {\n    throw new Error(`Type string unsupported for Clarity type: ${JSON.stringify(val)}`);\n  }\n}\nexport function abiFunctionToString(func) {\n  const access = func.access === 'read_only' ? 'read-only' : func.access;\n  return `(define-${access} (${func.name} ${func.args.map(arg => `(${arg.name} ${getTypeString(arg.type)})`).join(' ')}))`;\n}\n\nfunction matchType(cv, abiType) {\n  const union = getTypeUnion(abiType);\n\n  switch (cv.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeBool;\n\n    case ClarityType.Int:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeInt128;\n\n    case ClarityType.UInt:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeUInt128;\n\n    case ClarityType.Buffer:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeBuffer && union.type.buffer.length >= cv.buffer.length;\n\n    case ClarityType.StringASCII:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeStringAscii && union.type['string-ascii'].length >= cv.data.length;\n\n    case ClarityType.StringUTF8:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeStringUtf8 && union.type['string-utf8'].length >= cv.data.length;\n\n    case ClarityType.OptionalNone:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeNone || union.id === ClarityAbiTypeId.ClarityAbiTypeOptional;\n\n    case ClarityType.OptionalSome:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeOptional && matchType(cv.value, union.type.optional);\n\n    case ClarityType.ResponseErr:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeResponse && matchType(cv.value, union.type.response.error);\n\n    case ClarityType.ResponseOk:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeResponse && matchType(cv.value, union.type.response.ok);\n\n    case ClarityType.PrincipalContract:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal || union.id === ClarityAbiTypeId.ClarityAbiTypeTraitReference;\n\n    case ClarityType.PrincipalStandard:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal;\n\n    case ClarityType.List:\n      return union.id == ClarityAbiTypeId.ClarityAbiTypeList && union.type.list.length >= cv.list.length && cv.list.every(val => matchType(val, union.type.list.type));\n\n    case ClarityType.Tuple:\n      if (union.id == ClarityAbiTypeId.ClarityAbiTypeTuple) {\n        const tuple = cloneDeep(cv.data);\n\n        for (let i = 0; i < union.type.tuple.length; i++) {\n          const abiTupleEntry = union.type.tuple[i];\n          const key = abiTupleEntry.name;\n          const val = tuple[key];\n\n          if (val) {\n            if (!matchType(val, abiTupleEntry.type)) {\n              return false;\n            }\n\n            delete tuple[key];\n          } else {\n            return false;\n          }\n        }\n\n        return true;\n      } else {\n        return false;\n      }\n\n    default:\n      return false;\n  }\n}\n\nexport function validateContractCall(payload, abi) {\n  const filtered = abi.functions.filter(fn => fn.name === payload.functionName.content);\n\n  if (filtered.length === 1) {\n    const abiFunc = filtered[0];\n    const abiArgs = abiFunc.args;\n\n    if (payload.functionArgs.length !== abiArgs.length) {\n      throw new Error(`Clarity function expects ${abiArgs.length} argument(s) but received ${payload.functionArgs.length}`);\n    }\n\n    for (let i = 0; i < payload.functionArgs.length; i++) {\n      const payloadArg = payload.functionArgs[i];\n      const abiArg = abiArgs[i];\n\n      if (!matchType(payloadArg, abiArg.type)) {\n        const argNum = i + 1;\n        throw new Error(`Clarity function \\`${payload.functionName.content}\\` expects argument ${argNum} to be of type ${getTypeString(abiArg.type)}, not ${getCVTypeString(payloadArg)}`);\n      }\n    }\n\n    return true;\n  } else if (filtered.length === 0) {\n    throw new Error(`ABI doesn't contain a function with the name ${payload.functionName.content}`);\n  } else {\n    throw new Error(`Malformed ABI. Contains multiple functions with the name ${payload.functionName.content}`);\n  }\n}\nexport function parseToCV(input, type) {\n  const typeString = getTypeString(type);\n\n  if (isClarityAbiPrimitive(type)) {\n    if (type === 'uint128') {\n      return uintCV(input);\n    } else if (type === 'int128') {\n      return intCV(input);\n    } else if (type === 'bool') {\n      if (input.toLowerCase() === 'true') {\n        return trueCV();\n      } else if (input.toLowerCase() === 'false') {\n        return falseCV();\n      } else {\n        throw new Error(`Invalid bool value: ${input}`);\n      }\n    } else if (type === 'principal') {\n      if (input.includes('.')) {\n        const [address, contractName] = input.split('.');\n        return contractPrincipalCV(address, contractName);\n      } else {\n        return standardPrincipalCV(input);\n      }\n    } else {\n      throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n    }\n  } else if (isClarityAbiBuffer(type)) {\n    const inputLength = Buffer.from(input).byteLength;\n\n    if (inputLength > type.buffer.length) {\n      throw new Error(`Input exceeds specified buffer length limit of ${type.buffer.length}`);\n    }\n\n    return bufferCVFromString(input);\n  } else if (isClarityAbiResponse(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiOptional(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiTuple(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiList(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  }\n}","map":{"version":3,"mappings":"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","names":["Buffer","cloneDeep","uintCV","intCV","contractPrincipalCV","standardPrincipalCV","noneCV","bufferCV","falseCV","trueCV","ClarityType","getCVTypeString","bufferCVFromString","NotImplementedError","stringAsciiCV","stringUtf8CV","ClarityAbiTypeId","isClarityAbiPrimitive","val","isClarityAbiBuffer","buffer","undefined","isClarityAbiStringAscii","isClarityAbiStringUtf8","isClarityAbiResponse","response","isClarityAbiOptional","optional","isClarityAbiTuple","tuple","isClarityAbiList","list","getTypeUnion","id","ClarityAbiTypeUInt128","type","ClarityAbiTypeInt128","ClarityAbiTypeBool","ClarityAbiTypePrincipal","ClarityAbiTypeTraitReference","ClarityAbiTypeNone","Error","JSON","stringify","ClarityAbiTypeBuffer","ClarityAbiTypeResponse","ClarityAbiTypeOptional","ClarityAbiTypeTuple","ClarityAbiTypeList","ClarityAbiTypeStringAscii","ClarityAbiTypeStringUtf8","encodeClarityValue","input","union","includes","addr","name","split","from","getTypeString","length","ok","error","map","t","join","abiFunctionToString","func","access","args","arg","matchType","cv","abiType","BoolTrue","BoolFalse","Int","UInt","StringASCII","data","StringUTF8","OptionalNone","OptionalSome","value","ResponseErr","ResponseOk","PrincipalContract","PrincipalStandard","List","every","Tuple","i","abiTupleEntry","key","validateContractCall","payload","abi","filtered","functions","filter","fn","functionName","content","abiFunc","abiArgs","functionArgs","payloadArg","abiArg","argNum","parseToCV","typeString","toLowerCase","address","contractName","inputLength","byteLength"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\transactions\\src\\contract-abi.ts"],"sourcesContent":["import { Buffer } from '@stacks/common';\nimport { cloneDeep } from './utils';\nimport {\n  ClarityValue,\n  uintCV,\n  intCV,\n  contractPrincipalCV,\n  standardPrincipalCV,\n  noneCV,\n  bufferCV,\n  falseCV,\n  trueCV,\n  ClarityType,\n  getCVTypeString,\n  bufferCVFromString,\n} from './clarity';\nimport { ContractCallPayload } from './payload';\nimport { NotImplementedError } from './errors';\nimport { stringAsciiCV, stringUtf8CV } from './clarity/types/stringCV';\n\n// From https://github.com/blockstack/stacks-blockchain-sidecar/blob/master/src/event-stream/contract-abi.ts\n\nexport type ClarityAbiTypeBuffer = { buffer: { length: number } };\nexport type ClarityAbiTypeStringAscii = { 'string-ascii': { length: number } };\nexport type ClarityAbiTypeStringUtf8 = { 'string-utf8': { length: number } };\nexport type ClarityAbiTypeResponse = { response: { ok: ClarityAbiType; error: ClarityAbiType } };\nexport type ClarityAbiTypeOptional = { optional: ClarityAbiType };\nexport type ClarityAbiTypeTuple = { tuple: { name: string; type: ClarityAbiType }[] };\nexport type ClarityAbiTypeList = { list: { type: ClarityAbiType; length: number } };\n\nexport type ClarityAbiTypeUInt128 = 'uint128';\nexport type ClarityAbiTypeInt128 = 'int128';\nexport type ClarityAbiTypeBool = 'bool';\nexport type ClarityAbiTypePrincipal = 'principal';\nexport type ClarityAbiTypeTraitReference = 'trait_reference';\nexport type ClarityAbiTypeNone = 'none';\n\nexport type ClarityAbiTypePrimitive =\n  | ClarityAbiTypeUInt128\n  | ClarityAbiTypeInt128\n  | ClarityAbiTypeBool\n  | ClarityAbiTypePrincipal\n  | ClarityAbiTypeTraitReference\n  | ClarityAbiTypeNone;\n\nexport type ClarityAbiType =\n  | ClarityAbiTypePrimitive\n  | ClarityAbiTypeBuffer\n  | ClarityAbiTypeResponse\n  | ClarityAbiTypeOptional\n  | ClarityAbiTypeTuple\n  | ClarityAbiTypeList\n  | ClarityAbiTypeStringAscii\n  | ClarityAbiTypeStringUtf8\n  | ClarityAbiTypeTraitReference;\n\nexport enum ClarityAbiTypeId {\n  ClarityAbiTypeUInt128 = 1,\n  ClarityAbiTypeInt128 = 2,\n  ClarityAbiTypeBool = 3,\n  ClarityAbiTypePrincipal = 4,\n  ClarityAbiTypeNone = 5,\n  ClarityAbiTypeBuffer = 6,\n  ClarityAbiTypeResponse = 7,\n  ClarityAbiTypeOptional = 8,\n  ClarityAbiTypeTuple = 9,\n  ClarityAbiTypeList = 10,\n  ClarityAbiTypeStringAscii = 11,\n  ClarityAbiTypeStringUtf8 = 12,\n  ClarityAbiTypeTraitReference = 13,\n}\n\nexport const isClarityAbiPrimitive = (val: ClarityAbiType): val is ClarityAbiTypePrimitive =>\n  typeof val === 'string';\nexport const isClarityAbiBuffer = (val: ClarityAbiType): val is ClarityAbiTypeBuffer =>\n  (val as ClarityAbiTypeBuffer).buffer !== undefined;\nexport const isClarityAbiStringAscii = (val: ClarityAbiType): val is ClarityAbiTypeStringAscii =>\n  (val as ClarityAbiTypeStringAscii)['string-ascii'] !== undefined;\nexport const isClarityAbiStringUtf8 = (val: ClarityAbiType): val is ClarityAbiTypeStringUtf8 =>\n  (val as ClarityAbiTypeStringUtf8)['string-utf8'] !== undefined;\nexport const isClarityAbiResponse = (val: ClarityAbiType): val is ClarityAbiTypeResponse =>\n  (val as ClarityAbiTypeResponse).response !== undefined;\nexport const isClarityAbiOptional = (val: ClarityAbiType): val is ClarityAbiTypeOptional =>\n  (val as ClarityAbiTypeOptional).optional !== undefined;\nexport const isClarityAbiTuple = (val: ClarityAbiType): val is ClarityAbiTypeTuple =>\n  (val as ClarityAbiTypeTuple).tuple !== undefined;\nexport const isClarityAbiList = (val: ClarityAbiType): val is ClarityAbiTypeList =>\n  (val as ClarityAbiTypeList).list !== undefined;\n\nexport type ClarityAbiTypeUnion =\n  | { id: ClarityAbiTypeId.ClarityAbiTypeUInt128; type: ClarityAbiTypeUInt128 }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeInt128; type: ClarityAbiTypeInt128 }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeBool; type: ClarityAbiTypeBool }\n  | { id: ClarityAbiTypeId.ClarityAbiTypePrincipal; type: ClarityAbiTypePrincipal }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference; type: ClarityAbiTypeTraitReference }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeNone; type: ClarityAbiTypeNone }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeBuffer; type: ClarityAbiTypeBuffer }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeResponse; type: ClarityAbiTypeResponse }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeOptional; type: ClarityAbiTypeOptional }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeTuple; type: ClarityAbiTypeTuple }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeList; type: ClarityAbiTypeList }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii; type: ClarityAbiTypeStringAscii }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8; type: ClarityAbiTypeStringUtf8 };\n\nexport function getTypeUnion(val: ClarityAbiType): ClarityAbiTypeUnion {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'uint128') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeUInt128, type: val };\n    } else if (val === 'int128') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeInt128, type: val };\n    } else if (val === 'bool') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeBool, type: val };\n    } else if (val === 'principal') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypePrincipal, type: val };\n    } else if (val === 'trait_reference') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference, type: val };\n    } else if (val === 'none') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeNone, type: val };\n    } else {\n      throw new Error(`Unexpected Clarity ABI type primitive: ${JSON.stringify(val)}`);\n    }\n  } else if (isClarityAbiBuffer(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeBuffer, type: val };\n  } else if (isClarityAbiResponse(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeResponse, type: val };\n  } else if (isClarityAbiOptional(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeOptional, type: val };\n  } else if (isClarityAbiTuple(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeTuple, type: val };\n  } else if (isClarityAbiList(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeList, type: val };\n  } else if (isClarityAbiStringAscii(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii, type: val };\n  } else if (isClarityAbiStringUtf8(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8, type: val };\n  } else {\n    throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(val)}`);\n  }\n}\n\nfunction encodeClarityValue(type: ClarityAbiType, val: string): ClarityValue;\nfunction encodeClarityValue(type: ClarityAbiTypeUnion, val: string): ClarityValue;\nfunction encodeClarityValue(\n  input: ClarityAbiTypeUnion | ClarityAbiType,\n  val: string\n): ClarityValue {\n  let union: ClarityAbiTypeUnion;\n  if ((input as ClarityAbiTypeUnion).id !== undefined) {\n    union = input as ClarityAbiTypeUnion;\n  } else {\n    union = getTypeUnion(input as ClarityAbiType);\n  }\n  switch (union.id) {\n    case ClarityAbiTypeId.ClarityAbiTypeUInt128:\n      return uintCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeInt128:\n      return intCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeBool:\n      if (val === 'false' || val === '0') return falseCV();\n      else if (val === 'true' || val === '1') return trueCV();\n      else throw new Error(`Unexpected Clarity bool value: ${JSON.stringify(val)}`);\n    case ClarityAbiTypeId.ClarityAbiTypePrincipal:\n      if (val.includes('.')) {\n        const [addr, name] = val.split('.');\n        return contractPrincipalCV(addr, name);\n      } else {\n        return standardPrincipalCV(val);\n      }\n    case ClarityAbiTypeId.ClarityAbiTypeTraitReference:\n      const [addr, name] = val.split('.');\n      return contractPrincipalCV(addr, name);\n    case ClarityAbiTypeId.ClarityAbiTypeNone:\n      return noneCV();\n    case ClarityAbiTypeId.ClarityAbiTypeBuffer:\n      return bufferCV(Buffer.from(val, 'utf8'));\n    case ClarityAbiTypeId.ClarityAbiTypeStringAscii:\n      return stringAsciiCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeStringUtf8:\n      return stringUtf8CV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeResponse:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeOptional:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeTuple:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeList:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    default:\n      throw new Error(`Unexpected Clarity type ID: ${JSON.stringify(union)}`);\n  }\n}\nexport { encodeClarityValue };\n\nexport function getTypeString(val: ClarityAbiType): string {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'int128') {\n      return 'int';\n    } else if (val === 'uint128') {\n      return 'uint';\n    }\n    return val;\n  } else if (isClarityAbiBuffer(val)) {\n    return `(buff ${val.buffer.length})`;\n  } else if (isClarityAbiStringAscii(val)) {\n    return `(string-ascii ${val['string-ascii'].length})`;\n  } else if (isClarityAbiStringUtf8(val)) {\n    return `(string-utf8 ${val['string-utf8'].length})`;\n  } else if (isClarityAbiResponse(val)) {\n    return `(response ${getTypeString(val.response.ok)} ${getTypeString(val.response.error)})`;\n  } else if (isClarityAbiOptional(val)) {\n    return `(optional ${getTypeString(val.optional)})`;\n  } else if (isClarityAbiTuple(val)) {\n    return `(tuple ${val.tuple.map(t => `(${t.name} ${getTypeString(t.type)})`).join(' ')})`;\n  } else if (isClarityAbiList(val)) {\n    return `(list ${val.list.length} ${getTypeString(val.list.type)})`;\n  } else {\n    throw new Error(`Type string unsupported for Clarity type: ${JSON.stringify(val)}`);\n  }\n}\n\nexport interface ClarityAbiFunction {\n  name: string;\n  access: 'private' | 'public' | 'read_only';\n  args: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n  outputs: {\n    type: ClarityAbiType;\n  };\n}\n\nexport function abiFunctionToString(func: ClarityAbiFunction): string {\n  const access = func.access === 'read_only' ? 'read-only' : func.access;\n  return `(define-${access} (${func.name} ${func.args\n    .map(arg => `(${arg.name} ${getTypeString(arg.type)})`)\n    .join(' ')}))`;\n}\n\nexport interface ClarityAbiVariable {\n  name: string;\n  access: 'variable' | 'constant';\n  type: ClarityAbiType;\n}\n\nexport interface ClarityAbiMap {\n  name: string;\n  key: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n  value: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n}\n\nexport interface ClarityAbiTypeFungibleToken {\n  name: string;\n}\n\nexport interface ClarityAbiTypeNonFungibleToken {\n  name: string;\n  type: ClarityAbiType;\n}\n\nexport interface ClarityAbi {\n  functions: ClarityAbiFunction[];\n  variables: ClarityAbiVariable[];\n  maps: ClarityAbiMap[];\n  fungible_tokens: ClarityAbiTypeFungibleToken[];\n  non_fungible_tokens: ClarityAbiTypeNonFungibleToken[];\n}\n\nfunction matchType(cv: ClarityValue, abiType: ClarityAbiType): boolean {\n  const union = getTypeUnion(abiType);\n\n  switch (cv.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeBool;\n    case ClarityType.Int:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeInt128;\n    case ClarityType.UInt:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeUInt128;\n    case ClarityType.Buffer:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeBuffer &&\n        union.type.buffer.length >= cv.buffer.length\n      );\n    case ClarityType.StringASCII:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeStringAscii &&\n        union.type['string-ascii'].length >= cv.data.length\n      );\n    case ClarityType.StringUTF8:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeStringUtf8 &&\n        union.type['string-utf8'].length >= cv.data.length\n      );\n    case ClarityType.OptionalNone:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeNone ||\n        union.id === ClarityAbiTypeId.ClarityAbiTypeOptional\n      );\n    case ClarityType.OptionalSome:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeOptional &&\n        matchType(cv.value, union.type.optional)\n      );\n    case ClarityType.ResponseErr:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&\n        matchType(cv.value, union.type.response.error)\n      );\n    case ClarityType.ResponseOk:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&\n        matchType(cv.value, union.type.response.ok)\n      );\n    case ClarityType.PrincipalContract:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal ||\n        union.id === ClarityAbiTypeId.ClarityAbiTypeTraitReference\n      );\n    case ClarityType.PrincipalStandard:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal;\n    case ClarityType.List:\n      return (\n        union.id == ClarityAbiTypeId.ClarityAbiTypeList &&\n        union.type.list.length >= cv.list.length &&\n        cv.list.every(val => matchType(val, union.type.list.type))\n      );\n    case ClarityType.Tuple:\n      if (union.id == ClarityAbiTypeId.ClarityAbiTypeTuple) {\n        const tuple = cloneDeep(cv.data);\n        for (let i = 0; i < union.type.tuple.length; i++) {\n          const abiTupleEntry = union.type.tuple[i];\n          const key = abiTupleEntry.name;\n          const val = tuple[key];\n\n          // if key exists in cv tuple, check if its type matches the abi\n          // return false if key doesn't exist\n          if (val) {\n            if (!matchType(val, abiTupleEntry.type)) {\n              return false;\n            }\n            delete tuple[key];\n          } else {\n            return false;\n          }\n        }\n        return true;\n      } else {\n        return false;\n      }\n    default:\n      return false;\n  }\n}\n\n/**\n * Validates a contract-call payload with a contract ABI\n *\n * @param {ContractCallPayload} payload - a contract-call payload\n * @param {ClarityAbi} abi - a contract ABI\n *\n * @returns {boolean} true if the payloads functionArgs type check against those in the ABI\n */\nexport function validateContractCall(payload: ContractCallPayload, abi: ClarityAbi): boolean {\n  const filtered = abi.functions.filter(fn => fn.name === payload.functionName.content);\n  if (filtered.length === 1) {\n    const abiFunc = filtered[0];\n    const abiArgs = abiFunc.args;\n\n    if (payload.functionArgs.length !== abiArgs.length) {\n      throw new Error(\n        `Clarity function expects ${abiArgs.length} argument(s) but received ${payload.functionArgs.length}`\n      );\n    }\n\n    for (let i = 0; i < payload.functionArgs.length; i++) {\n      const payloadArg = payload.functionArgs[i];\n      const abiArg = abiArgs[i];\n\n      if (!matchType(payloadArg, abiArg.type)) {\n        const argNum = i + 1;\n        throw new Error(\n          `Clarity function \\`${\n            payload.functionName.content\n          }\\` expects argument ${argNum} to be of type ${getTypeString(\n            abiArg.type\n          )}, not ${getCVTypeString(payloadArg)}`\n        );\n      }\n    }\n\n    return true;\n  } else if (filtered.length === 0) {\n    throw new Error(`ABI doesn't contain a function with the name ${payload.functionName.content}`);\n  } else {\n    throw new Error(\n      `Malformed ABI. Contains multiple functions with the name ${payload.functionName.content}`\n    );\n  }\n}\n\n/**\n * Convert string input to Clarity value based on contract ABI data. Only handles Clarity\n * primitives and buffers. Responses, optionals, tuples and lists are not supported.\n *\n * @param {string} input - string to be parsed into Clarity value\n * @param {ClarityAbiType} type - the contract function argument object\n *\n * @returns {ClarityValue} returns a Clarity value\n */\nexport function parseToCV(input: string, type: ClarityAbiType): ClarityValue {\n  const typeString = getTypeString(type);\n  if (isClarityAbiPrimitive(type)) {\n    if (type === 'uint128') {\n      return uintCV(input);\n    } else if (type === 'int128') {\n      return intCV(input);\n    } else if (type === 'bool') {\n      if (input.toLowerCase() === 'true') {\n        return trueCV();\n      } else if (input.toLowerCase() === 'false') {\n        return falseCV();\n      } else {\n        throw new Error(`Invalid bool value: ${input}`);\n      }\n    } else if (type === 'principal') {\n      if (input.includes('.')) {\n        const [address, contractName] = input.split('.');\n        return contractPrincipalCV(address, contractName);\n      } else {\n        return standardPrincipalCV(input);\n      }\n    } else {\n      throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n    }\n  } else if (isClarityAbiBuffer(type)) {\n    const inputLength = Buffer.from(input).byteLength;\n    if (inputLength > type.buffer.length) {\n      throw new Error(`Input exceeds specified buffer length limit of ${type.buffer.length}`);\n    }\n    return bufferCVFromString(input);\n  } else if (isClarityAbiResponse(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiOptional(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiTuple(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiList(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}