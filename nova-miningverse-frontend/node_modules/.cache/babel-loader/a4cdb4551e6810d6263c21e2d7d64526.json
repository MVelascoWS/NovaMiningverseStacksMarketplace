{"ast":null,"code":"import { Buffer, toTwos, toBuffer } from '@stacks/common';\nimport { serializeAddress, serializeLPString } from '../types';\nimport { createLPString } from '../postcondition-types';\nimport { ClarityType } from './constants';\nimport { BufferArray } from '../utils';\nimport { SerializationError } from '../errors';\nimport { CLARITY_INT_BYTE_SIZE, CLARITY_INT_SIZE } from '../constants';\n\nfunction bufferWithTypeID(typeId, buffer) {\n  const id = Buffer.from([typeId]);\n  return Buffer.concat([id, buffer]);\n}\n\nfunction serializeBoolCV(value) {\n  return Buffer.from([value.type]);\n}\n\nfunction serializeOptionalCV(cv) {\n  if (cv.type === ClarityType.OptionalNone) {\n    return Buffer.from([cv.type]);\n  } else {\n    return bufferWithTypeID(cv.type, serializeCV(cv.value));\n  }\n}\n\nfunction serializeBufferCV(cv) {\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(cv.buffer.length, 0);\n  return bufferWithTypeID(cv.type, Buffer.concat([length, cv.buffer]));\n}\n\nfunction serializeIntCV(cv) {\n  const buffer = toBuffer(toTwos(cv.value, BigInt(CLARITY_INT_SIZE)), CLARITY_INT_BYTE_SIZE);\n  return bufferWithTypeID(cv.type, buffer);\n}\n\nfunction serializeUIntCV(cv) {\n  const buffer = toBuffer(cv.value, CLARITY_INT_BYTE_SIZE);\n  return bufferWithTypeID(cv.type, buffer);\n}\n\nfunction serializeStandardPrincipalCV(cv) {\n  return bufferWithTypeID(cv.type, serializeAddress(cv.address));\n}\n\nfunction serializeContractPrincipalCV(cv) {\n  return bufferWithTypeID(cv.type, Buffer.concat([serializeAddress(cv.address), serializeLPString(cv.contractName)]));\n}\n\nfunction serializeResponseCV(cv) {\n  return bufferWithTypeID(cv.type, serializeCV(cv.value));\n}\n\nfunction serializeListCV(cv) {\n  const buffers = new BufferArray();\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(cv.list.length, 0);\n  buffers.push(length);\n\n  for (const value of cv.list) {\n    const serializedValue = serializeCV(value);\n    buffers.push(serializedValue);\n  }\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeTupleCV(cv) {\n  const buffers = new BufferArray();\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(Object.keys(cv.data).length, 0);\n  buffers.push(length);\n  const lexicographicOrder = Object.keys(cv.data).sort((a, b) => {\n    const bufA = Buffer.from(a);\n    const bufB = Buffer.from(b);\n    return bufA.compare(bufB);\n  });\n\n  for (const key of lexicographicOrder) {\n    const nameWithLength = createLPString(key);\n    buffers.push(serializeLPString(nameWithLength));\n    const serializedValue = serializeCV(cv.data[key]);\n    buffers.push(serializedValue);\n  }\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeStringCV(cv, encoding) {\n  const buffers = new BufferArray();\n  const str = Buffer.from(cv.data, encoding);\n  const len = Buffer.alloc(4);\n  len.writeUInt32BE(str.length, 0);\n  buffers.push(len);\n  buffers.push(str);\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeStringAsciiCV(cv) {\n  return serializeStringCV(cv, 'ascii');\n}\n\nfunction serializeStringUtf8CV(cv) {\n  return serializeStringCV(cv, 'utf8');\n}\n\nexport function serializeCV(value) {\n  switch (value.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return serializeBoolCV(value);\n\n    case ClarityType.OptionalNone:\n    case ClarityType.OptionalSome:\n      return serializeOptionalCV(value);\n\n    case ClarityType.Buffer:\n      return serializeBufferCV(value);\n\n    case ClarityType.UInt:\n      return serializeUIntCV(value);\n\n    case ClarityType.Int:\n      return serializeIntCV(value);\n\n    case ClarityType.PrincipalStandard:\n      return serializeStandardPrincipalCV(value);\n\n    case ClarityType.PrincipalContract:\n      return serializeContractPrincipalCV(value);\n\n    case ClarityType.ResponseOk:\n    case ClarityType.ResponseErr:\n      return serializeResponseCV(value);\n\n    case ClarityType.List:\n      return serializeListCV(value);\n\n    case ClarityType.Tuple:\n      return serializeTupleCV(value);\n\n    case ClarityType.StringASCII:\n      return serializeStringAsciiCV(value);\n\n    case ClarityType.StringUTF8:\n      return serializeStringUtf8CV(value);\n\n    default:\n      throw new SerializationError('Unable to serialize. Invalid Clarity Value.');\n  }\n}","map":{"version":3,"mappings":"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","names":["Buffer","toTwos","toBuffer","serializeAddress","serializeLPString","createLPString","ClarityType","BufferArray","SerializationError","CLARITY_INT_BYTE_SIZE","CLARITY_INT_SIZE","bufferWithTypeID","typeId","buffer","id","from","concat","serializeBoolCV","value","type","serializeOptionalCV","cv","OptionalNone","serializeCV","serializeBufferCV","length","alloc","writeUInt32BE","serializeIntCV","BigInt","serializeUIntCV","serializeStandardPrincipalCV","address","serializeContractPrincipalCV","contractName","serializeResponseCV","serializeListCV","buffers","list","push","serializedValue","concatBuffer","serializeTupleCV","Object","keys","data","lexicographicOrder","sort","a","b","bufA","bufB","compare","key","nameWithLength","serializeStringCV","encoding","str","len","serializeStringAsciiCV","serializeStringUtf8CV","BoolTrue","BoolFalse","OptionalSome","UInt","Int","PrincipalStandard","PrincipalContract","ResponseOk","ResponseErr","List","Tuple","StringASCII","StringUTF8"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\transactions\\src\\clarity\\serialize.ts"],"sourcesContent":["import { Buffer, toTwos, toBuffer } from '@stacks/common';\nimport { serializeAddress, serializeLPString } from '../types';\nimport { createLPString } from '../postcondition-types';\nimport {\n  BooleanCV,\n  OptionalCV,\n  BufferCV,\n  IntCV,\n  UIntCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  ResponseCV,\n  ListCV,\n  TupleCV,\n  ClarityValue,\n} from '.';\nimport { ClarityType } from './constants';\nimport { BufferArray } from '../utils';\nimport { SerializationError } from '../errors';\nimport { StringAsciiCV, StringUtf8CV } from './types/stringCV';\nimport { CLARITY_INT_BYTE_SIZE, CLARITY_INT_SIZE } from '../constants';\n\nfunction bufferWithTypeID(typeId: ClarityType, buffer: Buffer): Buffer {\n  const id = Buffer.from([typeId]);\n  return Buffer.concat([id, buffer]);\n}\n\nfunction serializeBoolCV(value: BooleanCV): Buffer {\n  return Buffer.from([value.type]);\n}\n\nfunction serializeOptionalCV(cv: OptionalCV): Buffer {\n  if (cv.type === ClarityType.OptionalNone) {\n    return Buffer.from([cv.type]);\n  } else {\n    return bufferWithTypeID(cv.type, serializeCV(cv.value));\n  }\n}\n\nfunction serializeBufferCV(cv: BufferCV): Buffer {\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(cv.buffer.length, 0);\n  return bufferWithTypeID(cv.type, Buffer.concat([length, cv.buffer]));\n}\n\nfunction serializeIntCV(cv: IntCV): Buffer {\n  const buffer = toBuffer(toTwos(cv.value, BigInt(CLARITY_INT_SIZE)), CLARITY_INT_BYTE_SIZE);\n  return bufferWithTypeID(cv.type, buffer);\n}\n\nfunction serializeUIntCV(cv: UIntCV): Buffer {\n  const buffer = toBuffer(cv.value, CLARITY_INT_BYTE_SIZE);\n  return bufferWithTypeID(cv.type, buffer);\n}\n\nfunction serializeStandardPrincipalCV(cv: StandardPrincipalCV): Buffer {\n  return bufferWithTypeID(cv.type, serializeAddress(cv.address));\n}\n\nfunction serializeContractPrincipalCV(cv: ContractPrincipalCV): Buffer {\n  return bufferWithTypeID(\n    cv.type,\n    Buffer.concat([serializeAddress(cv.address), serializeLPString(cv.contractName)])\n  );\n}\n\nfunction serializeResponseCV(cv: ResponseCV) {\n  return bufferWithTypeID(cv.type, serializeCV(cv.value));\n}\n\nfunction serializeListCV(cv: ListCV) {\n  const buffers = new BufferArray();\n\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(cv.list.length, 0);\n  buffers.push(length);\n\n  for (const value of cv.list) {\n    const serializedValue = serializeCV(value);\n    buffers.push(serializedValue);\n  }\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeTupleCV(cv: TupleCV) {\n  const buffers = new BufferArray();\n\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(Object.keys(cv.data).length, 0);\n  buffers.push(length);\n\n  const lexicographicOrder = Object.keys(cv.data).sort((a, b) => {\n    const bufA = Buffer.from(a);\n    const bufB = Buffer.from(b);\n    return bufA.compare(bufB);\n  });\n\n  for (const key of lexicographicOrder) {\n    const nameWithLength = createLPString(key);\n    buffers.push(serializeLPString(nameWithLength));\n\n    const serializedValue = serializeCV(cv.data[key]);\n    buffers.push(serializedValue);\n  }\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeStringCV(cv: StringAsciiCV | StringUtf8CV, encoding: 'ascii' | 'utf8') {\n  const buffers = new BufferArray();\n\n  const str = Buffer.from(cv.data, encoding);\n  const len = Buffer.alloc(4);\n  len.writeUInt32BE(str.length, 0);\n\n  buffers.push(len);\n  buffers.push(str);\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeStringAsciiCV(cv: StringAsciiCV) {\n  return serializeStringCV(cv, 'ascii');\n}\n\nfunction serializeStringUtf8CV(cv: StringUtf8CV) {\n  return serializeStringCV(cv, 'utf8');\n}\n\n/**\n * Serializes clarity value to buffer\n *\n * @param {value} clarity value to be converted to buffer\n **\n * @returns {Buffer} returns the buffer instance\n *\n * @example\n * ```\n *  import { intCV, serializeCV } from '@stacks/transactions';\n *\n *  const serialized = serializeCV(intCV(100)); // Similarly works for other clarity types as well like listCV, booleanCV ...\n *\n *  // <Buffer 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 64>\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nexport function serializeCV(value: ClarityValue): Buffer {\n  switch (value.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return serializeBoolCV(value);\n    case ClarityType.OptionalNone:\n    case ClarityType.OptionalSome:\n      return serializeOptionalCV(value);\n    case ClarityType.Buffer:\n      return serializeBufferCV(value);\n    case ClarityType.UInt:\n      return serializeUIntCV(value);\n    case ClarityType.Int:\n      return serializeIntCV(value);\n    case ClarityType.PrincipalStandard:\n      return serializeStandardPrincipalCV(value);\n    case ClarityType.PrincipalContract:\n      return serializeContractPrincipalCV(value);\n    case ClarityType.ResponseOk:\n    case ClarityType.ResponseErr:\n      return serializeResponseCV(value);\n    case ClarityType.List:\n      return serializeListCV(value);\n    case ClarityType.Tuple:\n      return serializeTupleCV(value);\n    case ClarityType.StringASCII:\n      return serializeStringAsciiCV(value);\n    case ClarityType.StringUTF8:\n      return serializeStringUtf8CV(value);\n    default:\n      throw new SerializationError('Unable to serialize. Invalid Clarity Value.');\n  }\n}\n"]},"metadata":{},"sourceType":"module"}