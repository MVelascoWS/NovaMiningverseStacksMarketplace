{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { validateMnemonic, mnemonicToEntropy, entropyToMnemonic } from '@scure/bip39';\nimport { wordlist } from '@scure/bip39/wordlists/english';\nimport { randomBytes } from './cryptoRandom';\nimport { createSha2Hash } from './sha2Hash';\nimport { createHmacSha256 } from './hmacSha256';\nimport { createCipher } from './aesCipher';\nimport { createPbkdf2 } from './pbkdf2';\nexport async function encryptMnemonic(phrase, password, opts) {\n  let mnemonicEntropy;\n\n  try {\n    const entropyBytes = mnemonicToEntropy(phrase, wordlist);\n    mnemonicEntropy = Buffer.from(entropyBytes).toString('hex');\n  } catch (error) {\n    console.error('Invalid mnemonic phrase provided');\n    console.error(error);\n    throw new Error('Not a valid bip39 mnemonic');\n  }\n\n  const plaintextNormalized = Buffer.from(mnemonicEntropy, 'hex');\n  const pbkdf2 = await createPbkdf2();\n  let salt;\n\n  if (opts && opts.getRandomBytes) {\n    salt = opts.getRandomBytes(16);\n  } else {\n    salt = randomBytes(16);\n  }\n\n  const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');\n  const encKey = keysAndIV.slice(0, 16);\n  const macKey = keysAndIV.slice(16, 32);\n  const iv = keysAndIV.slice(32, 48);\n  const cipher = await createCipher();\n  const cipherText = await cipher.encrypt('aes-128-cbc', encKey, iv, plaintextNormalized);\n  const hmacPayload = Buffer.concat([salt, cipherText]);\n  const hmacSha256 = await createHmacSha256();\n  const hmacDigest = await hmacSha256.digest(macKey, hmacPayload);\n  const payload = Buffer.concat([salt, hmacDigest, cipherText]);\n  return payload;\n}\n\nclass PasswordError extends Error {}\n\nasync function decryptMnemonicBuffer(dataBuffer, password) {\n  const salt = dataBuffer.slice(0, 16);\n  const hmacSig = dataBuffer.slice(16, 48);\n  const cipherText = dataBuffer.slice(48);\n  const hmacPayload = Buffer.concat([salt, cipherText]);\n  const pbkdf2 = await createPbkdf2();\n  const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');\n  const encKey = keysAndIV.slice(0, 16);\n  const macKey = keysAndIV.slice(16, 32);\n  const iv = keysAndIV.slice(32, 48);\n  const decipher = await createCipher();\n  const decryptedResult = await decipher.decrypt('aes-128-cbc', encKey, iv, cipherText);\n  const hmacSha256 = await createHmacSha256();\n  const hmacDigest = await hmacSha256.digest(macKey, hmacPayload);\n  const sha2Hash = await createSha2Hash();\n  const hmacSigHash = await sha2Hash.digest(hmacSig);\n  const hmacDigestHash = await sha2Hash.digest(hmacDigest);\n\n  if (!hmacSigHash.equals(hmacDigestHash)) {\n    throw new PasswordError('Wrong password (HMAC mismatch)');\n  }\n\n  let mnemonic;\n\n  try {\n    mnemonic = entropyToMnemonic(decryptedResult, wordlist);\n  } catch (error) {\n    console.error('Error thrown by `entropyToMnemonic`');\n    console.error(error);\n    throw new PasswordError('Wrong password (invalid plaintext)');\n  }\n\n  if (!validateMnemonic(mnemonic, wordlist)) {\n    throw new PasswordError('Wrong password (invalid plaintext)');\n  }\n\n  return mnemonic;\n}\n\nfunction decryptLegacy(dataBuffer, password, triplesecDecrypt) {\n  return new Promise((resolve, reject) => {\n    if (!triplesecDecrypt) {\n      reject(new Error('The `triplesec.decrypt` function must be provided'));\n    }\n\n    triplesecDecrypt({\n      key: Buffer.from(password),\n      data: dataBuffer\n    }, (err, plaintextBuffer) => {\n      if (!err) {\n        resolve(plaintextBuffer);\n      } else {\n        reject(err);\n      }\n    });\n  });\n}\n\nexport async function decryptMnemonic(data, password, triplesecDecrypt) {\n  const dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');\n\n  try {\n    return await decryptMnemonicBuffer(dataBuffer, password);\n  } catch (err) {\n    if (err instanceof PasswordError) {\n      throw err;\n    }\n\n    const data = await decryptLegacy(dataBuffer, password, triplesecDecrypt);\n    return data.toString();\n  }\n}","map":{"version":3,"mappings":"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","names":["Buffer","validateMnemonic","mnemonicToEntropy","entropyToMnemonic","wordlist","randomBytes","createSha2Hash","createHmacSha256","createCipher","createPbkdf2","encryptMnemonic","phrase","password","opts","mnemonicEntropy","entropyBytes","from","toString","error","console","Error","plaintextNormalized","pbkdf2","salt","getRandomBytes","keysAndIV","derive","encKey","slice","macKey","iv","cipher","cipherText","encrypt","hmacPayload","concat","hmacSha256","hmacDigest","digest","payload","PasswordError","decryptMnemonicBuffer","dataBuffer","hmacSig","decipher","decryptedResult","decrypt","sha2Hash","hmacSigHash","hmacDigestHash","equals","mnemonic","decryptLegacy","triplesecDecrypt","Promise","resolve","reject","key","data","err","plaintextBuffer","decryptMnemonic","isBuffer"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\encryption\\src\\wallet.ts"],"sourcesContent":["import { Buffer } from '@stacks/common';\n// https://github.com/paulmillr/scure-bip39\n// Secure, audited & minimal implementation of BIP39 mnemonic phrases.\nimport { validateMnemonic, mnemonicToEntropy, entropyToMnemonic } from '@scure/bip39';\n// Word lists not imported by default as that would increase bundle sizes too much as in case of bitcoinjs/bip39\n// Use default english world list similiar to bitcoinjs/bip39\n// Backward compatible with bitcoinjs/bip39 dependency\n// Very small in size as compared to bitcoinjs/bip39 wordlist\n// Reference: https://github.com/paulmillr/scure-bip39\nimport { wordlist } from '@scure/bip39/wordlists/english';\nimport { randomBytes, GetRandomBytes } from './cryptoRandom';\nimport { createSha2Hash } from './sha2Hash';\nimport { createHmacSha256 } from './hmacSha256';\nimport { createCipher } from './aesCipher';\nimport { createPbkdf2 } from './pbkdf2';\nimport { TriplesecDecryptSignature } from './cryptoUtils';\n\n/**\n * Encrypt a raw mnemonic phrase to be password protected\n * @param {string} phrase - Raw mnemonic phrase\n * @param {string} password - Password to encrypt mnemonic with\n * @return {Promise<Buffer>} The encrypted phrase\n * @private\n * @ignore\n * */\nexport async function encryptMnemonic(\n  phrase: string,\n  password: string,\n  opts?: {\n    getRandomBytes?: GetRandomBytes;\n  }\n): Promise<Buffer> {\n  // hex encoded mnemonic string\n  let mnemonicEntropy: string;\n  try {\n    // must be bip39 mnemonic\n    // `mnemonicToEntropy` converts mnemonic string to raw entropy in form of byte array\n    const entropyBytes = mnemonicToEntropy(phrase, wordlist);\n    // Convert byte array to hex string\n    mnemonicEntropy = Buffer.from(entropyBytes).toString('hex');\n  } catch (error) {\n    console.error('Invalid mnemonic phrase provided');\n    console.error(error);\n    throw new Error('Not a valid bip39 mnemonic');\n  }\n\n  // normalize plaintext to fixed length byte string\n  const plaintextNormalized = Buffer.from(mnemonicEntropy, 'hex');\n\n  // AES-128-CBC with SHA256 HMAC\n  const pbkdf2 = await createPbkdf2();\n  let salt: Buffer;\n  if (opts && opts.getRandomBytes) {\n    salt = opts.getRandomBytes(16);\n  } else {\n    salt = randomBytes(16);\n  }\n  const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');\n  const encKey = keysAndIV.slice(0, 16);\n  const macKey = keysAndIV.slice(16, 32);\n  const iv = keysAndIV.slice(32, 48);\n\n  const cipher = await createCipher();\n  const cipherText = await cipher.encrypt('aes-128-cbc', encKey, iv, plaintextNormalized);\n\n  const hmacPayload = Buffer.concat([salt, cipherText]);\n  const hmacSha256 = await createHmacSha256();\n  const hmacDigest = await hmacSha256.digest(macKey, hmacPayload);\n\n  const payload = Buffer.concat([salt, hmacDigest, cipherText]);\n  return payload;\n}\n\n// Used to distinguish bad password during decrypt vs invalid format\nclass PasswordError extends Error {}\n\n/**\n * @ignore\n */\nasync function decryptMnemonicBuffer(dataBuffer: Buffer, password: string): Promise<string> {\n  const salt = dataBuffer.slice(0, 16);\n  const hmacSig = dataBuffer.slice(16, 48); // 32 bytes\n  const cipherText = dataBuffer.slice(48);\n  const hmacPayload = Buffer.concat([salt, cipherText]);\n\n  const pbkdf2 = await createPbkdf2();\n  const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');\n  const encKey = keysAndIV.slice(0, 16);\n  const macKey = keysAndIV.slice(16, 32);\n  const iv = keysAndIV.slice(32, 48);\n\n  const decipher = await createCipher();\n  const decryptedResult = await decipher.decrypt('aes-128-cbc', encKey, iv, cipherText);\n\n  const hmacSha256 = await createHmacSha256();\n  const hmacDigest = await hmacSha256.digest(macKey, hmacPayload);\n\n  // hash both hmacSig and hmacDigest so string comparison time\n  // is uncorrelated to the ciphertext\n  const sha2Hash = await createSha2Hash();\n  const hmacSigHash = await sha2Hash.digest(hmacSig);\n  const hmacDigestHash = await sha2Hash.digest(hmacDigest);\n\n  if (!hmacSigHash.equals(hmacDigestHash)) {\n    // not authentic\n    throw new PasswordError('Wrong password (HMAC mismatch)');\n  }\n\n  let mnemonic: string;\n  try {\n    // Converts raw entropy in form of byte array to mnemonic string\n    mnemonic = entropyToMnemonic(decryptedResult, wordlist);\n  } catch (error) {\n    console.error('Error thrown by `entropyToMnemonic`');\n    console.error(error);\n    throw new PasswordError('Wrong password (invalid plaintext)');\n  }\n  // Validates mnemonic for being 12-24 words contained in `wordlist`\n  if (!validateMnemonic(mnemonic, wordlist)) {\n    throw new PasswordError('Wrong password (invalid plaintext)');\n  }\n\n  return mnemonic;\n}\n\n/**\n * Decrypt legacy triplesec keys\n * @param {Buffer} dataBuffer - The encrypted key\n * @param {String} password - Password for data\n * @return {Promise<Buffer>} Decrypted seed\n * @private\n * @ignore\n */\nfunction decryptLegacy(\n  dataBuffer: Buffer,\n  password: string,\n  triplesecDecrypt?: TriplesecDecryptSignature\n): Promise<Buffer> {\n  return new Promise<Buffer>((resolve, reject) => {\n    if (!triplesecDecrypt) {\n      reject(new Error('The `triplesec.decrypt` function must be provided'));\n    }\n    triplesecDecrypt!(\n      {\n        key: Buffer.from(password),\n        data: dataBuffer,\n      },\n      (err, plaintextBuffer) => {\n        if (!err) {\n          resolve(plaintextBuffer!);\n        } else {\n          reject(err);\n        }\n      }\n    );\n  });\n}\n\n/**\n * Decrypt an encrypted mnemonic phrase with a password.\n * Legacy triplesec encrypted payloads are also supported.\n * @param data - Buffer or hex-encoded string of the encrypted mnemonic\n * @param password - Password for data\n * @return the raw mnemonic phrase\n * @private\n * @ignore\n */\nexport async function decryptMnemonic(\n  data: string | Buffer,\n  password: string,\n  triplesecDecrypt?: TriplesecDecryptSignature\n) {\n  const dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');\n  try {\n    return await decryptMnemonicBuffer(dataBuffer, password);\n  } catch (err) {\n    if (err instanceof PasswordError) {\n      throw err;\n    }\n    const data = await decryptLegacy(dataBuffer, password, triplesecDecrypt);\n    return data.toString();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}